<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtHgold 4.05 (hacked by jacob navia)">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

        
<title> {A container library for C}</title>
 
<h1 align="center"><i>A container library for C</i> </h1>

<h3 align="center">Jacob Navia </h3>

<h3 align="center"> </h3> 




<div class="p"><!----></div>
 <BR CLEAR=LEFT><BR><BR>
<img src="Containers.png" alt="Figure">

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>
<h1>Contents </h1>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1"
>1.1&nbsp; Design goals</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.1"
>1.1.1&nbsp; Error analysis</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.2"
>1.1.2&nbsp; Full feature set</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.3"
>1.1.3&nbsp; Abstraction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1.4"
>1.1.4&nbsp; Performance</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.2"
>1.2&nbsp; How the functions are specified in this document.</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; The interface concept</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; Error handling</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; The different containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.1"
>2.4.1&nbsp;  Single and double linked lists</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.2"
>2.4.2&nbsp; Flexible arrays (vector)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.3"
>2.4.3&nbsp; ValArray: Arrays of numbers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.4"
>2.4.4&nbsp; String collection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.5"
>2.4.5&nbsp; Bit-string</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.6"
>2.4.6&nbsp; Dictionary</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.7"
>2.4.7&nbsp; Hash Table</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.8"
>2.4.8&nbsp; AVL trees</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.9"
>2.4.9&nbsp; Scapegoat trees</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.10"
>2.4.10&nbsp; Bloom Filter</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.11"
>2.4.11&nbsp; Queue</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.12"
>2.4.12&nbsp; Deque</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4.13"
>2.4.13&nbsp; Buffers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5"
>2.5&nbsp; Types used by the library</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.1"
>2.5.1&nbsp; CompareInfo</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.2"
>2.5.2&nbsp; CompareFunction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.3"
>2.5.3&nbsp; Save function</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.4"
>2.5.4&nbsp; Read function</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.5"
>2.5.5&nbsp; Error function</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.5.6"
>2.5.6&nbsp; Destructor function</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; Creation of a container: Create</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; Destruction of a container: Clear and Finalize</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2.1"
>3.2.1&nbsp; Other creation functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; Adding an element to a container: Add and AddRange</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; Removing elements from a container</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.1"
>3.4.1&nbsp; Using an element as key</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.2"
>3.4.2&nbsp; Removing at a given position</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.3"
>3.4.3&nbsp; Using a container as a stack</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.4"
>3.4.4&nbsp; Batch removing</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; Retrieving elements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; Sorting a sequential container: Sort</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.7"
>3.7&nbsp; Copying a container: Copy</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.8"
>3.8&nbsp; Saving and loading a container to or from disk: Save and Load</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.9"
>3.9&nbsp; Inserting a container into another</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.9.1"
>3.9.1&nbsp; Sequential containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.9.2"
>3.9.2&nbsp; Associative containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.10"
>3.10&nbsp; Replace an element with another</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.10.1"
>3.10.1&nbsp; Sequential containers: ReplaceAt</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.10.2"
>3.10.2&nbsp; Associative containers: Replace</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11"
>3.11&nbsp; Looping through all elements of a container</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11.1"
>3.11.1&nbsp; Using a simple loop to iterate a container</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11.2"
>3.11.2&nbsp; Using the Apply function.</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.11.3"
>3.11.3&nbsp; Using iterators</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.12"
>3.12&nbsp; Setting and retrieving the state: GetFlags and SetFlags</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.13"
>3.13&nbsp; Retrieving the number of elements stored: Size</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.14"
>3.14&nbsp; Sizes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.14.1"
>3.14.1&nbsp; Sizeof</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.14.2"
>3.14.2&nbsp; SizeofIterator</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15"
>3.15&nbsp; Memory management</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15.1"
>3.15.1&nbsp; Memory manager objects</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15.2"
>3.15.2&nbsp; Pooled memory management</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15.3"
>3.15.3&nbsp; Heap of same size objects</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15.4"
>3.15.4&nbsp; Garbage collection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.15.5"
>3.15.5&nbsp; Multi-threading</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Masks</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.1"
>4.1.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1.2"
>4.1.2&nbsp; The API</a><br />











&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; Memory management</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.1"
>4.2.1&nbsp; The default memory manager</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2.2"
>4.2.2&nbsp; The Heap interface: iHeap</a><br />







&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; Pooled memory interface: iPool</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; Error handling Interface: iError</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; The iterator interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5.1"
>4.5.1&nbsp; The interface</a><br />







&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; The observer interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6.1"
>4.6.1&nbsp; Caveats</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6.2"
>4.6.2&nbsp; The interface</a><br />




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6.3"
>4.6.3&nbsp; Notifications messages</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; The List interfaces: iList, iDlist</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.1"
>5.1.1&nbsp; General remarks</a><br />



















































&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1.2"
>5.1.2&nbsp; Specializations of linked lists</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; Double linked lists: iDlist</a><br />


&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; The Vector interface: iVector</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3.1"
>5.3.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3.2"
>5.3.2&nbsp; The API</a><br />




















































&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4"
>5.4&nbsp; The bit-string container: iBitString</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.1"
>5.4.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4.2"
>5.4.2&nbsp; API</a><br />





















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5"
>5.5&nbsp; The string collection container: istrCollection, iWstrCollection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5.1"
>5.5.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5.2"
>5.5.2&nbsp; API</a><br />















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6"
>5.6&nbsp; The dictionary container: iDictionary</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6.1"
>5.6.1&nbsp; The dictionary interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6.2"
>5.6.2&nbsp; The API</a><br />






























&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7"
>5.7&nbsp; The TreeMap interface: iTreeMap</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7.1"
>5.7.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8"
>5.8&nbsp; Hash Table: iHashTable</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8.1"
>5.8.1&nbsp; The interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8.2"
>5.8.2&nbsp; The API</a><br />



















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9"
>5.9&nbsp; Queues: iQueue</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9.1"
>5.9.1&nbsp; Interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9.2"
>5.9.2&nbsp; The API</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.10"
>5.10&nbsp; Deque: iDeque</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.10.1"
>5.10.1&nbsp; Interface</a><br />

















&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11"
>5.11&nbsp; Bloom filters</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11.1"
>5.11.1&nbsp; The interface: iBloomFilter</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.11.2"
>5.11.2&nbsp; The API</a><br />






&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12"
>5.12&nbsp; Value arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12.1"
>5.12.1&nbsp; Operations</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12.2"
>5.12.2&nbsp; Slices and masks</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.12.3"
>5.12.3&nbsp; The interface</a><br />







































































&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.13"
>5.13&nbsp; Buffers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.13.1"
>5.13.1&nbsp; Stream buffers</a><br />














&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.13.2"
>5.13.2&nbsp; Circular buffers</a><br />











&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14"
>5.14&nbsp; The generic interfaces</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14.1"
>5.14.1&nbsp; Generic containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14.2"
>5.14.2&nbsp; Sequential containers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.14.3"
>5.14.3&nbsp; Associative containers</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; Adding conversions between containers</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; Unique</a><br />





&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; Paste</a><br />



&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; Mapcar</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1"
>8.1&nbsp; Partitioning</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2"
>8.2&nbsp; Data structures</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.1"
>8.2.1&nbsp; The generic part</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.2"
>8.2.2&nbsp; Lists</a><br />

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.3"
>8.2.3&nbsp; Double linked lists</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.4"
>8.2.4&nbsp; Vector</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.5"
>8.2.5&nbsp; Dictionary</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.6"
>8.2.6&nbsp; String collection</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.7"
>8.2.7&nbsp; The iterator implementation</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.8"
>8.2.8&nbsp; The timestamp field</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3"
>8.3&nbsp; The code</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.1"
>8.3.1&nbsp; List</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.2"
>8.3.2&nbsp; Queues</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.3"
>8.3.3&nbsp; The dictionary</a><br />




&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.4"
>8.3.4&nbsp; The bloom filter</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.5"
>8.3.5&nbsp; Debugging malloc</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.6"
>8.3.6&nbsp; The observer interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3.7"
>8.3.7&nbsp; ValArrays</a><br />


<a href="#tth_sEcindex">Index</a><br />* 

 <h1><a name="tth_chAp1">
Chapter 1 </a><br />Introduction</h1>
The objective of this proposal is to standardize the usage of common data structures within the context of the C language. The existence of a common standard interface for lists, hash tables, flexible arrays, and other containers has several advantages:

<ul>
<li>User code remains portable across different projects. In C, we all use the FILE abstraction, for instance. This abstraction allows software to be 
compatible across a large spectrum of machines and operating systems. Imagine what would happen if each project had to develop a file stream
abstraction again and again. This is the case when using lists, for instance. Today, we have in all significant projects written in C a list
module, and probably other ones like hash tables, etc.
<div class="p"><!----></div>
</li>

<li> Avoid duplication of effort. Most of the list or hash tables modules can't be debugged completely and are the source of never ending problems.
<div class="p"><!----></div>
</li>

<li> Lack of standards makes the merging of two projects very difficult since in most cases the interfaces and data structures are slightly
different. This leads to a complete rewrite of one of the modules, or to &#228;dapter" software that will translate from one list implementation
to the other, adding yet another layer of complexity to the merged project.
<div class="p"><!----></div>
</li>

<li> The language becomes more expressive since it becomes possible to reason within a high level environment. The lack of operations for
handling advanced data structures conditions programmers to use low level solutions like making an array with a fixed maximum size instead of a
list even if the programmer would agree that a list would be a more adequate solution to the problem. Confronted to the alternative of
developing yet another list module or opting for a low level solution many time constrained programmers will opt for the second solution.
<div class="p"><!----></div>
</li>

<li>
The portable specifications provide a common framework for library writers and compiler/system designers to build compatible yet strongly specialized implementations.
<div class="p"><!----></div>
</li>

<li>
The language becomes easier to analyze mathematically.
In their very interesting paper "Precise reasoning for programs using containers", Dillig, Dillig and Aiken
<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a> enumerate three main points that make program analysis easier using containers:

<ol type="1">
<li> Understanding the contents of a container doesn't require understanding the container's implementation
<div class="p"><!----></div>
</li>

<li> Verifying container implementations requires different techniques and degrees of automation than verifying their clients. Hence, separating
these two tasks allows us to choose the verification techniques best suited for each purpose.
<div class="p"><!----></div>
</li>

<li> There are orders of magnitude more clients of a container than there are container implementations. This fact makes it possible to annotate
a handful of library interfaces in order to analyze many programs using these containers.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li> It is possible to abstract from the nature of any container (using the <font size="+1"><tt>iterator</tt></font> construct) what allows a series of algorithms to
be written without having to bind them to a precise data structure. Containers present a uniform interface to the rest of the program.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<img src="AbstractIterator.png" alt="Figure">

<div class="p"><!----></div>
The big innovation of C in the eighties was its standard library, that made input/output portable across machines and implementations. The container library would replicate again that idea, at a higher level.

<div class="p"><!----></div>
The specifications presented here are completely scoped by the C99 specifications, and can be implemented even in compilers that do not implement C99 and remained within the C94 context. No language extensions are needed nor any are proposed.

<div class="p"><!----></div>
The interfaces proposed try to present complete packages, i.e. interfaces with all the necessary functions to allow the widest usage: Serialization, searching, and many other functionalities are included in the proposed standard to allow for maximum code portability. It can be argued that this makes  for "fat" containers, but if you read carefully you will notice that many things can be left out in systems that run in low memory or with feeble computing power.

<div class="p"><!----></div>
This documentation is composed of several parts:

<ol type="1">
<li> An introductory part where the general lines of the library are explained.
<div class="p"><!----></div>
</li>

<li> A specifications part where each function of the library is fully specified. This is the proposal for the next C standard.
<div class="p"><!----></div>
</li>

<li> An &#235;xamples" part that shows the uses of the library and allows you to have a better idea of how the usage of the library looks like.
<div class="p"><!----></div>
</li>

<li> An implementation part where the code of the sample implementation is discussed. This is designed as a guide for implementors to give them a basis to start with.
<div class="p"><!----></div>
</li>
</ol>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Design goals</h2>

     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Error analysis</h3>
It has been a  tradition in C to place raw performance as the most important quality of specifications. To follow this sacred cow C specifications
ignored any error analysis arguing that any specification of failure modes would damage "performance". No matter that raw machine performance
increased by several orders of magnitude, the cost of  a check for NULL was always "too expensive" to afford.

<div class="p"><!----></div>
This kind of mental framework was described by one of the people in the discussion group "comp.lang.c++" as follows:<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>

<blockquote>
 In C++, the program is responsible for ensuring that <b>all</b> parameters to
 the standard library functions are valid, not only the third parameter of
 <font size="+1"><tt>std::mismatch()</tt></font>. For example, also the first range for <font size="+1"><tt>std:mismatch()</tt></font>
 must be valid, one may not pass a start iterator from one container and
 end iterator from another, for example. However, STL does not guarantee
 any protection against such errors, this is just UB.
</blockquote>
These specifications try to break away from that frame of thought. Each function specifies a minimal subset of failure modes as a consequence of its 
error analysis. This allows user code to:

<ul>
<li> Detect and handle errors better.
<div class="p"><!----></div>
</li>

<li> Ensure that errors will always have the <b>same</b> consequences. One of the worst consequences of undefined behavior is that the same error can 
have completely different consequences depending on apparently random factors like previous contents of memory or previous allocation pattern.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
At the same time, the mandatory error checking consists mainly of checks that can be implemented with a few integer comparisons. For instance a check 
for zero is a single instruction in most processors. If implemented correctly the conditional jump after the comparison with zero is not taken in the 
normal case and correctly predicted by the processor. This means that the pipeline is not disturbed and the cost for the whole operation is much less than a cycle.

<div class="p"><!----></div>
Why is error analysis an essential part of any program specifications?

<div class="p"><!----></div>
Because <b>mistakes are a fact of life</b>. Good programmers are good most of the time only. Even very good programmers <i>do make mistakes<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>.</i> Software
must be prepared to cope with this fact in an orderly fashion because if failure modes are not specified they have catastrophic consequences and lead
to brittle software that crashes randomly.

<div class="p"><!----></div>
Note that error <i>analysis</i> is not error <i>handling</i>. Error handling is taking an action after an error, a task only the application can do.
What the library can do is to establish a framework where a user defined procedure receives enough information about the specific problem at hand.

<div class="p"><!----></div>
Error analysis means that for each function and each API:

<ul>
<li> An analysis is performed of what are the consequences of any error in its inputs. Error codes are used to pass detailed error information
to the error procedure.
<div class="p"><!----></div>
</li>

<li> During its execution, an analysis is done of each step that can fail.
<div class="p"><!----></div>
</li>

<li> The outputs of the function are left in a consistent state, errors provoking the undo of the previous steps in most cases, leaving the inputs
as they were before the function was called. This feature allows library functions to be restartable after an error. For instance an out of memory
condition can be corrected by freeing memory and retrying.
<div class="p"><!----></div>
</li>
</ul>
The library provides hooks for the users that can control each step and provide functions that can do the error handling, for instance logging the
error and jumping to a pre-established recovery point.

     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Full feature set</h3>
Another design goal is to offer to the user a full feature set, complete with serializing, iterators, search, read-only containers and all the features 
needed in most
situations. Other features are planned for later like multi-threading support. The objective here is to avoid incompatible and non portable extensions
because some essential feature is missing.

     <h3><a name="tth_sEc1.3">
1.3</a>&nbsp;&nbsp;Abstraction</h3>
The library is designed with the possibility of implementing abstraction like serial and associative containers that allow software to treat several 
containers in a way that abstract most of their features, improving code reuse by allowing to implement algorithms for a class of objects. This is
specially true in the iterators feature.

<div class="p"><!----></div>
It can be argued that the C language lacks many of the abstractions constructs of other languages like templates, inheritance, and many others.
All that is true, but the objective of this proposal is to show that those constructs are just an aid to developing abstractions, an aid that
is paid in added complexity for the resulting language, and in a limitation of what is feasible within a given framework. Since C has no 
framework, no preferred inheritance model, it is possible to create abstractions that are quite unconstrained: there is no framework precisely.

     <h3><a name="tth_sEc1.4">
1.4</a>&nbsp;&nbsp;Performance</h3> Even with all the tests, the performance of the library has been maintained at a high level compared to similar libraries
in other languages. The performance should improve if standardized because compiler writers could specialize their optimizations targeting this
code.

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;How the functions are specified in this document.</h2>
The specifications part of the proposal uses the same building blocks for each of the functions proposed.
<div class="p"><!----></div>
<b>Name</b>

<div class="p"><!----></div>
 The name of the function. Note that when using this name, the container interface should be always before: 
iList.Add, iDictionary.Add, etc.

<div class="p"><!----></div>
 The name is followed by the prototype defined as a function pointer. For the function <font size="+1"><tt>Add</tt></font> of the container <font size="+1"><tt>List</tt></font> we have

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(List&nbsp;*list,const&nbsp;void&nbsp;*data);

</pre></font> 
This means that <font size="+1"><tt>Add</tt></font> is a function pointer in the interface iList. It would be used as:
<font size="+1"><tt>iList.Add(list,data)</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
The minimal set of errors that can appear during the execution of the function is listed. Each implementation is free to add implementation specific errors to this list. Note that how the library behaves after an error is defined by the current error function in the container (if any), then by the behavior of the error function in the iError interface. This can be changed by the user by using the iError interface.

<div class="p"><!----></div>
<b>Returns:</b>
The return value of the operation. Normally, negative values are error codes, positive values means success, and zero means non fatal errors, more in the sense of a warning.

<div class="p"><!----></div>
 <h1><a name="tth_chAp2">
Chapter 2 </a><br />Overview</h1>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Containers</h2>
In the context of this library, a container is a data structure used to organize data within a single logical object that allows for adding, searching 
and removing data. In most containers the data is not further specified, but the library assumes that all elements of a container have the same type. 
The data can be anything, images, numbers, text, whatever. The only thing that the container knows is the size of the data, if we store a series of 
objects of the same size, or its address, if we store objects of different sizes. In the later case we store just a pointer in the 
container<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>.

<div class="p"><!----></div>
A special kind of containers, ValArrays, contain the basic types of the C language and the library treats them specially. There is one ValArray
for each elementary type. For character strings they are stored in &#223;tring collections", a term borrowed from the C# language.

<div class="p"><!----></div>
Each container has a way of iterating through all its elements by using an &#239;terator" auxiliary object, that returns each stored object in sequence. In 
sequential containers you can also iterate using an index variable, what can be cheaper than using iterators for arrays but very expensive in lists.

<div class="p"><!----></div>
All objects stored by the library are copied into the library, and the library is responsible for the management of the associated storage. If you do not want this, just store a pointer to the data and manage the data yourself.

<div class="p"><!----></div>
A container has a set of functions for accessing the elements it stores, called its <i>interface</i>. This object is a collection of function
pointers that provide the functionality of the container.  The interfaces are stored in writable memory and the user can, at run time, change the
behavior of a class of containers by changing the function pointer. This operation is called &#223;ubclassing" in this document.

<div class="p"><!----></div>
Subclassing allows the user to modify the behavior of a container, maybe adding some functionality, without having to write all the container from
scratch. The user of the library can:

<ul>
<li> Use the stored pointer to the original function to call the original functionality, and add some functionality after that call.
<div class="p"><!----></div>
</li>

<li> Add some functionality and call the stored pointer afterwards.
<div class="p"><!----></div>
</li>

<li> Replace completely the functionality by its own without calling any of the former functions.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Subclassing adds enormous flexibility to this design, since it makes possible to add functionality in a transparent way.

<div class="p"><!----></div>
Using the organization of the data as a classification criteria we have basically two different kinds of containers

<ul>
<li>1. Sequential containers
<div class="p"><!----></div>
</li>

<li>
2. Associative containers
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
A sequential container is organized in a linear order. We have a sequence starting at index zero up to the number of elements stored. Data items can be retrieved by index, and it makes sense to speak of a "next" and a "previous" element.

<div class="p"><!----></div>
Sequential containers can be contiguous (arrays) or disjoint (lists). In the first case access is very fast since it implies multiplying the index by the size of each element to get to any position in the data. In the second case access the nth element can be a lengthy operation since the chain of "next" or "previous" pointers must be followed for each access to a given position.

<div class="p"><!----></div>
An associative container stores an object divided in two parts: a key, that is used as a token for the data, and the data itself. It associates key/value pairs. Speed of access is fast, but not linear, and can degrade as new items are stored in it.

<div class="p"><!----></div>
In all cases, we have some basic properties of an abstract container that are common to all of them. 

<ul>
<li> Functions to implement the life-cycle of the object: creation, maintenance and destruction.
<div class="p"><!----></div>
</li>

<li> Functions to add, replace and remove elements from the container.
<div class="p"><!----></div>
</li>

<li> A function that returns the number of objects stored in the container.
<div class="p"><!----></div>
</li>

<li>
A function to report errors. This function (like all other function pointers) can be changed by the user of the library. In the sample implementation 
it defaults to a simple function that prints the error in the standard error stream.
<div class="p"><!----></div>
</li>

<li>
Each change in a container is recorded. This permits to validate pointers to a container: if the container has changed after the creation of the pointer, the pointer could be invalid.
<div class="p"><!----></div>
</li>

<li>
All containers use a standard object to allocate and manage memory. The library provides a default allocator that contains the standard C functions malloc, free, realloc and calloc. Each container class can contain an allocator pointer, or each container can contain an allocator. The provided
sample implementation has a per container allocator, but in many applications a per class allocator could be enough, or even a single global allocator
that would be used by the whole library.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Managing a sequence involves trade offs what performance is concerned. If the usage will involve frequent insertion and deletion of objects you will prefer a container that handles those operations in constant time: the time to add or delete an object doesn't increase with the number of elements in the container. Such a container will be unlikely to provide also access to a given element in constant time. Access is likely to be much slower, and what you gain in flexibility you loose in another dimension. It is the user of the library, the programmer, that decides what container fits best the intended usage.

<div class="p"><!----></div>
Since usage patterns change, however, the library tries to ensure that you can change the container you are using with minimal effort. If at the beginning of an application a list looked like a good solution but later an array, that provides constant time access is better suited, you can change the type of container without changing every line that uses it. The common vocabulary of the library makes this possible.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;The interface concept</h2>
Each container is defined by its interface, i.e. the table of functions it supports. For each interface, its name is composed of a lower case &#239;" followed by the container name: iList, iVector, istrCollection, etc.

<div class="p"><!----></div>
Each function of the interface receives always the container as its first argument. Obviously, the big exception is the creation function, that receives various arguments depending of which container or from what input, the container is to be created.

<div class="p"><!----></div>
For each container interface a global object exists that allows direct access to the function table without the need of creating a container to access it.

<div class="p"><!----></div>
This interface allows for simple access to each container using a very similar vocabulary:

<font size=+1><pre>
iList.Add(list,object);
istrCollection.Add(strcol,object);

</pre></font>
The objects stored in a container have always the same size. When storing objects of different sizes just store a pointer to the objects, since pointers have always the same size.

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Error handling</h2>
This specification describes the basic error handling that each function of the library must do. Other errors can appear in different implementations.

<div class="p"><!----></div>
Error handling has three different phases:

<ol type="1">
<li> <b>Detection</b>. All library functions detect blatantly wrong arguments, for instance a&nbsp;NULL pointer when an object is expected, or arguments out of their valid range, etc.
<div class="p"><!----></div>
</li>

<li> <b>Reporting.</b> When an error is detected the library calls the corresponding error function that receives a character string with the name of the 
function where the error was detected, and an integer error code. Error codes are always negative constants.
<div class="p"><!----></div>
</li>

<li> <b>Response.</b> The library's default response to an error is to print it in the standard error stream. This can be modified by the user at any time by calling the <font size="+1"><tt>SetErrorFunction</tt></font> API, replacing the default behavior with its own.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
At each error, the library should call the container instance specific error handling when there is one, or call the general error handling function in the iError interface. When it is not possible to call the instance specific error function, for instance when the instance parameter is&nbsp;NULL , the library calls the general error handling function in the iError interface<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>.

<div class="p"><!----></div>
The user of the library can either replace the default iError interface with a function that handles the error with a jump to a previously set recovery point, or treat the error locally using the return code. All errors are negative constants, it suffices to test if the result is less than zero.
<a name="errorcodes">
</a> 
The error codes defined by this specification are:
<a 
name="error-codes30"></a>

<ul>
<li>
CONTAINER_ERROR_BADARG

 One of the parameters passed to a function is invalid. This is the same as the <font size="-2">EDOM</font> error code used by the function errno. If an implementation uses the <font size="+1"><tt>errno</tt></font> mechanism it can set at each occurrence of this error also <font size="+1"><tt>errno</tt></font> to <font size="-2">EDOM</font>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation<a href="#tthFtNtAAG" name="tthFrefAAG"><sup>6</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The index is out of bounds. If an implementation uses the <font size="+1"><tt>errno</tt></font> mechanism it can set <font size="+1"><tt>errno</tt></font> to <font size="-2">ERANGE</font>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The object is read-only and the operation would modify it <a href="#tthFtNtAAH" name="tthFrefAAH"><sup>7</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_INTERNAL

 Unspecified error provoked by a problem in the implementation.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 A change in the underlying object has invalidated an iterator. If an implementation uses <font size="+1"><tt>errno</tt></font> it can set 
<font size="+1"><tt>errno</tt></font> to <font size="-2">EILSEQ</font><a href="#tthFtNtAAI" name="tthFrefAAI"><sup>8</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_FILE_READ

 Input error in a stream<a href="#tthFtNtAAJ" name="tthFrefAAJ"><sup>9</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_FILE_WRITE

 Output error in a stream.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_CONTAINER_FULL

 Implementations can limit the maximum number of elements a container can hold. This error indicates that the limit is reached.
<a href="#tthFtNtABA" name="tthFrefABA"><sup>10</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_BADPOINTER

 The debug implementation of <font size="+1"><tt>free()</tt></font> has discovered an incorrect pointer attempting to be freed<a href="#tthFtNtABB" name="tthFrefABB"><sup>11</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_BUFFEROVERFLOW

 The debug implementation of <font size="+1"><tt>free()</tt></font> discovered a buffer overflow.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_WRONGFILE

 You are trying to read a container from a stream that has no such container saved
<a href="#tthFtNtABC" name="tthFrefABC"><sup>12</sup></a>.
<div class="p"><!----></div>
</li>

<li> 

<div class="p"><!----></div>
CONTAINER_ERROR_DIVISION_BY_ZERO

 The library has detected an attempt to divide by zero<a href="#tthFtNtABD" name="tthFrefABD"><sup>13</sup></a>.
<div class="p"><!----></div>
</li>

<li>

<div class="p"><!----></div>
CONTAINER_ERROR_OVERFLOW

 An overflow was detected in an arithmetic operation. Implementations are encouraged to detect overflow in all operations that
can generate one and report it through this error.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Other errors can be defined by each implementation.

<div class="p"><!----></div>
The treatment of each error is done in the object defined by the <font size="+1"><tt>iError</tt></font> interface.

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;The different containers</h2>
All data structures in this section are known and used for several decades. Lists are a common feature of any data processing task since the sixties for instance. 
The library provides for abstract containers, and some examples of concrete ones for the elementary types.
We have:

<ul>
<li>Vectors. The general abstract vector container is implemented in the "Vector" container. This is a flexible array that allows for insertion/deletions, 
with no cost for insertion at the end in most cases. Concrete implementations for the elementary types are provided for bits (bit-strings), strings 
(null terminated), int/double/long double numeric data in the form of templates.
<div class="p"><!----></div>
</li>

<li>
Lists. Single linked lists (List) and double linked lists (Dlist) are provided. Lists of strings and wide character strings are specified too.
<div class="p"><!----></div>
</li>

<li>
Queue, Deque
<div class="p"><!----></div>
</li>

<li>
Trees (red/black trees, AVL trees)
<div class="p"><!----></div>
</li>

<li>
Dictionary. This is a simple implementation of a hash table with character keys. It comes in two flavours: 

<ol type="1">
<li> Single byte character keys
<div class="p"><!----></div>
</li>

<li> Wide character keys
<div class="p"><!----></div>
</li>
</ol>
<a href="#tthFtNtABE" name="tthFrefABE"><sup>14</sup></a>
<div class="p"><!----></div>
</li>

<li>
Hash Table. More complex implementation of a hash table with arbitrary (binary) keys, and automatic hash table resizing.
<div class="p"><!----></div>
</li>

<li> Buffers. Stream buffers (linear buffers that resize to accommodate more data) and circular buffers are provided.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp; Single and double linked lists</h3>
This containers consist of a header and a list of elements containing each a pointer to the next element in the chain, and a pointer to the data item 
stored. The end of the list is marked by a node that contains a&nbsp;NULL "next" pointer. Double linked lists contain an additional pointer to the previous 
element.

<div class="p"><!----></div>
This is a very flexible container, allowing you to add and delete elements easily just by rewriting some pointers. You can even split them in two 
sublists just by zeroing somewhere the "next" pointer.

<div class="p"><!----></div>
The price you pay for this flexibility is that sequential access is expensive, the cost of accessing the nth element increases linearly with n.

<div class="p"><!----></div>
Storage overhead is one or two pointers per element stored in the list for single/double linked lists..

<div class="p"><!----></div>
The data is stored directly after the pointer, there is no pointer to the data. This is a variable length structure with a fixed and a variable part. 
To avoid using a standard C99 feature that could be absent in older compilers, we use a semi-generic pointer indexed either by one (for older compilers) or by nothing (standard C).

<div class="p"><!----></div>
      <h4><a name="tth_sEc4.1.1">
4.1.1</a>&nbsp;&nbsp;Single linked lists of byte or wide character strings</h4>
A specialization of the single linked list is provided for multibyte or wide character strings. The rationale for this specialization is that
zero terminated strings are variable length records what would make them impossible to store into a standard list that needs records of the
same size.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Flexible arrays (vector)</h3>
This container is an array with added operations that allow the user to insert and delete elements easily. It will resize itself if needed.

<div class="p"><!----></div>
The access time is essentially the same as with a normal array. Insertion and deletion are possible but they are in general more expensive than with lists since the container must copy the elements to make place for a new element or to delete an element. An exception to this rule is the deletion of the last element that will be done in constant time since it implies only decrementing the number of elements in the container.

<div class="p"><!----></div>
The storage overhead for each element is zero since this container doesn't require any pointers per object stored.

<div class="p"><!----></div>
This container uses a reserve storage to avoid allocating new memory for each addition operation. This allows the <font size="+1"><tt>Add</tt></font> operation to be done in constant time in most occasions.

<div class="p"><!----></div>
Comparing vectors with plain arrays, there are following points to be made:

<ul>
<li> With plain arrays, a program cannot determine the array's capacity, which is to say, its dimension when it was allocated.  
The program code must supply this information independently, and must maintain that information always current.
<div class="p"><!----></div>
</li>

<li> There isn't any simple way to increase the size of our array, once it’s been allocated.  We often need to do that, rather than try to figure out 
in advance how large it should be.
<div class="p"><!----></div>
</li>

<li> When accessing the array there is no automatic way to check if the index is within bounds. We have to program all array access specially
if we want to make sure there are no index errors.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;ValArray: Arrays of numbers</h3>
This group is an specialization of flexible array. It features objects that contain numbers in different formats designed to facilitate operations
in numerical programming. There are ValArrays for the types <font size="+1"><tt>short</tt></font>, <font size="+1"><tt>int</tt></font>, <font size="+1"><tt>long</tt></font>, <font size="+1"><tt>float</tt></font>, <font size="+1"><tt>double</tt></font>,
<font size="+1"><tt>long double</tt></font>, <font size="+1"><tt>size_t</tt></font> and <font size="+1"><tt>long long</tt></font>. Each <font size="+1"><tt>ValArray</tt></font> has the same basic operations (addition, subtraction, etc)
but some members have specialized operations: trigonometric operations are defined only in floating point ValArrays, boolean operations only in the unsigned versions of the <font size="+1"><tt>int/short</tt></font> and the <font size="+1"><tt>long long</tt></font> types.

<div class="p"><!----></div>
ValArray functions come often in two flavors: The first uses two arrays where the left argument is both source and destination, and a second form where
a number is applied to the whole array. For instance we have <font size="+1"><tt>AddTo(leftArray</tt></font><b>,</b><font size="+1"><tt>rightArray)</tt></font> and <font size="+1"><tt>AddToScalar(Array</tt></font><b>,</b><font size="+1"><tt>number)</tt></font>.

     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;String collection</h3>
This container is designed to handle a collection of C strings. It is essentially an application of the flexible array container with some extra functionality to handle strings. It comes in two flavors, as strings in C: multi-byte and wide character strings.

     <h3><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Bit-string</h3>
This container is designed to handle arbitrary sequences of bits. Some algorithms that are easy to program with strings are much more complicated for bit-strings, like to one that mimics &#223;trstr" ("bit-strstr"). 

<div class="p"><!----></div>
The bits are packed with 8 bits per character unit. The overhead per bit is the size of the bit-string header only. No pointers are associated with each bit.

<div class="p"><!----></div>
     <h3><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;Dictionary</h3>
This is an associative container based on a hash table. It associates a text key with some arbitrary data. This container is not ordered. Access time to each element depends on how much elements are stored in it and on the efficacy of the hash function to maintain elements in different slots. Storage overhead per element is one pointer each, plus the size of the slot table. This is for a hash table with linked lists in each slot for managing collisions. Other implementations exist of course.

     <h3><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;Hash Table</h3>
This is a more sophisticated version of the dictionary hash table. It allows for keys of binary data and it has automatic resizing in case the table gets too crowded.

     <h3><a name="tth_sEc4.8">
4.8</a>&nbsp;&nbsp;AVL trees</h3>
This data structure allows for fast searching for data. You can store millions of records and find a given record with a few comparisons.

     <h3><a name="tth_sEc4.9">
4.9</a>&nbsp;&nbsp;Scapegoat trees</h3>
This is another form of trees. They can be more efficient than AVL trees, but from a container perspective they share the same characteristics.

     <h3><a name="tth_sEc4.10">
4.10</a>&nbsp;&nbsp;Bloom Filter</h3>
This is a probabilistic data structure used to quickly check if an element is not in a larger set of elements. It returns false positives with a given probability set when the container is built. Elements can be added to it but they can't be removed from the container. It stores no data, just a key.

     <h3><a name="tth_sEc4.11">
4.11</a>&nbsp;&nbsp;Queue</h3>
Queues are designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other. This container can be implemented as an adaptor using a single linked list as its base container. The sample implementation uses this strategy to show how adapters can look like. Other implementations can implement this container directly presenting the same interface.

     <h3><a name="tth_sEc4.12">
4.12</a>&nbsp;&nbsp;Deque</h3>
This is a linear container that allows for cheap insertions/deletions at both ends.

     <h3><a name="tth_sEc4.13">
4.13</a>&nbsp;&nbsp;Buffers</h3>
Buffers are containers used to hold data temporarily, either to be transmitted or stored into some medium, or to be filtered and used later
by other parts of the application. The library provides two types of buffers:

<ul>
<li> Stream buffers. They are a linear sequence of bytes, like a file. They resize automatically if they need to, and they have a <i>cursor</i>
that points to the position where the next item will be stored.
<div class="p"><!----></div>
</li>

<li> Circular buffers. They store the last <i>n</i> items of a stream. They can contain any item as in the vector container, or they can contain 
character strings, as in the string collection.
<div class="p"><!----></div>
</li>
</ul>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Types used by the library</h2>
Here is a complete list of all the auxiliary data types defined by the library.

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;CompareInfo</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagCompareInfo&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs;
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*ContainerLeft;
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*ContainerRight;
}&nbsp;CompareInfo;

</pre></font>
This structure will be passed to the comparison functions. The <font size="+1"><tt>ExtraArgs</tt></font> pointer will receive the pointer that was passed to the calling function. If both elements being compared are members of a single container, the <font size="+1"><tt>ContainerRight</tt></font> member will be&nbsp;NULL .

     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;CompareFunction</h3>
<a 
name="CompareFunction52"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*CompareFunction)(const&nbsp;void&nbsp;*elem1,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*elem2,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*ExtraArgs);

</pre></font>
This type defines the function used to compare two elements.
The result should be less than zero if elem1 is less than elem2, zero if they are equal, and bigger than zero if elem1 is bigger than element 2.

<div class="p"><!----></div>
The default comparison function is <font size="+1"><tt>memcmp</tt></font>. This function will compare all the object's area, including eventually padding bytes added by
compilers for alignment reasons. To minimize this problem always zero the objects before assigning the values. For instance:

<font size=+1><pre>
struct&nbsp;Data&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Age;&nbsp;//&nbsp;Here&nbsp;the&nbsp;compiler&nbsp;can&nbsp;introduce&nbsp;padding&nbsp;bytes
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;Weight;
};

int&nbsp;fn(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;Data&nbsp;m;
&nbsp;&nbsp;&nbsp;&nbsp;memset(&amp;m,0,sizeof(m));
&nbsp;&nbsp;&nbsp;&nbsp;m.Age&nbsp;=&nbsp;23;
&nbsp;&nbsp;&nbsp;&nbsp;m.Weight&nbsp;=&nbsp;76;
&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(DataCollection,&amp;m);
}

</pre></font>
By zeroing the structure before making the assignments, we have a known value in the padding bytes. If we make comparisons with memcmp, they will
work correctly.

<div class="p"><!----></div>
Obviously the best way to avoid this problem is to avoid any default comparison function by defining one.

<div class="p"><!----></div>
     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Save function</h3>
<a 
name="SaveFunction53"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*SaveFunction)(const&nbsp;void&nbsp;*element,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArg,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*OutputStream);

</pre></font>
This function should save the given element into the given stream.  The <font size="+1"><tt>ExtraArg</tt></font> argument receives any argument passed to the Save function.
The result should be bigger than zero if the operation completed successfully, zero or less than zero otherwise.

<div class="p"><!----></div>
What the save function does is unknown to the rest of the library, basically the only requirement is that its output should be understood by the
read function, when called to read each element. The size of the written data can be bigger (or smaller) than the size of each stored element,
according to the specific requirements of the application data. This allows to write save functions tha would write a complete data set, including
embedded objects into the stream. For instance a save function can save the contents pointed by a character pointer instead of the pointer value 
that would be meaningless when read again.

<div class="p"><!----></div>
The default save function provided by the implementation just writes the contents of each element into the stream. Embedded pointers aren't followed.

     <h3><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;Read function</h3>
<a 
name="ReadFunction54"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*ReadFunction)(void&nbsp;*element,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArg,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*InputStream);

</pre></font>
This function should read into the given element from the given stream. The <font size="+1"><tt>ExtraArg</tt></font> argument is passed to the container read function and allows to pass an argument to the user defined save function. The amount of data read is unknown to the rest of the software and the only requirement
is that it should reverse the work of the save function.

<div class="p"><!----></div>
The default read function provided by the implementation should read the contents of one element from the stream and add it to the result container.

<div class="p"><!----></div>
The result is bigger than zero if the operation completed successfully, zero or less than zero otherwise.

     <h3><a name="tth_sEc5.5">
5.5</a>&nbsp;&nbsp;Error function</h3>
<a 
name="ErrorFunction55"></a>

<font size=+1><pre>
typedef&nbsp;void&nbsp;(*ErrorFunction)(const&nbsp;char&nbsp;*functionName,int&nbsp;code,...);

</pre></font>
This function type is used to handle errors in each container. The first argument is the name of the function where the error occurred, the second is a 
negative error code. No checks are performed on the function name argument, and other information or messages could be included in the message.

<div class="p"><!----></div>
Note that this function is roughly compatible with the prototype of snprintf, and could be used with a format string, a buffer size, and a series of 
arguments corresponding to the arguments the format requires. The only problem is the conversion between <font size="+1"><tt>int</tt></font> and <font size="+1"><tt>size_t</tt></font>.

     <h3><a name="tth_sEc5.6">
5.6</a>&nbsp;&nbsp;Destructor function</h3>
<a 
name="DestructorFunction56"></a>

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*DestructorFunction)(void&nbsp;*object);

</pre></font>
This function type is called when an object is being destroyed from the container. An object is destroyed when:

<ul>
<li> An <font size="+1"><tt>Erase</tt></font> call is done.
<div class="p"><!----></div>
</li>

<li> A <font size="+1"><tt>Replace</tt></font> call is done.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>Clear</tt></font> call is done.
<div class="p"><!----></div>
</li>
</ul>
This function should free any memory used by pointers within the object <b>without</b> freeing the object memory itself. In most cases the memory
used by the library is <b>not</b> allocated with malloc. Its result type is less than zero when an error occurred or greater than zero when
it finished successfully.

 <h1><a name="tth_chAp3">
Chapter 3 </a><br />The common vocabulary: iGenericContainer</h1>
<img src="Vocabulary.png" alt="Figure">
<div class="p"><!----></div>
The library uses always the same words to represent similar actions in all containers. 

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Creation of a container: Create</h2>
Containers are created with a call to their "Create" function.  The first argument is the size of the objects that will be stored in the container. The second is optional and is a hint to the number of elements that will be stored in the container.
Note that if you want to store objects of different sizes you just store a pointer to those objects instead of the objects themselves.
The creation functions can have several arguments, the first being always the size of the elements that the container will hold. The prototype can be:

<font size=+1><pre>
Container&nbsp;*&nbsp;iContainer.Create(size_t&nbsp;elementsize,...);

</pre></font>
The creation function needs to allocate memory to hold the container. This memory will be allocated using the current memory manager that is always an implicit argument to all creation functions. The rationale behind this design decision is that you don't change your memory allocation strategy at each call to a container creation function. This simplifies the interface at the expense of making the change of allocation strategy more expensive.

<div class="p"><!----></div>
There is an abstract class of objects called "Generic container" that has all functions that are common to all containers. This is an abstraction,
and as such, it can't have any concrete examples: there is no creation function for a generic container. You can only create a concrete container, a list, a vector, etc. 

<div class="p"><!----></div>
Once created, and if the created container supports the generic interface, you can make a cast and treat the concrete container as an abstract member
of a mythical "generic" container. This can save you a lot of redundant code since your code is independent of the type of container and will run
with any object (even future objects) that support the generic container interface.

<div class="p"><!----></div>
As everything, there is no free lunch. Precisely because of its generality the generic interface is missing a lot of functionality that you will find
in the concrete containers interfaces. 

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Destruction of a container: Clear and Finalize</h2>
All containers support two cleanup functions:

<ol type="1">
<li>Clear: remove all elements. The header structure remains untouched. This can be used to free the memory when the container was created with the <font size="+1"><tt>Init</tt></font> function.
<div class="p"><!----></div>
</li>

<li>
Finalize: Remove all elements and the memory used by the container object using the allocator for this container. The container should NOT have been created using the <font size="+1"><tt>Init</tt></font> function.
<div class="p"><!----></div>
</li>
</ol>
The syntax is:

<ol type="1">
<li> <font size="+1"><tt>int iContainer.Clear(Container *);</tt></font>
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>int iContainer.Finalize(Container *);</tt></font>
<div class="p"><!----></div>
</li>
</ol>
The result of those functions is less than zero when something goes wrong, greater than zero otherwise.

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Other creation functions</h3>

<ol type="1">
<li>An implicit argument to all the creation functions is the current allocator, that is used to retrieve space for the container being built. To avoid changing the current allocator, what in multi-threaded environment would need acquiring a lock to that global variable, some containers support a creation function that receives an extra argument: a custom allocator.

<font size=+1><pre>
Container&nbsp;*&nbsp;iContainer.CreateWithAllocator(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*allocator,&nbsp;...);

</pre></font>
<div class="p"><!----></div>
</li>

<li>
Sometimes it can be useful for some containers (specially lists) to create the  header structure using an already existing space, for instance in the space for local variables. For this an 'Init' function can exist, that initializes a container within an existing space.
Since normally the detailed structure (and the size of course) of each container header is implementation dependent, you use the Sizeof function with an argument of&nbsp;NULL to get the size of the header. This can be used within a C99 compiler environment to allocate the space for that variable.
<a href="#tthFtNtABF" name="tthFrefABF"><sup>15</sup></a>
The declaration of the container header in C99 would be:

<font size=+1><pre>
int&nbsp;function(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;listSpace[iList.Sizeof(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;iList.Init(listSpace);
}

</pre></font>
If C99 is not available, the best way is to just print the size of the container you are interested in, and then use that value that should stay fixed 
for a given version. This can be automated and you can find in the Appendix 1, a small program that generates a series of <font size="+1"><tt>#defines</tt></font> with the 
values of the sizes of the containers described in this documentation
<a href="#tthFtNtABG" name="tthFrefABG"><sup>16</sup></a>.
<div class="p"><!----></div>
</li>

<li> Initializing with existing data
All containers support the <font size="+1"><tt>InitializeWith</tt></font> function. It will create a container using a table of elements to store. Its arguments are the size of 
the objects to be stored, the number of those objects, and a pointer to the table. The table should be a contiguous memory area.

<font size=+1><pre>
/*&nbsp;For&nbsp;sequential&nbsp;containers&nbsp;and&nbsp;TreeMap&nbsp;*/
Container&nbsp;*&nbsp;iContainer.InitializeWith(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;n,&nbsp;void&nbsp;*data);
/*&nbsp;For&nbsp;Dictionary&nbsp;*/
Container&nbsp;*&nbsp;iContainer.InitializeWith(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;n,&nbsp;char&nbsp;**&nbsp;Keys,void&nbsp;*data;

</pre></font>
<div class="p"><!----></div>
</li>
</ol>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Adding an element to a container: Add and AddRange</h2>
This operation adds the given element to a container. In sequential containers it is added at the end, in associative containers it is added at an unspecified position.

<font size=+1><pre>
int&nbsp;iContainer.Add(Container&nbsp;*,const&nbsp;&nbsp;void&nbsp;*element);

</pre></font>
The result of this operation is a positive integer if success, or an error code less than zero if the operation fails.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified in any way, it is copied into the container.

<div class="p"><!----></div>
Sequential containers support also the <font size="+1"><tt>AddRange</tt></font> API:

<font size=+1><pre>
int&nbsp;iContainer.AddRange(Container&nbsp;*,size_t&nbsp;n,const&nbsp;void&nbsp;*elements[]);

</pre></font>
This API allows you to pass a table of elements into a sequential container and add it with a single call.

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Removing elements from a container</h2>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Using an element as key</h3>
The functions <font size="+1"><tt>Erase</tt></font> and <font size="+1"><tt>EraseAll</tt></font> remove the given element from the container. 
The result is an integer greater or equal to zero or an error code less than zero if the element couldn't be added
<a href="#tthFtNtABH" name="tthFrefABH"><sup>17</sup></a> 
.

<div class="p"><!----></div>
The <font size="+1"><tt>EraseAll</tt></font> function is not needed for associative containers since each element in those data structures is unique.

<font size=+1><pre>
int&nbsp;iContainer.Erase(Container&nbsp;*,const&nbsp;void&nbsp;*element);
int&nbsp;iContainer.EraseAll(Container&nbsp;*,const&nbsp;void&nbsp;*element);

</pre></font>

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Removing at a given position</h3>
 The <font size="+1"><tt>Erase/EraseAt</tt></font> functions need to search for the given element before erasing it. For sequential containers you can use the &#203;raseAt" function, that will remove an element at a given position.

<font size=+1><pre>
int&nbsp;iContainer.EraseAt(Container&nbsp;*,size_t&nbsp;idx);

</pre></font>

For associative containers you use RemoveKey:

<font size=+1><pre>
int&nbsp;iContainer.RemoveKey(Container&nbsp;*,const&nbsp;void&nbsp;*Key);

</pre></font>

     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Using a container as a stack</h3>
Elements can be removed from the front or the back in sequential containers using it like a stack:

<font size=+1><pre>
int&nbsp;iContainer.PopBack(Container&nbsp;*d,void&nbsp;*outbuf);
int&nbsp;iContainer.PopFront(Container&nbsp;*d,void&nbsp;*outbuf);

</pre></font>
These functions copy the contents of the last or the first element into the given buffer. If the buffer is NULL, nothing is copied, but the
container is modified: the first or the last element is removed.

     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Batch removing</h3>
Several elements can be removed at once from a container using the <font size="+1"><tt>RemoveRange</tt></font> function. This function is implemented in sequential
containers only.

<font size=+1><pre>
int&nbsp;iContainer.RemoveRange(Container&nbsp;*c,size_t&nbsp;start,&nbsp;size_t&nbsp;end);

</pre></font>
This function removes the elements whose index is greater or equal than <i>start</i> and less than <i>end</i>. If <i>start</i> equals <i>end</i>
nothing is removed and the result is zero. If <i>end</i> is greater than the length of the container it will be adjusted to 1 element past the
end. If no elements are removed the result is zero, positive when one or more elements are removed. The result is a negative error code when an
error occurs.

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Retrieving elements</h2>
The GetElement function retrieves an element from a container. It comes in two different flavors, one for sequential containers, and another for associative ones.

<font size=+1><pre>
const&nbsp;void&nbsp;*iContainer.GetElement(const&nbsp;Container&nbsp;*,size_t&nbsp;index);
const&nbsp;void&nbsp;*iContainer.GetElement(const&nbsp;Container&nbsp;*,const&nbsp;void&nbsp;*Key);

</pre></font>
These functions return a pointer to the requested element or&nbsp;NULL if the element can't be retrieved. The resulting pointer points directly to the data 
stored in the container. This could be used to bypass all the flags that control the access to the container. For read-only containers, use the 
<font size="+1"><tt>CopyElement</tt></font> function that returns a copy of the requested data into a buffer.

<div class="p"><!----></div>
The function <font size="+1"><tt>GetRange</tt></font> retrieves a slice of a container returning a container of the same type with a copy of the elements storeds in the
given range:

<font size=+1><pre>
Container&nbsp;*iContainer.GetRange(const&nbsp;Container&nbsp;*src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start,&nbsp;size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
The pointer returned can be invalidated by some operations done to the container. For instance if you reverse the order of the elements in a container, 
a pointer to the element zero will point to something else than when you obtained it. If a container needs reallocating its data space because you
added an element, all the pointers that point to data elements of the container can be invalidated. In general <b>it is a bad idea to keep pointers 
to elements in a container that is being modified</b>


<div class="p"><!----></div>
 <b>Invariants:</b>
The given container is not modified in any way.

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Sorting a sequential container: Sort</h2>
The "Sort" function will sort a container in place. To keep the old, unsorted contents, make a copy of the container first.

<font size=+1><pre>
int&nbsp;iContainer.Sort(Container&nbsp;*);

</pre></font>

 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Copying a container: Copy</h2>
 The "Copy" function will make a fresh copy of a container. Some fields of the header are copied: the error and compare functions, the flags, and others. Memory will be allocated withe the source container allocator.

<font size=+1><pre>
newContainer&nbsp;*&nbsp;iContainer.Copy(const&nbsp;Container&nbsp;*);

</pre></font>


<div class="p"><!----></div>
 <b>Invariants:</b>
The input container is not modified.

 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Saving and loading a container to or from disk: Save and Load</h2>
The functions "Save" and "Load" will save / load the contents, state, and characteristics of a container into / from disk. They need an open file stream, open in binary mode, and in the correct direction: saving needs a stream open in the write direction, loading needs a stream open in the read direction.

<font size=+1><pre>
int&nbsp;Save(const&nbsp;Container&nbsp;*c,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;fn,void&nbsp;*arg);
Container&nbsp;*Load(FILE&nbsp;*stream,ReadGunction&nbsp;fn,void&nbsp;*arg);

</pre></font>
Both <font size="+1"><tt>Save</tt></font> and <font size="+1"><tt>Load</tt></font> provide default functions to save and load an element but they do a <i>shallow</i> save: pointers aren't followed 
to save the data they point to <a href="#tthFtNtABI" name="tthFrefABI"><sup>18</sup></a>.

 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Inserting a container into another</h2>

     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Sequential containers</h3>


<font size=+1><pre>
int&nbsp;(*InsertIn)(Container&nbsp;*destination,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;position,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Container&nbsp;*source);
int&nbsp;(*Append)(SequentialContainer&nbsp;*&nbsp;SC1,SequentialContainer&nbsp;*&nbsp;SC2);

</pre></font>
The <font size="+1"><tt>InsertIn</tt></font> function will insert into the "destination" container the contents of the <font size="+1"><tt>source</tt></font> container at the given position. The source is not modified in any way, and a copy of its data will be used. Both containers must be of the same type and store elements of  the same type. The library only tests the element size of each one.

<div class="p"><!----></div>
The <font size="+1"><tt>Append</tt></font> function is similar to InsertIn: the elements of the second container are appended at the end of the first one. The big difference 
is that the second container is destroyed. It is absorbed into the first: its elements are not copied but inserted.

     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;Associative containers</h3>

<font size=+1><pre>
int&nbsp;(*InsertIn)(Container&nbsp;*destination,&nbsp;Container&nbsp;*source);

</pre></font>
This function will insert into the destination container the source container using the source container keys. Otherwise the same conditions apply as to the sequential containers: the containers must be of the same type and store elements of the same type.

 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Replace an element with another</h2>

     <h3><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;Sequential containers: ReplaceAt</h3>

<font size=+1><pre>
int&nbsp;(*ReplaceAt)(Container&nbsp;*dst,size_t&nbsp;position,void&nbsp;*newData);

</pre></font>
Replaces the element at the given position with the new data. 

     <h3><a name="tth_sEc10.2">
10.2</a>&nbsp;&nbsp;Associative containers: Replace</h3>

<font size=+1><pre>
int&nbsp;(*Replace)(Dictionary&nbsp;*Dict,&nbsp;const&nbsp;char&nbsp;*Key,void&nbsp;*Value);

</pre></font>
Replaces the element with the given key. If the element is absent nothing is done.

 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Looping through all elements of a container</h2>
The user has  three methods for looping through all elements:

<ol type="1">
<li> Using a simple loop construct
<div class="p"><!----></div>
</li>

<li> Using the <font size="+1"><tt>Apply</tt></font> function
<div class="p"><!----></div>
</li>

<li> Using an iterator
<div class="p"><!----></div>
</li>
</ol>
One the most familiar design patterns  is the ITERATOR pattern, which ‘provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 

<div class="p"><!----></div>
Traditionally, this is achieved by identifying an ITERATOR interface that presents operations to initialize an iteration, to access the current element, to advance to the next element, and to test for completion; collection objects are expected to implement this interface, usually indirectly via an auxiliary object. 

<div class="p"><!----></div>
This is exactly the case in the iterator proposal here. Essential to the pattern is the idea that elements are accessed sequentially, but independently of their position in the collection; for example, labeling each element of a tree with its index in left-to-right order fits the pattern, but labeling each element with its depth does not. This traditional version of the pattern is sometimes called an EXTERNAL ITERATOR. 

<div class="p"><!----></div>
An alternative INTERNAL ITERATOR approach assigns responsibility for managing the traversal to the collection instead of the client: the client needs only to provide an operation, which the collection applies to each of its elements. The latter approach is simpler to use, but less flexible; for example, it is not possible for the iteration to affect the order in which elements are accessed, nor to terminate the iteration early. This is the algorithm followed by the <font size="+1"><tt>Apply</tt></font> function.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Using a simple loop to iterate a container</h3>

<div class="p"><!----></div>
You can iterate any sequential container with a simple loop. You use the "Size" function to limit the loop. At each loop step you get the corresponding element with the "GetElement" function, present in this form in all containers.

<font size=+1><pre>
//&nbsp;"Container"&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;some&nbsp;container
for&nbsp;(size_t&nbsp;i=0;&nbsp;i&lt;iContainer.Size(Container);&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;someType&nbsp;*element&nbsp;=&nbsp;iContainer.GetElement(Container,i);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Use&nbsp;"element"&nbsp;here.
}

</pre></font>
For associative containers you retrieve first a strCollection containing all keys using the <font size="+1"><tt>GetKeys</tt></font> function, present in all associative containers. Then, you retrieve each element by looping through the string collection that you have obtained in a similar manner to the sequential containers. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Using the Apply function.</h3>
<a 
name="Apply+general112"></a>
The <font size="+1"><tt>Apply</tt></font> function will iterate through all elements calling a given function for each one.1 Its prototype is:

<font size=+1><pre>
void&nbsp;iContainer.Apply(Container,&nbsp;//pointer&nbsp;to&nbsp;some&nbsp;container
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int(*Applyfn)(void&nbsp;*elem,void&nbsp;*arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);

</pre></font>
This function receives three arguments:

<ol type="1">
<li> A pointer to the container. <a href="#tthFtNtABJ" name="tthFrefABJ"><sup>19</sup></a>.
<div class="p"><!----></div>
</li>

<li> A function pointer that should point to a function that receives two arguments: the element of the container, and an extra argument where it can receive (and write to) global information about the search.  This extra argument is
<div class="p"><!----></div>
</li>

<li> The third one passed to the <font size="+1"><tt>Apply</tt></font> function. <font size="+1"><tt>Apply</tt></font> will pass this argument to the given function together with a pointer to the element retrieved from the container.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Using iterators</h3>
Iterators are objects returned by each container that allow you to iterate (obviously) through all elements of a container.
You use iterators like this:

<font size=+1><pre>
Iterator&nbsp;*it&nbsp;=&nbsp;iContainer.NewIterator(someContainer);
Mytype&nbsp;*Myobject;
for&nbsp;(myobject&nbsp;=&nbsp;it-&#62;GetFirst(it);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myobject!=&nbsp;NULL;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myobject&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;"myobject"&nbsp;here
}
iContainer.DeleteIterator(it);&nbsp;//&nbsp;dispose&nbsp;the&nbsp;iterator&nbsp;object

</pre></font>
Iterators provide a container-independent way of iterating that will work with any container, both sequential or associative. In associative containers the specific sequence is implementation defined, and in sequential containers is the natural sequence.

<div class="p"><!----></div>
The main objective for iterators is to break a dependence between an algorithm and the type of container it is working with. Since all containers
support iterators, you can write your code independently (to a great extent) from which specific iterator you are using.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input container could be modified in some implementations. A list of existing iterators is possible, to allow invalidating them in case of
modifications to the container for example.

<div class="p"><!----></div>
Iterators always support at least the following functions:

<font size=+1><pre>
void&nbsp;*iterator-&#62;GetFirst(iterator);
void&nbsp;*iterator-&#62;GetNext(iterator);
void&nbsp;*iterator-&#62;GetCurrent(iterator);

</pre></font>
All containers support the "NewIterator"  and "deleteIterator" methods:

<font size=+1><pre>
iterator&nbsp;*iContainer.NewIterator(Container);&nbsp;
int&nbsp;iContainer.deleteIterator(iterator);

</pre></font>
Iterators must be destroyed since they are allocated using the containers allocator.

<div class="p"><!----></div>
Sequential containers can support additional functions:

<font size=+1><pre>
void&nbsp;*iterator-&#62;GetLast(iterator);
void&nbsp;*iterator-&#62;GetPrevious(iterator);
void&nbsp;*iterator-&#62;Seek(iterator&nbsp;i,&nbsp;size_t&nbsp;position);

</pre></font>
This interface allows users to write fully general algorithms that will work with any container, independently of its internal structure. Obviously the 
performance can differ from container to container depending on usage.

<div class="p"><!----></div>
All iterators will become invalid if the underlying container changes in any way, except through the iterator itself.<a href="#tthFtNtACA" name="tthFrefACA"><sup>20</sup></a>
Each container can conceptually be seen as a sequence of <i>generations</i>, or <i>states</i>. Beginning with the fresh constructed state, the container
evolves until it reaches the destroyed state after the execution of the <font size="+1"><tt>Finalize</tt></font> function. This sequence of states interacts with an
iterator as follows: An iterator applies only to a <b>single</b> container state. Any modification of the container state, directly or
indirectly moves the state and invalidates the iterator.

<div class="p"><!----></div>
An implementation may catch some of the movements of the container in the state space and report an error when an iterator is used that belongs to 
a different container state. But not all access can be catched. If the user has pointers to an iterator's data and modifies this data without
using the container API an implementation may not catch this error.

<div class="p"><!----></div>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Setting and retrieving the state: GetFlags and SetFlags</h2>
Each container has a set of flags that can be read and written to change the container's behavior. The only flag that is defined by all containers
is the read-only flag. Implementations can extend this to offer different services like copy-on-write, or other applications. 

<div class="p"><!----></div>
The read-only flag means that no direct pointers to an element or to the whole data are returned, no functions that modify the
container are allowed to proceed and that the <font size="+1"><tt>Clear()</tt></font>
and <font size="+1"><tt>Finalize()</tt></font> APIs will not work. You must unset this flag to allow for destruction of the object.
<a href="#tthFtNtACB" name="tthFrefACB"><sup>21</sup></a>

<div class="p"><!----></div>
Using the state space concept introduced above, this flag freezes the state of a container disallowing any further evolution. The only API that
can modify the state is the <font size="+1"><tt>SetFlags</tt></font> API that can reset the state to a read/write state again.

 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;Retrieving the number of elements stored: Size</h2>
All containers support querying the number of elements stored. The prototype is:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;iContainer.Size(const&nbsp;Container&nbsp;*);

</pre></font>
There is no error return. If a&nbsp;NULL pointer is given to those functions the result is zero.

 <h2><a name="tth_sEc14">
14</a>&nbsp;&nbsp;Sizes</h2>

     <h3><a name="tth_sEc14.1">
14.1</a>&nbsp;&nbsp;Sizeof</h3>
This computes the total size used by the container in bytes, including the header structure and the data stored in the container. Any other overhead 
must be accounted for.

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;iContainer.Sizeof(const&nbsp;Container&nbsp;*);

</pre></font>

<div class="p"><!----></div>
If its argument is&nbsp;NULL , <font size="+1"><tt>Sizeof</tt></font> returns the size of the container header. This can be used to allocate space for a container as a local variable for instance.

<div class="p"><!----></div>
     <h3><a name="tth_sEc14.2">
14.2</a>&nbsp;&nbsp;SizeofIterator</h3>
Computes the size of the iterator for the given container. The objective here is to allow the declaration of the iterator as a local variable
to avoid having to free the iterator at the exit of the function.

<font size=+1><pre>
int&nbsp;Fn(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[iList.SizeofIterator(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;(Iterator&nbsp;*)buf;
&nbsp;&nbsp;&nbsp;&nbsp;iList.InitIterator(it);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Use&nbsp;iterator&nbsp;"it"&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;No&nbsp;need&nbsp;to&nbsp;call&nbsp;deleteIterator&nbsp;at&nbsp;exit
}

</pre></font>

<div class="p"><!----></div>
 <h2><a name="tth_sEc15">
15</a>&nbsp;&nbsp;Memory management</h2>

<div class="p"><!----></div>
All containers have a pointer to their allocator object. An allocator object is a simple interface that provides 4 functions:

<ol type="1">
<li> malloc: A function that receives a <font size="+1"><tt>size_t</tt></font> and returns a <font size="+1"><tt>void *</tt></font> pointing to a memory block of the requested size, or&nbsp;NULL if no more memory is available. Note that this function receives the number of <b>bytes</b> to allocate, not the number of items.<a href="#tthFtNtACC" name="tthFrefACC"><sup>22</sup></a>
<div class="p"><!----></div>
</li>

<li> realloc: A function that will resize a previously allocated block.
<div class="p"><!----></div>
</li>

<li> free: A function that will release the memory allocated previously with malloc/realloc.
<div class="p"><!----></div>
</li>

<li> calloc: a function that will allocate <font size="+1"><tt>n</tt></font> objects of <font size="+1"><tt>m</tt></font> size and clear the memory block to zero before returning it.
<div class="p"><!----></div>
</li>
</ol>
At the start of the library runtime a default allocator object exists that uses the four functions of the standard C library. Other allocator objects can be used, and the user can change the global allocator at any time. Each container retrieves the default allocator object when created, and stores it in the container descriptor. Any further change to the default allocator will not affect existing containers that have already an allocator. When changing the allocator you should do that before creating the container.

<div class="p"><!----></div>
Some containers are created without any heap management by default. You can introduce heap management by calling the <font size="+1"><tt>UseHeap</tt></font> function, that will install a new heap in the container. Other containers are always created with a heap, and you should pass them an allocator object for object creation.

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.1">
15.1</a>&nbsp;&nbsp;Memory manager objects</h3>
The library provides two memory manager objects:

<ol type="1">
<li> The default memory manager, that receives the standard C library functions; malloc, free, realloc and calloc.
<div class="p"><!----></div>
</li>

<li> The debug memory manager that implements the same functions with added functionality designed to:

<ul>
<li>Catch the "double free" problem.
<div class="p"><!----></div>
</li>

<li>
Catch the overflow of a memory block
<div class="p"><!----></div>
</li>

<li>
Catch freeing a block that wasn't allocated
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc15.2">
15.2</a>&nbsp;&nbsp;Pooled memory management</h3>
The problem with the traditional C memory management is that it requires that the programmer cares about each piece of RAM that is allocated by the program and follows the lifetime of each piece to ensure that it gets returned to the system for reuse. In today's software world, this is just impractical.

<div class="p"><!----></div>
A better strategy is to use a pool of memory where related memory allocations can b e done from a common pool. When the module finishes, all the allocated pool is freed just by destroying the whole pool. This is much easier to manage, and in many cases more efficient.
The proposed interface has the following functionalities:

<ol type="1">
<li> Creation. The creation function receives a memory allocator to use for this pool.
<div class="p"><!----></div>
</li>

<li> Alloc. This function receives a pool and a size and returns a memory block, or&nbsp;NULL if there is no more memory.
<div class="p"><!----></div>
</li>

<li> Clear. This erases all objects allocated in the pool without returning the memory to the system.
<div class="p"><!----></div>
</li>

<li> Destroy. This releases all memory and destroys all objects.
<div class="p"><!----></div>
</li>
</ol>
Note that there is no realloc, and that the "Clear" function is optional. Not all pools support it. The rationale for these decisions being that realloc would need to store the size of each block, what in a pool maintained by a single stack like pointer would be very expensive.

     <h3><a name="tth_sEc15.3">
15.3</a>&nbsp;&nbsp;Heap of same size objects</h3>
Many containers are used to store sets of objects of the same size. The library provides a specialized heap management software for this application. It stores vectors of objects of the same size. The interface provided is as follows:

<ul>
<li> Create. This function receives a memory manager object that will be used to allocate memory.
<div class="p"><!----></div>
</li>

<li> NewObject: returns an object to the application
<div class="p"><!----></div>
</li>

<li> AddToFreeList: Adds an object to the list of available objects
<div class="p"><!----></div>
</li>

<li> Size: Returns the size of the heap in bytes
<div class="p"><!----></div>
</li>

<li> DestroyFreeList: reclaims memory used by the free list
<div class="p"><!----></div>
</li>

<li> Destroy: Reclaims all memory used by the heap and the heap object
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc15.4">
15.4</a>&nbsp;&nbsp;Garbage collection</h3>
Automatic garbage collection is offered by some compiler systems as an alternative to traditional memory management. This solution is
not compatible with real time requirements, and is not practical in machines with very low memory configurations.

<div class="p"><!----></div>
In other cases however, it can be a real simplification since the programmer is relieved from the huge task of taking care of each
piece of memory and to cater its disposal. A simple memory model is proposed: you program as if the amount of memory was infinite
and never worry about freeing the memory you use. Periodically the collector starts collecting unused memory chunks and adds them
to the pool of available memory or releases it to the underlying operating system.

<div class="p"><!----></div>
This model is not the solution to all memory management problems. It can be a solution to some situations, specially when developing
in workstation environments where memory is freely available. The bugs that can appear are also very difficult to solve. One of the
most difficult is when you keep by mistake some reference to a large piece of memory making the recycling of the memory impossible.
In that case you have to search in all the code of the application for the reference that keeps the memory block marked as used, and that can
be very difficult in large applications.

     <h3><a name="tth_sEc15.5">
15.5</a>&nbsp;&nbsp;Multi-threading</h3>
In environments where multi-threading or other parallel programming constructs are possible, the implementation must provide for sequential
semantics, i.e. each operation should perform as described in this documentation with the additional caveat that any operation that modifies
a container must be <font size="+1"><tt>atomic</tt></font>, i.e. it can't be interrupted leaving the container in an unstable or incoherent state. It is up to the
implementation to ensure that if an atomic operation is interrupted, the inconsistent container state will be invisible to other processes
or threads accessing the container.

 <h1><a name="tth_chAp4">
Chapter 4 </a><br />The auxiliary interfaces</h1>
These interfaces are used by all the containers in the rest of the library. They provide basically three functions

<ul>
<li> Memory management with the <font size="+1"><tt>MemoryManager</tt></font> object.
<div class="p"><!----></div>
</li>

<li> Observer and circulation of notifications with <font size="+1"><tt>iObserver</tt></font>.
<div class="p"><!----></div>
</li>

<li> Error handling with the <font size="+1"><tt>iError</tt></font> interface.
<div class="p"><!----></div>
</li>

<li> Masks used to select items
<div class="p"><!----></div>
</li>
</ul>
<img src="Basic.png" alt="Figure">

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Masks</h2>
A mask is a sequence that contains boolean data used for selection of items in a sequential container. 
It is not specified if a mask is a bit string (i.e. a
strictly boolean array) or an array of chars or other integers used to hold the binary data. In all cases a value of the mask at a given position 
means <i>select</i> if it is different than zero, or <i>do not select</i> if it is zero.

<div class="p"><!----></div>
The interface offered by the mask object is very small. Masks can't be resized but they have an allocator to be able to reclaim the
memory they use when created. This allocator will be initialized to the current allocator when the mask is created.

     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Mask&nbsp;Mask;
typedef&nbsp;struct&nbsp;tagMaskInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(Mask&nbsp;*src1,Mask&nbsp;*src2);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*Copy)(Mask&nbsp;*src);
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*Create)(size_t&nbsp;length);
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CreateFromMask)(size_t&nbsp;length,char&nbsp;*data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(Mask&nbsp;*src1,Mask&nbsp;*src2);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Set)(Mask&nbsp;*m,size_t&nbsp;idx,int&nbsp;val);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Mask&nbsp;*);
}&nbsp;iMask;

</pre></font>

     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="And+\container12"></a> <font size="+1"><b>And</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(Mask&nbsp;*src1,Mask&nbsp;*src2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Stores into src1 the result of a logical AND operation between each element of src1 with the corresponding element of src2.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The masks are of different length.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation was performed, a negative error code if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container12"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets all elements of the mask to zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the mask was cleared, a negative error code if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container12"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*Copy)(Mask&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates a new mask and copies the contents of the given one into it.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new mask or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CreateFromMask+\container12"></a> <font size="+1"><b>CreateFromMask</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CreateFromMask)(size_t&nbsp;length,char&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new mask with the specified length and copies the given data into the mask. Each character in the input data is transformed into the
mask internal representation. The storage is obtained using the CurrentMemoryManager pointer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The data pointer is&nbsp;NULL 

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 No memory is available to perform the allocation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new mask or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container12"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*Create)(size_t&nbsp;length);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new mask with the specified length. The storage is obtained using the CurrentMemoryManager pointer. The data is initialized to zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 No memory is available to perform the allocation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new mask or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Finalize+\container12"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The memory used by the mask is reclaimed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the memory was reclaimed, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Not+\container12"></a> <font size="+1"><b>Not</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Not)(Mask&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Stores into src the result of a logical NOT operation: each bit is inverted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation was performed, a negative error code if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Or+\container12"></a> <font size="+1"><b>Or</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(Mask&nbsp;*src1,Mask&nbsp;*src2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Stores into src1 the result of a logical OR operation between each element of src1 with the corresponding element of src2.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The masks are of different length.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation was performed, a negative error code if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Set+\container12"></a> <font size="+1"><b>Set</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Set)(Mask&nbsp;*m,size_t&nbsp;idx,int&nbsp;val);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the given position to the given value if the value fits in the internal representation of the mask. If not, an implementation defined
conversion occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The index given is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the value was set or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container12"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Mask&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The number of elements in the mask is returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The mask pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of elements. If the mask pointer is&nbsp;NULL , the result is zero.

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container12"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Mask&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The number of bytes used by the given mask. If the argument is&nbsp;NULL the number of bytes of the header structure is returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>The number of bytes.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Memory management</h2>
Several interfaces implement different memory allocation strategies. This should give flexibility to the implementations, allowing it to use several memory allocation strategies within the same container.
<div class="p"><!----></div>
The library starts with the <font size="+1"><tt>default</tt></font> memory manager, that contains pointers to the default C memory management functions: malloc, free, realloc and calloc. Another memory manager is the <font size="+1"><tt>debug</tt></font> memory manager that should implement more checking and 
maybe offer hooks to the debugger. The sample
implementation shows how to implement several simple checks, but other implementations can extend this simple interface providing 
much more sophisticated controls<a href="#tthFtNtACD" name="tthFrefACD"><sup>23</sup></a>.

<div class="p"><!----></div>
<img src="MemoryManagement.png" alt="Figure">
<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;The default memory manager</h3>
The C language provides several functions to manage memory. The default MemoryManager object is built from the standard C memory allocation functions.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagMemoryManager&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*malloc)(size_t);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;(*free)(void&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*realloc)(void&nbsp;*,size_t);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*calloc)(size_t,size_t);
}&nbsp;ContainerMemoryManager;
extern&nbsp;ContainerMemoryManager&nbsp;*&nbsp;CurrentMemoryManager;

</pre></font>
At startup, the CurrentMemoryManager points to an object constructed with the functions of the C standard library. This is a required interface.
The user can change the object that "CurrentMemoryManager" points to another object that should have the same interface.

<div class="p"><!----></div>
This is the established procedure to build custom memory allocators to provide for special alignment requirements, improve speed, allocate objects
from the stack instead of the heap, and many other usages.

<div class="p"><!----></div>
The library can also include a debug version on top of the standard C functions, offering the same interface. Changing the CurrentMemoryManager to point to that object allows to switch to the debug version. The debug version of the sample implementation offers:

<ul>
<li>Detection of free() of a memory block not allocated by malloc().
<div class="p"><!----></div>
</li>

<li>
Detection of  writing past the end of the block in some cases.
<div class="p"><!----></div>
</li>

<li>
Detection of freeing a memory block twice.
<div class="p"><!----></div>
</li>
</ul>

<font size=+1><pre>
extern&nbsp;ContainerMemoryManager&nbsp;iDebugMalloc;

</pre></font>
This interface is optional. The sample implementation documents a possible implementation, see <a href="#Malloc"> 8.3.5Debugging malloc</a> on page&nbsp;<a href="#Malloc">pageref</a>
.

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;The Heap interface: iHeap</h3>
Some containers can benefit from a cacheing memory manager that manages a stock of objects of the same size. This is not required and not all implementations may provide it. If they do, the interface is:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(Container&nbsp;*c);

</pre></font>
The standard interface for the heap is:<a 
name="iHeap22"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagHeapObject&nbsp;ContainerHeap;
typedef&nbsp;struct&nbsp;_HeapAllocatorInterface&nbsp;{
&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*(*Create)(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*m);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*newObject)(ContainerHeap&nbsp;*heap);
&nbsp;&nbsp;&nbsp;void&nbsp;(*AddToFreeList)(ContainerHeap&nbsp;*heap,void&nbsp;*element);
&nbsp;&nbsp;&nbsp;void&nbsp;(*DestroyFreeList)(ContainerHeap&nbsp;*heap);
&nbsp;&nbsp;&nbsp;void&nbsp;(*Destroy)(ContainerHeap&nbsp;*heap);
&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*&nbsp;(*InitHeap)(size_t&nbsp;ElementSize,void&nbsp;*heap,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*m);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(ContainerHeap&nbsp;*heap);
}&nbsp;HeapInterface;
extern&nbsp;HeapInterface&nbsp;iHeap;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container22"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

ContainerHeap&nbsp;*iHeap.Create(size_t&nbsp;elementSize,&nbsp;MemoryManager&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new heap object that will use the given memory manager to allocate memory. All elements will have the given size. If the memory manager object pointer is&nbsp;NULL , the object pointed by CurrentMemoryManager will be used.

<div class="p"><!----></div>
<b>Returns:</b>a pointer to the new heap object or&nbsp;NULL , if an error occurred.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The element size is bigger than what the heap implementation can support..

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="InitHeap+\container22"></a> <font size="+1"><b>InitHeap</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*&nbsp;(*InitHeap)(void&nbsp;*heap,size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the given buffer to a heap header object designed to hold objects of <font size="+1"><tt>ElementSize</tt></font> bytes. The heap will use the given memory
manager. If the memory manager parameter is&nbsp;NULL the default memory manager is used.

<div class="p"><!----></div>
This function supposes that the <font size="+1"><tt>heap</tt></font> parameter points to a contiguous memory space at least enough to hold a <font size="+1"><tt>ContainerHeap</tt></font> object.
The size of this object can be obtainer by using the <font size="+1"><tt>iHeap.Size</tt></font> API with a&nbsp;NULL parameter.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new ContainerHeap object or&nbsp;NULL if there is an error. Note that the pointer returned can be different from the passed in
pointer due to alignment requirements.
 
<div class="p"><!----></div>
<br /><a 
name="newObject+\container22"></a> <font size="+1"><b>newObject</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;void&nbsp;*iHeap.newObject(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The heap returns a pointer to a new object or&nbsp;NULL if no more memory is left.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to an object or&nbsp;NULL if there is not enough memory to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="AddToFreeList+\container22"></a> <font size="+1"><b>AddToFreeList</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;size_t&nbsp;iHeap.AddToFreeList(ContainerHeap&nbsp;*heap,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given object to the list of free objects, allowing for recycling of memory without new allocations. The element pointer can be&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The heap pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of objects in the free list.
 
<div class="p"><!----></div>
<br /><a 
name="DestroyFreeList+\container22"></a> <font size="+1"><b>DestroyFreeList</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;void&nbsp;iHeap.DestroyFreeList(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases all memory used by the free list and resets the heap object to its state as it was when created.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The heap pointer is&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container22"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;iHeap.Finalize(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Destroys all memory used by the indicated heap and frees the heap object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The heap pointer is&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container22"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;iHeap.Sizeof(ContainerHeap&nbsp;*heap);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of bytes used by the given heap, including the size of the free list. If the argument <font size="+1"><tt>"heap"</tt></font> is&nbsp;NULL , the result is the size of the heap header structure (i.e. <font size="+1"><tt>sizeof(ContainerHeap)</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

void&nbsp;SomeFunction(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buffer[iHeap.Sizerof(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*ch;

&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;iHeap.InitHeap(buffer,200,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;iHeap.DestroyFreeList(ch);
}

</pre></font>
This example uses the variable length arrays that have been introduced in the C language by the latest standard (C99). The <font size="+1"><tt>Sizeof</tt></font> function
returns the size of the header object that is used to specify the size of the buffer. The buffer is passed to the <font size="+1"><tt>InitHeap</tt></font> function using
a number of objects of 200 and the default memory allocator.

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Pooled memory interface: iPool</h2>
<a 
name="iPool30"></a>
<img src="Pool.png" alt="Figure">
<div class="p"><!----></div>
Many containers could benefit from a memory pool. A memory pool groups all allocations done in a specific context and can be released in a single call. This allows the programmer to avoid having to manage each single piece of memory like the basic interface.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_tagPoolAllocatorInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Pool&nbsp;&nbsp;*(*Create)(ContainerMemoryManager&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*(*Alloc)(Pool&nbsp;*pool,size_t&nbsp;size);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*(*Calloc)(Pool&nbsp;*pool,size_t&nbsp;size);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;(*Clear)(Pool&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;(*Finalize)(Pool&nbsp;*);
}&nbsp;PoolAllocatorInterface;

</pre></font>
Note that there is no realloc function. Pooled memory is often implemented without storing the size of the block to cut overhead. Since a realloc function could be expensive, implementations are not required to provide it.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container30"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Pool&nbsp;*iPool.Create(ContainerMemoryManager&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new pool object that will use the given memory manager. If m is null, the object pointed by the CurrentMemoryManager will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new object or&nbsp;NULL if the operation couldn't be completed.

<div class="p"><!----></div>
 
<br /><a 
name="Alloc+\container30"></a> <font size="+1"><b>Alloc</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*iPool.Alloc(Pool&nbsp;*pool,size_t&nbsp;size);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Allocates size bytes from the pool pool. If there isn't enough memory to resize the pool  the result is&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the allocated memory or&nbsp;NULL if error.

<div class="p"><!----></div>
 
<br /><a 
name="Calloc+\container30"></a> <font size="+1"><b>Calloc</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*iPool.Calloc(Pool&nbsp;*pool,size_t&nbsp;n,size_t&nbsp;size);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates n objects of size &#223;ize" in a single block. All memory is initialized to zero. If there is no memory left it returns&nbsp;NULL ;

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the allocated memory or&nbsp;NULL if error.

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container30"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;iPool.Clear(Pool&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the pool and leaves the object as it was when created.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The pool pointer is&nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="Finalize+\container30"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;iPool.Finalize(Pool&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the pool and destroys the pool object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The pool pointer is&nbsp;NULL .

<div class="p"><!----></div>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Error handling Interface: iError</h2>
<a 
name="iError40"></a>
The &#239;Error" interface provides a default strategy for handling errors. The "RaiseError" function will be used as the default error function within the creation function for all containers that support a per container instance error function.

<font size=+1><pre>
typedef&nbsp;(*ErrorFunction)(const&nbsp;char&nbsp;*,int,...);
typedef&nbsp;struct&nbsp;{
&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*RaiseError)(const&nbsp;char&nbsp;*fname,int&nbsp;code,...);
&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*EmptyErrorFunction)(const&nbsp;char&nbsp;*fname,int&nbsp;code,...);
&nbsp;&nbsp;const&nbsp;char&nbsp;*(*StrError)(int&nbsp;errorCode);
&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(ErrorFunction);
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*NullPtrError)(const&nbsp;char&nbsp;*);
}&nbsp;ErrorInterface;

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="RaiseError+\container40"></a> <font size="+1"><b>RaiseError</b></font> <hr />


<font size=+1><pre>

&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError(const&nbsp;char&nbsp;*fname,int&nbsp;errcode,...);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The parameter "fname" should be the name of the function where the error occurs. The &#235;rrcode" parameter is a negative error code. The actual value of the code is defined for the cases mentioned in the section <a href="#errorcodes"> 2.3Error handling</a>. Other negative values can be defined by the implementation.

<div class="p"><!----></div>
Other parameters can be passed depending on the error. The sample implementation never passes anything else but the name of the function where the
error occurs and the error code.

<div class="p"><!----></div>
The behavior of the default error function is implementation specific. In the sample code this function will just print the error message in the standard error stream. Other implementations could end the program, log the error into a error stream, or do nothing.

<div class="p"><!----></div>
<b>Returns:</b>No return value

<div class="p"><!----></div>
 
<br /><a 
name="EmptyErrorFunction+\container40"></a> <font size="+1"><b>EmptyErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.EmptyErrorFunction(const&nbsp;char&nbsp;*fname,int&nbsp;errcode,...);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function can be used to ignore all errors within the library. It does nothing.

<div class="p"><!----></div>
 
<br /><a 
name="StrError+\container40"></a> <font size="+1"><b>StrError</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;const&nbsp;char&nbsp;*iError.StrError(int&nbsp;errorCode);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Converts the given error code in a character string. If the error code doesn't correspond to any error defined by the implementation a character string 
with an implementation defined value is returned.

<div class="p"><!----></div>
 
<br /><a 
name="SetErrorFunction+\container40"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;ErrorFunction&nbsp;iError.SetErrorFunction(ErrorFunction);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Changes the value of the default error function. If its argument is&nbsp;NULL , nothing is done, and the call is interpreted as a query of the current value.

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the default error function.
 
<div class="p"><!----></div>
<br /><a 
name="NullPtrError+\container40"></a> <font size="+1"><b>NullPtrError</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*NullPtrError)(const&nbsp;char&nbsp;*msg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This is a utility function equivalent to:

<font size=+1><pre>
int&nbsp;NullPtrError(const&nbsp;char&nbsp;*fname)
{
&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError(fname,CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
}

</pre></font>

<div class="p"><!----></div>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;The iterator interface</h2>
<img src="Iterator.png" alt="Figure">
<div class="p"><!----></div>
The iterator object exposes at least the functions "GetFirst", for initializing the loop, and "GetNext", for getting the next element in the sequence. 
The functions "NewIterator" and "deleteIterator" are specific to each container interface even if they all have the same syntax.

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Iterator&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetNext)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetPrevious)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetFirst)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetCurrent)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetLast)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*Seek)(Iterator&nbsp;*it,size_t&nbsp;pos);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(Iterator&nbsp;*it,&nbsp;void&nbsp;*data,&nbsp;int&nbsp;drection);
}&nbsp;Iterator;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetCurrent+\container51"></a> <font size="+1"><b>GetCurrent</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetCurrent)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Returns the element at the cursor position.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the current element or&nbsp;NULL , if the container is empty or an error occurs. If the container is read-only, a pointer to a copy of the element is returned. This pointer is valid only until the next iterator function is called.
 
<div class="p"><!----></div>
<br /><a 
name="GetFirst+\container51"></a> <font size="+1"><b>GetFirst</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetFirst)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function initializes the given iterator to the first element in the container. For sequential operators this is the element with index zero. In 
associative operators which element is the first is implementation defined and can change if elements are added or removed from the container.

<div class="p"><!----></div>
If the container is empty the result is&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the first element or&nbsp;NULL , if the container is empty or an error occurs. If the container is read-only, a pointer to a copy of the element 
is returned. This pointer is valid only until the next iterator function is called.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Iterator&nbsp;*myIterator;
List&nbsp;*myList;
myType&nbsp;*obj;&nbsp;//&nbsp;"myList"&nbsp;stores&nbsp;objects&nbsp;of&nbsp;type&nbsp;"myType"
myIterator&nbsp;=&nbsp;iList.NewIterator(myList);&nbsp;//&nbsp;Request&nbsp;iterator
for&nbsp;(obj&nbsp;=&nbsp;myIterator-&#62;GetFirst(myIterator);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;!=&nbsp;NULL;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&nbsp;myIterator-&#62;GetNext(myIterator))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Use&nbsp;obj&nbsp;here
}
iList.deleteIterator(myIterator);&nbsp;//&nbsp;Reclaim&nbsp;memory

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="GetNext+\container51"></a> <font size="+1"><b>GetNext</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetNext)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions de cursor at the next element and returns a pointer to its contents. If the iterator is at the end of the container the result is&nbsp;NULL 
and the iterator remains at the last position, a subsequent call to GetCurrent returns the last element.

<div class="p"><!----></div>
If the container is read-only, a pointer to a copy of the object is returned. This pointer is valid only until the next iterator function is called.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the next element or&nbsp;NULL , if the cursor reaches the last element. If the container is read-only, a pointer to a copy of the element is 
returned, valid until the next element is retrieved
 
<div class="p"><!----></div>
<br /><a 
name="GetPrevious+\container51"></a> <font size="+1"><b>GetPrevious</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetPrevious)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions de cursor at the previous element and returns a pointer to its contents. If the pointer is at the beginning of the container the
result is&nbsp;NULL and the iterator remains at the beginning, a subsequent call to GetCurrent will return the first element of the container.

<div class="p"><!----></div>
This function is meaningful only in sequential containers. Its existence in associative containers is implementation defined. Even in sequential 
containers, it can be very expensive to find a previous element, for instance in single linked lists. In those cases it can always return&nbsp;NULL .

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the previous element or&nbsp;NULL , if the cursor reached the first element already. If the container is read-only, a pointer to a copy of the 
element is returned.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Iterator&nbsp;*myIterator;
List&nbsp;*myList;
myType&nbsp;*obj;&nbsp;//&nbsp;"myList"&nbsp;stores&nbsp;objects&nbsp;of&nbsp;type&nbsp;"myType"
myIterator&nbsp;=&nbsp;iList.NewIterator(myList);&nbsp;//&nbsp;Request&nbsp;iterator
for&nbsp;(obj&nbsp;=&nbsp;myIterator-&#62;GetLast(myIterator);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;!=&nbsp;NULL;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&nbsp;myIterator-&#62;GetPrevious(myIterator))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Use&nbsp;obj&nbsp;here
}
iList.deleteIterator(myIterator);&nbsp;//&nbsp;Reclaim&nbsp;memory

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetLast+\container51"></a> <font size="+1"><b>GetLast</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetLast)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions the cursor at the last element and returns a pointer to it. Returns&nbsp;NULL if the container is empty.  If the container is read-only, a pointer 
to a copy of the element is returned.

<div class="p"><!----></div>
This function is meaningful only in sequential containers. Its existence in associative containers is implementation defined. Even in sequential 
containers, it can be very expensive to find the last element, for instance in single linked lists. In those cases it can always return&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Seek+\container51"></a> <font size="+1"><b>Seek</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*Seek)(Iterator&nbsp;*it,size_t&nbsp;pos);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Positions the given iterator at the indicated position and then returns a pointer to the element's data at that position. 
If the position is bigger than the last element of the container, the last element position will be used.

<div class="p"><!----></div>
This function is supported in sequential containers only.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the data of the given element or&nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Replace+\container51"></a> <font size="+1"><b>Replace</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Replace)(Iterator&nbsp;*it,void&nbsp;*data,&nbsp;int&nbsp;direction);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current object pointed by the given iterator with the new data. If the
<font size="+1"><tt><i>data</i></tt></font>
 argument is&nbsp;NULL the element is erased from the
container. If the 
<font size="+1"><tt><i>direction</i></tt></font>
 parameter is different from zero, in sequential containers the iterator will point to the next element,
otherwise it will point to the previous element. In associative containers this parameter is ignored and the iterator is always set to the next
element, if any.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_OBJECT_CHANGED

 The container has been modified and the iterator is invalid. Further calls always return&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The container is read only.

<div class="p"><!----></div>
<b>Returns:</b>A positive value if the element was changed or erased, zero if the container was empty, or a negative error code if an error occurred.

<div class="p"><!----></div>

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;The observer interface</h2>
<a 
name="observer60"></a>
In its general form, the observer design pattern can be defined as a one-to-many dependency between objects so that when one object 
changes state, all its dependents are notified and updated automatically. 

<div class="p"><!----></div>
When a container changes its state, specifically when elements are added or removed, it is sometimes necessary to update relationships that 
can be very complex.
The observer interface is designed to simplify this operation by allowing the container to emit <i>notifications</i> to other objects that have 
previously manifested interest in receiving them by <i>subscribing</i> to them. In general notifications are sent only when one of the defined
operations for a container occur, mostly operations that change the number of elements.

<div class="p"><!----></div>
This interface then, establishes a relationship between two software entities:

<ol type="1">
<li> The container, that is responsible for sending the notifications when appropriate
<div class="p"><!----></div>
</li>

<li> The receiver, that is an unspecified object represented by its callback function that is called when a change occurs that matches the
notifications specified in the subscription.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
Since this relationship needs both objects, it will be finished when either object goes out of scope or breaks the relationship for whatever 
reason. Both objects can unsubscribe (terminate) their relationship.

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Caveats</h3>

<ul>
<li>It is in general a bad idea to modify the object being observed during a notification since this could trigger other notification
messages. Implementations are not required to avoid this situation that is the responsability of the programmer. Contrary to the iterator interface
no error is issued when a possible infinite loop is started. Implementations may catch the error by limiting the number of recursive
invocations of this interface but they are not required to do so.
<div class="p"><!----></div>
</li>

<li>
Since all messages sent by the containers have different type of information in the same two arguments that each message is associated with,
there is no possible compile time control of the usage of the received pointers or numbers. The observer function must correctly 
discriminate between the different messages it can receive<a href="#tthFtNtACE" name="tthFrefACE"><sup>24</sup></a>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;void&nbsp;(*ObserverFunction)(const&nbsp;void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Operation,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo[]);

typedef&nbsp;struct&nbsp;tagObserverInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Subscribe)(void&nbsp;*ObservedObject,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback,&nbsp;unsigned&nbsp;Operations);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Notify)(const&nbsp;void&nbsp;*ObservedObject,unsigned&nbsp;operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo1,void&nbsp;*ExtraInfo2);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Unsubscribe)(void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback);
}&nbsp;ObserverInterface;
extern&nbsp;ObserverInterface&nbsp;iObserver;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="ObserverFunction+\container62"></a> <font size="+1"><b>ObserverFunction</b></font> <hr />


<font size=+1><pre>

typedef&nbsp;void&nbsp;(*ObserverFunction)(void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Operation,&nbsp;void&nbsp;*ExtraInfo[]);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function will be called by the interface when a notification is received for an observed object.  The call happens after all arguments have been processed, the actual work of the function is finished (when adding an object) or not yet done (when destroying an object). 
The container is in a consistent state. For the callbacks that are called when an object is deleted from a
container the call happens before any call to <font size="+1"><tt>free()</tt></font> and before any call to a destructor (if any) is done. For the calls that add an object
the callback is called after the container has been modified. 

<div class="p"><!----></div>
Arguments:

<ol type="1">
<li> <font size="+1"><tt>ObservedObject</tt></font>: Specifies the object that sends the notification, i.e. the container
that has the subscription. It is assumed that this container conforms to the <font size="+1"><tt>iGeneric</tt></font> interface.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Operation</tt></font>: The operation that provoked the notification. Since it is possible to subscribe to several operations with only one callback function,
this argument allows the callback to discriminate between the operation notifications.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>ExtraInfo</tt></font>: This argument is specific to each operation and conveys further information<a href="#tthFtNtACF" name="tthFrefACF"><sup>25</sup></a> for each operation.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
None of the arguments will be ever&nbsp;NULL or zero.
 
<div class="p"><!----></div>
<br /><a 
name="Subscribe+\container62"></a> <font size="+1"><b>Subscribe</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Subscribe)(void&nbsp;*ObservedObject,&nbsp;ObserverFunction&nbsp;callback,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Operations);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function establishes the relationship between the observed object (argument 1) and the observer, represented by its callback (argument 2).
The third argument establishes which operations are to be observed.
This operation performs an allocation to register the relationship in the observer interface tables, therefore it can fail with an out of memory condition.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The observed object pointer is&nbsp;NULL , the callback function pointer is&nbsp;NULL , or the operations argument is zero.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to proceed.

<div class="p"><!----></div>
<b>Returns:</b>An integer greater than zero if the relationship was established, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Notify+\container62"></a> <font size="+1"><b>Notify</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Notify)(void&nbsp;*ObservedObject,unsigned&nbsp;Operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo1,void&nbsp;*ExtraInfo2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function will be used by the container to send a message to the receiver callback. The arguments correspond roughly to the arguments the callback
function will receive. "Notify" will call all the objects that are observing <font size="+1"><tt>ObservedObject</tt></font> and that have subscribed to one of the 
operations
specified in the <font size="+1"><tt>Operation</tt></font> argument. This implies a search through the observer interface table, and possibly several calls, making
this function quite expensive. The time needed is roughly proportional to the number of registered callbacks and the complexity of the callbacks
themselves.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The ObservedObject pointer is&nbsp;NULL or the Operation argument is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number with the number of objects that received the notifications, zero if there was no match for the combination of observed object and operations specified, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Unsubscribe+\container62"></a> <font size="+1"><b>Unsubscribe</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Unsubscribe)(void&nbsp;*ObservedObject,&nbsp;ObserverFunction&nbsp;callback);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function breaks the relationship between the observed object and the observer. There are several combinations of both arguments:

<ul>
<li> The <font size="+1"><tt>ObservedObject</tt></font> argument is&nbsp;NULL . This means that the <font size="+1"><tt>callback</tt></font> object wants to break its relationship to all objects it is
observing. The observer interface will remove all relationships that contain this callback from its tables.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>callback</tt></font> argument is&nbsp;NULL . This means that the given <font size="+1"><tt>ObservedObject</tt></font> is going out of scope and wants to break all
relationships to all its observers. The interface removes from its tables all relationships that have this object as the observed object.
This happens normally immediately after the notification <font size="+1"><tt>FINALIZE</tt></font> is sent.
<div class="p"><!----></div>
</li>

<li> If both <font size="+1"><tt>callback</tt></font> and <font size="+1"><tt>ObservedObject</tt></font> are non&nbsp;NULL , only the matching relationships will be removed from the tables.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Notifications messages</h3>

<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table>
<tr><td width="98"><b>Operation</b> </td><td width="197"><b>Argument 1</b> </td><td width="177"><b>Argument 2</b></td></tr>
<tr><td width="98"></td></tr>

<tr><td width="98">
<div class="p"><!----></div>

<div class="p"><!----></div>
 </td></tr>
<tr><td width="98"><b>Operation</b> </td><td width="197"><b>Argument 1</b> </td><td width="177"><b>Argument 2</b></td></tr>
<tr><td width="98"></td></tr>

<tr><td width="98">Add</td><td width="197">Pointer to the new object</td><td width="177">&nbsp;NULL or slice specs if any</td></tr>
<tr><td width="98">AddRange</td><td width="197">A <font size="+1"><tt>size_t</tt></font> with the number of objects added</td><td width="177">Pointer to a table of <i>n</i> elements that were added</td></tr>
<tr><td width="98">Append</td><td width="197">A pointer to the object being appended. It is of the same type as the object emitting the notification</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Clear</td><td width="197">Pointer to the container being cleared</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Copy</td><td width="197">Pointer to the copy of the container</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Erase</td><td width="197">Pointer to the object being deleted. The object is still valid</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">EraseAt</td><td width="197">Pointer to object being deleted</td><td width="177">Position (as size_t)</td></tr>
<tr><td width="98">Finalize</td><td width="197">&nbsp;NULL </td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Insert</td><td width="197">Pointer to the new object being inserted</td><td width="177">A <font size="+1"><tt>size_t</tt></font> with the position of the object being inserted if applicable</td></tr>
<tr><td width="98">InsertIn</td><td width="197">Pointer to the object being inserted, that has the same type as the object sending the notification</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Pop</td><td width="197">Pointer to the object being popped</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">Push</td><td width="197">Pointer to the object being pushed</td><td width="177">&nbsp;NULL </td></tr>
<tr><td width="98">ReplaceAt</td><td width="197">Pointer to the old value</td><td width="177">Pointer to the new value</td></tr>
<tr><td width="98"></td></tr></table>
</center>
<div class="p"><!----></div>
Here is a complete example that demonstrates some of the above functions.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

include&nbsp;"containers.h"
static&nbsp;void&nbsp;fn(void&nbsp;*ObservedObject,&nbsp;unsigned&nbsp;operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraInfo[])
{
&nbsp;&nbsp;&nbsp;&nbsp;printf("Object&nbsp;is&nbsp;%p,&nbsp;operation&nbsp;is&nbsp;%d\n",ObservedObject,operation);
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayInt&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iValArrayInt.CreateSequence(24,0,1);

&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;array:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Subscribe(vInt,fn,CCL_ADD|CCL_FINALIZE);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Adding&nbsp;an&nbsp;integer\n");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Add(vInt,4096);
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Finalize(vInt);
}
OUTPUT:
Original&nbsp;array:&nbsp;
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;
Adding&nbsp;an&nbsp;integer
Object&nbsp;is&nbsp;0x100100080,&nbsp;operation&nbsp;is&nbsp;1
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;4096&nbsp;
Object&nbsp;is&nbsp;0x100100080,&nbsp;operation&nbsp;is&nbsp;16

</pre></font>
We setup our observer function calling the Subscribe API. We request to be notified when there is an addition and when the object
finalizes. Our callback function does nothing but print some of its arguments. We see that we get called when the requested operations are performed.

 <h1><a name="tth_chAp5">
Chapter 5 </a><br />The containers</h1>
<a 
name="List03"></a>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;The List interfaces: iList, iDlist</h2>
The list container appears in two flavors: 

<ul>
<li>single linked lists: the iList type
<div class="p"><!----></div>
</li>

<li>
double linked lists the iDlist type
<div class="p"><!----></div>
</li>
</ul>
The space overhead of single linked lists is smaller at the expense of more difficult access to the elements. It is up to the application programmer to decide which container fits best in his/her application
<a href="#tthFtNtACG" name="tthFrefACG"><sup>26</sup></a>.

<div class="p"><!----></div>
The interfaces of both containers are very similar. Double linked lists support all functions in single linked ones, and add a few more. To avoid unnecessary repetition we document here all the single linked list interface, then only the functions that the Dlist interface adds to it.
<a 
name="iList10"></a><a 
name="lists+single linked10"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagListInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(List&nbsp;*L,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(List&nbsp;*L,&nbsp;size_t&nbsp;n,const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(List&nbsp;*l1,List&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(List&nbsp;*L,int(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Back)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(List&nbsp;*L);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;List&nbsp;*L,const&nbsp;void&nbsp;*element);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Copy)(const&nbsp;List&nbsp;*L);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;List&nbsp;*list,size_t&nbsp;idx,void&nbsp;*OutBuffer);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Create)(size_t&nbsp;element_size);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;List&nbsp;*l1,const&nbsp;List&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(List&nbsp;*L,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(List&nbsp;*l,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(List&nbsp;*L,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseRange)(List&nbsp;*L,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(List&nbsp;*L);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Front)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;List&nbsp;*list);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;List&nbsp;*L,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;List&nbsp;*L);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*GetRange)(const&nbsp;List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;List&nbsp;*L,const&nbsp;void&nbsp;*SearchedElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Init)(List&nbsp;*aList,size_t&nbsp;element_size);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(List&nbsp;*L,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*InitWithAllocator)(List&nbsp;*aList,size_t&nbsp;element_size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(List&nbsp;*L,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(List&nbsp;*l,&nbsp;size_t&nbsp;idx,List&nbsp;*newData);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(List&nbsp;*L);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(List&nbsp;*L,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(List&nbsp;*L,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(List&nbsp;*l,size_t&nbsp;start,&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(List&nbsp;*L,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(List&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(List&nbsp;*l,&nbsp;size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(List&nbsp;*l,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;List&nbsp;*L,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(List&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*SelectCopy)(const&nbsp;List&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*SetAllocator)(List&nbsp;*l,&nbsp;ContainerMemoryManager&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(List&nbsp;*l,CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(List&nbsp;*v,DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(List&nbsp;*L,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(List&nbsp;*L,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;List&nbsp;*L);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;List&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(List&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(List&nbsp;*L,&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;ListInterface;

</pre></font>


<div class="p"><!----></div>
<img src="ListVocabulary.png" alt="Figure">

     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;General remarks</h3>
Lists are containers that store each element in a sequence, unidirectionally (single linked lists) or bidirectionally (double linked lists).
The advantage of linked lists is their flexibility. You can easily and with a very low cost remove or add elements by manipulating the links between the elements. Single linked lists have less overhead than their double linked counterparts (one pointer less in each node), but they tend to use a lot of computer power when inserting elements near the end of the list: you have to follow all links from the beginning until you find the right one.

<div class="p"><!----></div>
The list nodes themselves do not move around, only their links are changed. This can be important if you maintain pointers to those elements. Obviously, if you delete a node, its contents (that do not move) could be recycled to contain something else than what you expect.

<div class="p"><!----></div>
The iList interface consists (as all other interfaces) of a table of function pointers. The interface describes the behavior of the List container.

<div class="p"><!----></div>
The stack operations push and pop are provided with PushFront and PopFront because they have a very low cost, insertion at the start of a single linked list is very fast. PushBack is the equivalent of the <font size="+1"><tt>Add</tt></font> operation, but PopBack would have a very high cost since it would need going through all the list. 

<div class="p"><!----></div>
The list container features in some implementations a per list error function.  This is the function that will be called for any errors, except in  cases where no list object exists: the creation function, or the error of getting a&nbsp;NULL pointer instead of a list pointer. In those cases the general iError interface is used, and iError.RaiseError is called. The default value of the list error function is the function iError.RaiseError at the moment the list is created.

<div class="p"><!----></div>
Other implementations of this interface may specialize list for a certain category of uses: lists of a few elements would try to reduce overhead by eliminating a per list error function and replace it with the standard error function in iError, for instance, eliminating their fields in the header. If the read-only flag support is dropped, the whole "Flags" field can be eliminated. In such an implementation, the SetFlags primitive would always return an error code.

<div class="p"><!----></div>
The sample implementation of the list container supports the following state flags:

<font size=+1><pre>
#define&nbsp;CONTAINER_READONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1

</pre></font>
If this flag is set, no modifications to the container are allowed, and the Clear and Finalize functions will not work. Only copies of the data are handed out, no direct pointers to the data are available.

<font size=+1><pre>
#define&nbsp;CONTAINER_SORTED_FRONT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2
#define&nbsp;CONTAINER_SORTED_BACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4

</pre></font>
If this flag is set, the container is maintained always in sorted order, with the biggest element at the index zero for <font size="+1"><tt>CONTAINER_SORTED_FRONT</tt></font>
or with the biggest element at the end if <font size="+1"><tt>CONTAINER_SORTED_BACK</tt></font> is set. It is an error if both flags are set, and the results in that  case
are implementation defined.
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container11"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(List&nbsp;*l,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the container. It is assumed that "data" points to a contiguous memory area of at least ElementSize bytes. Returns a value greater than zero if the addition of the element to the list completed successfully, a negative error code otherwise. The error codes returned can be:

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The list or the data pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element was added or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

/*&nbsp;This&nbsp;example&nbsp;shows&nbsp;how&nbsp;to:&nbsp;
(1)&nbsp;Create&nbsp;a&nbsp;linked&nbsp;list&nbsp;of&nbsp;"double"&nbsp;data
(2)&nbsp;Fill&nbsp;it&nbsp;using&nbsp;the&nbsp;"Add"&nbsp;function
(3)&nbsp;Print&nbsp;it&nbsp;using&nbsp;the&nbsp;GetElement&nbsp;function&nbsp;*/
#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintList(List&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iList.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
static&nbsp;void&nbsp;FillList(List&nbsp;*&nbsp;AL,size_t&nbsp;siz)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;siz;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*AL&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;FillList(AL,10);
&nbsp;&nbsp;&nbsp;&nbsp;PrintList(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="AddRange+\container11"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(List&nbsp;*&nbsp;AL,size_t&nbsp;n,&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the n given elements to the end of the container. It is the same operations as the PushBack operation. It is assumed that "data" points to a contiguous memory area of at least n*ElementSize bytes. If <i>n</i> is zero no error is issued even if the array pointer or the data pointer are&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the data pointers are&nbsp;NULL , and n is not zero.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Append+\container11"></a> <font size="+1"><b>Append</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(List&nbsp;*list1,List&nbsp;*list2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Appends the contents of list2 to list1 and destroys list2.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list1 or list2 are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 One or both lists are read only.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintList(List&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iList.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
static&nbsp;void&nbsp;FillList(List&nbsp;*&nbsp;AL,size_t&nbsp;siz)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;siz;i++)&nbsp;{&nbsp;double&nbsp;d&nbsp;=&nbsp;i;&nbsp;iList.Add(AL,&amp;d);}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L1&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L2&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;FillList(L1,10);
&nbsp;&nbsp;&nbsp;&nbsp;FillList(L2,10);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Append(L1,L2);
&nbsp;&nbsp;&nbsp;&nbsp;PrintList(L1);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container11"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(List&nbsp;l,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element of the list. The first argument of the callback function receives an element of the list. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the list is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list or Applyfn are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

: The list is read-only and there is no more memory to allocate the buffer to copy each element.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
The list container of C++ has no direct equivalent, but in the algorithm part of the STL there is a "for_each" construct, that does essentially the same. Java and C# offer a similar "ForEach" functionality.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;int&nbsp;Callback(void&nbsp;*pElement,void&nbsp;*pResult)
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pElement;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*result&nbsp;=&nbsp;pResult;
&nbsp;&nbsp;&nbsp;&nbsp;*result&nbsp;+=&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
&nbsp;&nbsp;&nbsp;&nbsp;
void&nbsp;main(void)&nbsp;
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(list,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(list,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(list,Callback,&amp;sum);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Here&nbsp;sum&nbsp;should&nbsp;be&nbsp;5.
&nbsp;&nbsp;&nbsp;&nbsp;printf("%g\n",sum);
}

</pre></font>
The above example shows a function callback as used by &#196;pply". It receives two pointers, one to the current element and another to an extra argument that in this case contains a pointer to the sum. For each call to the callback, the function adds the contents of the element to the sum.

<div class="p"><!----></div>
The main function creates a list, adds two elements with the values 2 and 3, and then calls &#196;pply" to get their sum using the callback.
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container11"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

const&nbsp;void&nbsp;*(*Back)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the last element of the given list or&nbsp;NULL if the list is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The last element or&nbsp;NULL if the list is empty or an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container11"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The list header will not be destroyed, and its contents will be the same as when the list was initially created. It is an error to use this function when there are still active iterators for the container.<a href="#tthFtNtACH" name="tthFrefACH"><sup>27</sup></a>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*l;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iList.Clear(l);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container11"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(List&nbsp;*list,void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns one if the given data is stored in the list, zero otherwise. The "data" argument is supposed to point to an element at least ElementSize bytes. The list's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list or data are&nbsp;NULL .


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
C++ has std::find that does essentially the same . Java and C# have a "Contains" method.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Contains(list,&amp;data);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container11"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*Copy)(const&nbsp;List&nbsp;*L);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given list is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the given list's allocator.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
C++ has no direct equivalent but the assignment operator should work, Java and C# support a copy method.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*newList,*OldList;
&nbsp;&nbsp;&nbsp;&nbsp;newList&nbsp;=&nbsp;iList.Copy(OldList);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newList&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="CopyElement+\container11"></a> <font size="+1"><b>CopyElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;List&nbsp;*list,size_t&nbsp;idx,void&nbsp;*outBuffer);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the element data at the given position into the given buffer, assuming that at least ElementSize bytes of storage are available at the position pointed by the output buffer. The main usage of this function is to access data in a read only container for later modification.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer or the output buffer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if it failed.

<div class="p"><!----></div>

  <b>Notes:</b>
<div class="p"><!----></div>
Neither C# nor Java provide this functionality because the treatment of pointers in those languages makes the need for such a construct unnecessary.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;&nbsp;double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.CopyElement(list,3,&amp;d)&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;value&nbsp;at&nbsp;position&nbsp;3&nbsp;is&nbsp;%g\n",d);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container11"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*Create)(size_t&nbsp;element_size);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The creation function returns an empty List container, initialized with all the default values.
The current memory manager is used to allocate the space needed for the List header. The list is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the list with sizeof(void *) as the size parameter.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a newly created List or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given element size is zero or greater than what the implementation allows for maximum object size.

<div class="p"><!----></div>
Errors provoke the call of the current default error function of the library since this is the creation function and there isn't a container specific error function yet.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*ListOfDoubles&nbsp;=&nbsp;iList.Create(sizeof(double));

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container11"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elem_size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The creation function returns an empty List container, initialized with all the default values.
The given memory manager is used to allocate the space needed for the List header. The list is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the list with sizeof(void *) as the size parameter.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a newly created List or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given element size is zero or greater than what the implementation allows for maximum object size, or the given allocator pointer is&nbsp;NULL .

<div class="p"><!----></div>
Errors provoke the call of the current default error function of the library since this is the creation function and there isn't a container specific error function yet.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ContainerMemoryManager&nbsp;*myAllocator;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*ListOfDoubles&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.CreateWithAllocator(sizeof(double),myAllocator);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="deleteIterator+\container11"></a> <font size="+1"><b>deleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;deleteIterator(Iterator&nbsp;*it);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims the memory used by the given iterator object

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful or a negative error code.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container11"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;List&nbsp;*list1,const&nbsp;List&nbsp;*list2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given lists using the list comparison function of either list1 or list2 that must compare equal. If the list differ in their length, flags, or any other characteristic they compare unequal. If any of their elements differ, they compare unequal.
If both list1 and list2 are&nbsp;NULL they compare equal. If both list1 and list2 are empty they compare equal.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None


<div class="p"><!----></div>
 <b>Invariants:</b>
The two lists are not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the lists are equal, zero otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container11"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(List&nbsp;*list,void&nbsp;*const&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list the element that matches the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Erase(list,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;erased\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;CONTAINER_ERROR_NOTFOUND)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("No&nbsp;element&nbsp;with&nbsp;value&nbsp;2.3&nbsp;present\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;not&nbsp;erased.&nbsp;Error&nbsp;is&nbsp;\%s\n",iError.StrError(r));

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="EraseAll+\container11"></a> <font size="+1"><b>EraseAll</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(List&nbsp;*list,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list all elements that match the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="EraseAt+\container11"></a> <font size="+1"><b>EraseAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(List&nbsp;*list,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list the element at the given position.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred or a positive value that indicates that the element was removed.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.EraseAt(list,2);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Element&nbsp;at&nbsp;position&nbsp;2&nbsp;erased\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;code&nbsp;%d\n",r);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="EraseRange+\container11"></a> <font size="+1"><b>EraseRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;int&nbsp;(*EraseRange)(List&nbsp;*L,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list the given range, starting with the <font size="+1"><tt>start</tt></font> index, until the element before the <font size="+1"><tt>end</tt></font> index. If <font size="+1"><tt>end</tt></font>
is greater than the length of the list, it will be 'rounded' to the length of the list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number indicates success, zero means nothing was erased, and a negative number an error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;print_list(List&nbsp;*li)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(li);&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;%d",*(int&nbsp;*)iList.GetElement(li,i));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*li&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(li,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
&nbsp;&nbsp;&nbsp;&nbsp;iList.EraseRange(li,3,8);
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
}
OUTPUT:
&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9
&nbsp;0&nbsp;1&nbsp;2&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container11"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the list, including the list header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed. A negative error code indicates failure.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Finalize(list);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container11"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

const&nbsp;void&nbsp;*(*Front)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the first element of the given list or&nbsp;NULL if the list is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified. The resulting pointer is read-only.

<div class="p"><!----></div>
<b>Returns:</b>
The first element or&nbsp;NULL if the list is empty or an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetAllocator+\container11"></a> <font size="+1"><b>GetAllocator</b></font> <hr />


<font size=+1><pre>

ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the list's allocator object. If the list pointer is&nbsp;NULL it returns&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="GetElementSize+\container11"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the size of the elements stored in the given list. Note that this value can be different than the value given to the creation function because of alignment requirements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The element size.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

List&nbsp;*l;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iList.GetElementSize(l);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetElement+\container11"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*(*GetElement)(const&nbsp;List&nbsp;*list,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a read only pointer to the element at the given index, or&nbsp;NULL if the operation failed.  This function will return&nbsp;NULL if the list is read only.

<div class="p"><!----></div>
Use the CopyElement function to get a read/write copy of an element of the list.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified. The resulting pointer is read-only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;*(double&nbsp;*)iList.GetElement(list,3);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetFlags / SetFlags+\container11"></a> <font size="+1"><b>GetFlags / SetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;List&nbsp;*l);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(List&nbsp;*l,unsigned&nbsp;newFlags);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
GetFlags returns the state of the container flags, SetFlags sets the flags to a new value and returns the old value.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
The flags or zero if there was an error.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetRange+\container11"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*GetRange)(const&nbsp;List&nbsp;*list,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Selects a series of consecutive elements starting at position start and ending at position end.  Both the elements at start and end are included in the result.
If start is greater than end start and end are interchanged. If end is bigger than the number of elements in list, only elements up to the number of elements will be used. If both start and end are out of range an error is issued and&nbsp;NULL is returned.
The selected elements are copied into a new list. 


<div class="p"><!----></div>
 <b>Invariants:</b>
The original list remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL 

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 Both start and end are out of range.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new list containing the selected elements or&nbsp;NULL if an error occurs.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*range&nbsp;=&nbsp;iList.GetRange(list,2,5);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(range&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="IndexOf+\container11"></a> <font size="+1"><b>IndexOf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*IndexOf)(const&nbsp;List&nbsp;*l,const&nbsp;void&nbsp;*ElementToFind,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*args,size_t&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches for an element in the list. If found its zero based index is returned in the passed pointer "result". 

<div class="p"><!----></div>
Otherwise the result of the search is  
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
and the passed pointer will remain unmodified. The <font size="+1"><tt>args</tt></font> argument will be passed to the comparison function that is called by IndexOf.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer or element are&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input list and the data to be searched are not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if element is found or a negative value if not found or an error occurs.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.IndexOf(list,&amp;data,&amp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;CONTAINER_ERROR_NOTFOUND)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Not&nbsp;found\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;printf("Found&nbsp;at&nbsp;position&nbsp;%ld\n",idx);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Init+\container11"></a> <font size="+1"><b>Init</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*Init)(List&nbsp;*aList,size_t&nbsp;element_size);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the memory pointed by the <font size="+1"><tt>aList</tt></font> argument. The new list will use the allocator pointed by the current memory allocator.
It is assumed that the memory pointed by <font size="+1"><tt>aList</tt></font> contains at least the size of the header object. This size can be obtained by calling the Sizeof function with a&nbsp;NULL argument.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

//&nbsp;This&nbsp;example&nbsp;uses&nbsp;C99
void&nbsp;Example(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;aList[iList.Sizeof(NULL)];
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list&nbsp;=&nbsp;iList.Init((List&nbsp;*)aList);
}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="InitializeWith+\container11"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,const&nbsp;void&nbsp;*Data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Construct a new list from the given data. It is assumed that
<font size="+1"><tt><i>Data</i></tt></font>
 points to a memory area that contains at least
<font size="+1"><tt><i>n</i></tt></font>
 items 
of
<font size="+1"><tt><i>elementSize</i></tt></font>
 bytes each.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Data argument is&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The new list or&nbsp;NULL if an error occurs

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="InitWithAllocator+\container11"></a> <font size="+1"><b>InitWithAllocator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*InitWithAllocator)(List&nbsp;*aList,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;element_size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the memory pointed by the <font size="+1"><tt>aList</tt></font> argument. The new list will use the given allocator.
It is assumed that the memory pointed by <font size="+1"><tt>aList</tt></font> contains at least the size of the header object. This size can be obtained by calling the Sizeof function with a&nbsp;NULL argument.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer is&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The given allocator is not modified.
 
<div class="p"><!----></div>
<br /><a 
name="InsertAt+\container11"></a> <font size="+1"><b>InsertAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(List&nbsp;*L,size_t&nbsp;idx,const&nbsp;void&nbsp;*newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new element. The new element will have the given index, that can go from zero to the list count inclusive, i.e. one more than the number of elements in the list. In single linked lists the cost for this operation is proportional to idx.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given list pointer or the element given are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.


<div class="p"><!----></div>
 <b>Invariants:</b>
The data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.InsertAt(list,2,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="InsertIn+\container11"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(List&nbsp;*Destination,&nbsp;size_t&nbsp;position,&nbsp;List&nbsp;*source);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the list given in  its third argument at the given position in the list pointed to by its first argument. The data is copied, and the source argument is not modified in any way. Both lists must have elements of the same type. The library only tests the size of each one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The source or the destination lists are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The destination list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The lists store elements of different size.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
/*&nbsp;Prints&nbsp;the&nbsp;contents&nbsp;of&nbsp;a&nbsp;list&nbsp;*/
static&nbsp;void&nbsp;PrintList(List&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Count&nbsp;%ld\n",(long)iList.Size(AL));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iList.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
/*&nbsp;Fills&nbsp;a&nbsp;list&nbsp;with&nbsp;10&nbsp;numbers.&nbsp;The&nbsp;10&nbsp;is&nbsp;hardwired...&nbsp;*/
static&nbsp;void&nbsp;FillList(List&nbsp;*&nbsp;AL,int&nbsp;start)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i+start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
/*&nbsp;Creates&nbsp;two&nbsp;lists:&nbsp;one&nbsp;with&nbsp;the&nbsp;numbers&nbsp;from&nbsp;0&nbsp;to&nbsp;9,&nbsp;another&nbsp;
&nbsp;&nbsp;&nbsp;with&nbsp;numbers&nbsp;100&nbsp;to&nbsp;109,&nbsp;then&nbsp;inserts&nbsp;the&nbsp;second&nbsp;into&nbsp;the&nbsp;
&nbsp;&nbsp;&nbsp;first&nbsp;at&nbsp;position&nbsp;5&nbsp;*/
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*AL&nbsp;=&nbsp;iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*AL1&nbsp;=iList.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;FillList(AL,0);
&nbsp;&nbsp;&nbsp;&nbsp;FillList(AL1,100);
&nbsp;&nbsp;&nbsp;&nbsp;iList.InsertIn(AL,5,AL1);
&nbsp;&nbsp;&nbsp;&nbsp;PrintList(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Count&nbsp;20
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;100&nbsp;101&nbsp;102&nbsp;103&nbsp;104&nbsp;105&nbsp;106&nbsp;107&nbsp;108&nbsp;109&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Load+\container11"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a list previously saved with the Save function from the stream pointed to by stream. If readFn is not&nbsp;NULL , it will be used to read each element. The <font size="+1"><tt>arg</tt></font> argument will be passed to the read function. If the read function is&nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A new list or&nbsp;NULL if the operation could not be completed. Note that the function pointers in the list are NOT saved, nor any special allocator that was in the original list. Those values will be the values by default. To rebuild the original state the user should replace the pointers again with the new list.

<div class="p"><!----></div>
 
<br /><a 
name="NewIterator+\container11"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 No more memory is available.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new iterator or&nbsp;NULL if there is no more memory left.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iList.NewIterator(list);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iList.deleteIterator(it);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="PopFront+\container11"></a> <font size="+1"><b>PopFront</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*PopFront)(List&nbsp;*L,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Pops the element at position zero copying it to the result pointer. If the "result" pointer is&nbsp;NULL , the first element is removed without any copying. The library supposes that result points to at least ElementSize bytes of contiguous storage. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the result pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if an element was popped, zero if the list was empty, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.PopFront(L,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("List&nbsp;empty\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;%d\n",r);
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;printf("OK,&nbsp;popped&nbsp;value&nbsp;%g\n",d);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="PushFront+\container11"></a> <font size="+1"><b>PushFront</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(List&nbsp;*L,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the given element at position zero. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the element pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.PushFront(list,&amp;d)&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error\n");

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RemoveRange+\container11"></a> <font size="+1"><b>RemoveRange</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*RemoveRange)(List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all elements having an index equal or greater than
<font size="+1"><tt><i>start</i></tt></font>
 and less than
<font size="+1"><tt><i>end</i></tt></font>
. If
<font size="+1"><tt><i>end</i></tt></font>
 is greater than the number of elements 
in the collection it will be adjusted to one more than the number of elements. If
<font size="+1"><tt><i>start</i></tt></font>
 is bigger than
<font size="+1"><tt><i>end</i></tt></font>
 the range is still valid and
starts with the value of
<font size="+1"><tt><i>end</i></tt></font>
 and ends with the value of
<font size="+1"><tt><i>start</i></tt></font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if no elements were removed. Otherwise returns a positive number for success, a negative error code in case of an error.
 
<div class="p"><!----></div>
<br /><a 
name="ReplaceAt+\container11"></a> <font size="+1"><b>ReplaceAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(List&nbsp;*list,size_t&nbsp;idx,const&nbsp;void&nbsp;*newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the list element at position idx with the new data starting at the position pointed to by "newData" and extending ElementSize bytes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the new element pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input data is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;6.7;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.ReplaceAt(list,2,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Reverse+\container11"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reverses the order of the given list: the head becomes the tail and the tail becomes the head. The original order is lost.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;print_list(List&nbsp;*li)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(li);&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;%d",*(int&nbsp;*)iList.GetElement(li,i));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*li&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(li,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Reverse(li);
&nbsp;&nbsp;&nbsp;&nbsp;print_list(li);
}
OUTPUT
&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9
&nbsp;9&nbsp;8&nbsp;7&nbsp;6&nbsp;5&nbsp;4&nbsp;3&nbsp;2&nbsp;1&nbsp;0

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RotateRight+\container11"></a> <font size="+1"><b>RotateRight</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(List&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates right the list by the indicated amount. The last n elements will be written to the start of
the array, and the rest will be shifted right.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).

<div class="p"><!----></div>
 
<br /><a 
name="RotateLeft+\container11"></a> <font size="+1"><b>RotateLeft</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(List&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates left the list by the indicated amount. The first n elements will be written to the end of
the list, and the rest will be shifted left to fill the empty n places.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size), or an error code less than zero if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Save+\container11"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;List&nbsp;*l,&nbsp;FILE&nbsp;*stream,SaveFunction&nbsp;SaveFn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given list are saved into the given stream. If the save function pointer is not&nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save. Otherwise a default save function will be used and arg will be ignored.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer or the stream pointer are&nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Select+\container11"></a> <font size="+1"><b>Select</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Select)(List&nbsp;*l,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Uses the given mask to select elements from the given list. The list is modified: all elements that have a corresponding value of zero in the mask are 
erased from the list. The length of the mask should be equal to the length of the list. If there is a destructor set up for the list, it is called for 
all the elements that are eliminated.


<div class="p"><!----></div>
 <b>Invariants:</b>
The mask is not modified.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the mask are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The mask and the list have different lengths.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value for success, a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
static&nbsp;void&nbsp;printList(List&nbsp;*v)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,*pi;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(v);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;iList.GetElement(v,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",*pi);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=1;i&lt;=24;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(vInt,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;iMask.Create(24);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;list:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;printList(vInt);

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;i&lt;24;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Set(m,i,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\nSelect&nbsp;of&nbsp;the&nbsp;list:\n");

&nbsp;&nbsp;&nbsp;&nbsp;iList.Select(vInt,m);
&nbsp;&nbsp;&nbsp;&nbsp;printList(vInt);

&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(vInt);
&nbsp;&nbsp;&nbsp;&nbsp;iMask.Finalize(m);
}
OUTPUT:
Original&nbsp;list:&nbsp;
&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;
&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;
Select&nbsp;of&nbsp;the&nbsp;list:
&nbsp;2&nbsp;&nbsp;4&nbsp;&nbsp;6&nbsp;&nbsp;8&nbsp;10&nbsp;12&nbsp;14&nbsp;16&nbsp;18&nbsp;20&nbsp;22&nbsp;24&nbsp;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SelectCopy+\container11"></a> <font size="+1"><b>SelectCopy</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*SelectCopy)(const&nbsp;List&nbsp;*l,const&nbsp;Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Uses the given mask to select elements from the given list. The list is not modified: all elements that have a corresponding value different of zero
in the mask are copied to the new list. The length of the mask should be equal to the length of the list.


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input list nor the mask are modified.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the mask are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The mask and the list have different lengths.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Insufficient ressources to create the result list.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new list or&nbsp;NULL if there was an error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
static&nbsp;void&nbsp;printList(List&nbsp;*v)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,*pi;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iList.Size(v);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pi&nbsp;=&nbsp;iList.GetElement(v,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",*pi);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*copy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=1;i&lt;=24;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(vInt,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;iMask.Create(24);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;list:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printList(vInt);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;i&lt;24;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Set(m,i,!(i&amp;1));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2d&nbsp;",!(i&amp;1));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\nSelect&nbsp;of&nbsp;the&nbsp;list:\n");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;copy&nbsp;=&nbsp;iList.SelectCopy(vInt,m);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printList(copy);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(vInt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(copy);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Finalize(m);
}
OUTPUT
Original&nbsp;list:&nbsp;
&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;24&nbsp;
&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;0&nbsp;
Select&nbsp;of&nbsp;the&nbsp;list:
&nbsp;1&nbsp;&nbsp;3&nbsp;&nbsp;5&nbsp;&nbsp;7&nbsp;&nbsp;9&nbsp;11&nbsp;13&nbsp;15&nbsp;17&nbsp;19&nbsp;21&nbsp;23&nbsp;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetCompareFunction+\container11"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

CompareFunction&nbsp;(*SetCompareFunction)(List&nbsp;l,CompareFunction&nbsp;f);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
if the f argument is non&nbsp;NULL , it sets the list comparison function to f.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only and the function argument is not&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the comparison function.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ErrorFunction&nbsp;fn,newfn;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;iList.SetCompareFunction(list,newfn);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetAllocator+\container11"></a> <font size="+1"><b>SetAllocator</b></font> <hr />


<font size=+1><pre>

List&nbsp;*SetAllocator(List&nbsp;*l,ContainerMemoryManager&nbsp;&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current allocator for the given list with the new one function if different from&nbsp;NULL . The list must be empty, and the new allocator must 
be able to allocate at least the size of the list header.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only and the function argument is not&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the allocator, or&nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<br /><a 
name="SetDestructor+\container11"></a> <font size="+1"><b>SetDestructor</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;SetDestructor(List&nbsp;*l,DestructorFunction&nbsp;fn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Sets the destructor function to its given argument. If the function argument is&nbsp;NULL nothing is changed and the call is interpreted as a query since the return value is the current value of the destructor function. If the list argument is&nbsp;NULL , the result is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the destructor.
 
<div class="p"><!----></div>
<br /><a 
name="SetErrorFunction+\container11"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(List&nbsp;*L,ErrorFunction);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given list with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is different from&nbsp;NULL . If 
the
<font size="+1"><tt><i>List</i></tt></font>
parameter is&nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only and the function argument is not&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function, or&nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container11"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;List&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the list.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
If the given list pointer is&nbsp;NULL , it returns  SIZE_MAX.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*li;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;bytes&nbsp;=&nbsp;iList.Size(li);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container11"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the list, including the header, and all data stored in the list. If <font size="+1"><tt>list</tt></font> is&nbsp;NULL , the result is the size of the <font size="+1"><tt>List</tt></font> structure.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the list or the size of the empty List container if the argument is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;siz&nbsp;=&nbsp;iList.Sizeof(list);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SizeofIterator+\container11"></a> <font size="+1"><b>SizeofIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the list iterator.  

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the list iterator.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;siz&nbsp;=&nbsp;iList.Sizeof(list);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Sort+\container11"></a> <font size="+1"><b>Sort</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Sort(List&nbsp;*list);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sorts the given list using the list comparison function. The order of the original list is destroyed. You should copy it if you want to preserve it. 

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if sorting succeeded, a negative error code if not.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

List&nbsp;*list;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.Sort(list)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="UseHeap+\container11"></a> <font size="+1"><b>UseHeap</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(List&nbsp;*list,ContainerMemoryManager&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds a heap manager to the given list, that should be empty. The heap manager will manage the free list and the allocation of new objects. Use this 
function when the list will hold a great number of elements. This function is optional and may not be present in all implementations.
If m is&nbsp;NULL , the current memory manager object will be used for allocating and reclaiming memory. Otherwise m should be a memory manager object.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOT_EMPTY

 The list is not empty or has already a heap.

<div class="p"><!----></div>
Portability:
This function is optional and may not be present in all implementations.

     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Specializations of linked lists</h3>
The sample implementation proposes a <font size="+1"><tt>stringlist</tt></font> container that can hold a list of strings. Its interface functions and all its vocabulary
are identical to the linked list one. It comes in two flavors:

<ul>
<li> Single byte character strings. The name of the interface is <font size="+1"><tt>iStringList</tt></font>.
<div class="p"><!----></div>
</li>

<li> Wide character strings. The name of the interface is <font size="+1"><tt>iWStringList</tt></font>.
<div class="p"><!----></div>
</li>
</ul>
In this specialization the function <font size="+1"><tt>GetElementSize</tt></font> returns always zero since it has no meaning in a list composed of strings of different
length.<a href="#tthFtNtACI" name="tthFrefACI"><sup>28</sup></a>

<div class="p"><!----></div>
The function <font size="+1"><tt>Sizeof</tt></font> that is very fast in normal lists (the element size is known), it is very expensive in string lists since all
the list needs to be scanned to add up the contents of each string.<a href="#tthFtNtACJ" name="tthFrefACJ"><sup>29</sup></a>

<div class="p"><!----></div>
Another difference is that the function <font size="+1"><tt>Save</tt></font> and the function <font size="+1"><tt>Load</tt></font> do not use the user function argument since they are specialized
to load and save character strings. The function argument can have any value. It has been maintained for compatibility with the rest of the software.

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Double linked lists: iDlist</h2>
<a 
name="Dlist20"></a>
<div class="p"><!----></div>
<img src="DListVocabulary.png" alt="Figure">

<div class="p"><!----></div>
 Differences with the list vocabulary are marked in bold.<BR CLEAR=LEFT><BR><BR>
<a 
name="lists+double linked20"></a>
<div class="p"><!----></div>
Double linked lists have a pair of pointers pointing to the next and to the previous element in the list. It is easy then, to move in  either direction through the list. The price to pay is a higher overhead for each element.
This container shares most of its interface with the single linked list container.  Here we document the functions that aren't already described for the list container.
<a 
name="iDlist20"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagDlistInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Dlist&nbsp;*dl,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(Dlist&nbsp;*l,size_t&nbsp;n,const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(Dlist&nbsp;*l1,Dlist&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Dlist&nbsp;*L,int(Applyfn)(void&nbsp;*elem,void&nbsp;*extraArg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Back)(const&nbsp;Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;Dlist&nbsp;*dl,const&nbsp;void&nbsp;*element);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Copy)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;Dlist&nbsp;*l,size_t&nbsp;idx,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Create)(size_t&nbsp;elementsize);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*CreateWithAllocator)(size_t,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*);
&nbsp;&nbsp;&nbsp;bool&nbsp;(*Equal)(const&nbsp;Dlist&nbsp;*l1,const&nbsp;Dlist&nbsp;*l2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(Dlist&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Dlist&nbsp;*AL);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Front)(const&nbsp;Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;Dlist&nbsp;*AL,int&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;Dlist&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*GetRange)(Dlist&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;Dlist&nbsp;*AL,const&nbsp;void&nbsp;*SearchedElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*args,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Init)(Dlist&nbsp;*dlist,size_t&nbsp;elementsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Dlist&nbsp;*,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(Dlist&nbsp;*AL,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Dlist&nbsp;*l,&nbsp;size_t&nbsp;idx,Dlist&nbsp;*newData);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Dlist&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Dlist&nbsp;*AL,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(Dlist&nbsp;*AL,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(Dlist&nbsp;*AL,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(Dlist&nbsp;*l,size_t&nbsp;start,&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(Dlist&nbsp;*AL,size_t&nbsp;idx,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Dlist&nbsp;*L,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*SelectCopy)(const&nbsp;Dlist&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(Dlist&nbsp;*l,CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Dlist&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Dlist&nbsp;*L,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Dlist&nbsp;*AL,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;Dlist&nbsp;*dl);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;Dlist&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(Dlist&nbsp;*l);
&nbsp;&nbsp;&nbsp;Dlist&nbsp;*(*Splice)(Dlist&nbsp;*list,void&nbsp;*pos,Dlist&nbsp;*toInsert,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;direction);
&nbsp;&nbsp;&nbsp;int&nbsp;(*UseHeap)(Dlist&nbsp;*L,const&nbsp;ContainerMemoryManager&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;DlistInterface;

</pre></font>

 
<div class="p"><!----></div>
<br /><a 
name="PopBack+\container20"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(List&nbsp;*L,void&nbsp;*result);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Pops the element at position zero copying it to the result pointer. If the "result" pointer is&nbsp;NULL , the last element is removed without any copying. Otherwise, the library supposes that result points to at least ElementSize bytes of contiguous storage. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the result pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if an element was popped, zero if the list was empty, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.PopBack(L,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("List&nbsp;empty\n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;%d\n",r);
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;printf("OK,&nbsp;popped&nbsp;value&nbsp;%g\n",d);

PushBack
Synopsis:
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(List&nbsp;*L,void&nbsp;*element);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the given element at position zero. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list or the element pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iList.PushFront(list,&amp;d)&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error\n");

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Splice+\container20"></a> <font size="+1"><b>Splice</b></font> <hr />


<font size=+1><pre>

Synopsis:
Dlist&nbsp;*(*Splice)(Dlist&nbsp;*list,&nbsp;void&nbsp;*Pos,&nbsp;Dlist&nbsp;*toInsert,int&nbsp;direction);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts a list (parameter "toInsert") into another one (parameter "list") at the given position
that should be an element of "list". The direction argument means to insert before the position if zero, after the position if not zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The list, the list to be inserted or the element pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The list is read only.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;The Vector interface: iVector</h2>
<a 
name="iVector30"></a>
<img src="VectorVocabulary.png" alt="Figure">
<div class="p"><!----></div>
 Vector vocabulary.
<div class="p"><!----></div>
<a 
name="Vector30"></a>The "vector" container is an array that resizes to accommodate new elements. Access is always checked against the array bounds.
Insertion and deletion of items are more expensive than in lists, and the cost increases linearly with the array size. Access is very cheap, since a multiplication suffices to get to any array position.

<div class="p"><!----></div>
Most functions of the interface are shared with the list, Dlist and the other sequential containers.

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;The interface</h3>
<a 
name="iVector31"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagVectorInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(Vector&nbsp;*AL,size_t&nbsp;n,const&nbsp;void&nbsp;*newvalues);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(Vector&nbsp;*AL1,&nbsp;Vector&nbsp;*AL2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Vector&nbsp;*AL,int&nbsp;(*Applyfn)(void&nbsp;*element,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Back)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqual)(const&nbsp;Vector&nbsp;*left,const&nbsp;Vector&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqualScalar)(const&nbsp;Vector&nbsp;*left,&nbsp;const&nbsp;void&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;Vector&nbsp;*AL,const&nbsp;void&nbsp;*element,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Copy)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;void&nbsp;**(*CopyTo)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Create)(size_t&nbsp;elementsize,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elemsiz,size_t&nbsp;startsiz,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;Vector&nbsp;*first,const&nbsp;Vector&nbsp;*second);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(Vector&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*Front)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;void&nbsp;**(*GetData)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;Vector&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*GetRange)(const&nbsp;Vector&nbsp;*AL,&nbsp;size_t&nbsp;start,&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*IndexIn)(Vector&nbsp;*SC,Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;Vector&nbsp;*AL,const&nbsp;void&nbsp;*data,void&nbsp;*ExtraArgs,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Init)(Vector&nbsp;*r,size_t&nbsp;elementsize,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Vector&nbsp;*V,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(Vector&nbsp;*AL,void&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Vector&nbsp;*AL,&nbsp;size_t&nbsp;idx,Vector&nbsp;*newData);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mismatch)(Vector&nbsp;*a1,Vector&nbsp;*a2,size_t&nbsp;*mismatch);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Vector&nbsp;*AL,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Vector&nbsp;*AL,const&nbsp;void&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(Vector&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(Vector&nbsp;*AL,size_t&nbsp;newcapacity);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(Vector&nbsp;*V,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(Vector&nbsp;*V,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Vector&nbsp;*AL,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SearchWithKey)(Vector&nbsp;*vec,size_t&nbsp;startByte,size_t&nbsp;sizeKey,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startIndex,void&nbsp;*item,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(Vector&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*SelectCopy)(Vector&nbsp;*src,Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(Vector&nbsp;*AL,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(Vector&nbsp;*l,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Vector&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Vector&nbsp;*AL,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Vector&nbsp;*AL,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(Vector&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;VectorInterface;

</pre></font>


     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container32"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Vector&nbsp;*AL,void&nbsp;*data);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the end of the container. It is the same operations as the PushBack operation. It is assumed that "data" points to a contiguous memory area of at least ElementSize bytes. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector or the data pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iVector.Add(AL,&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="AddRange+\container32"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Vector&nbsp;*AL,size_t&nbsp;n,&nbsp;void&nbsp;*data);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the n given elements to the end of the container. It is the same operations as the PushBack operation. It is assumed that "data" points to a contiguous memory area of at least n*ElementSize bytes. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise. If n is zero no error is issued even if the array pointer or the data pointer are&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector or the data pointers are&nbsp;NULL , and n is not zero.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data[]&nbsp;=&nbsp;{4.5,&nbsp;4.6,&nbsp;4.7&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iVector.Add(AL,3,&nbsp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Append+\container32"></a> <font size="+1"><b>Append</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;int&nbsp;(*Append)(Vector&nbsp;*AL1,&nbsp;Vector&nbsp;*AL2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds all elements of AL2 at the end of the first container AL1.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of the Vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The first argument is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container32"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Vector&nbsp;l,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element of the array. The first argument of the callback function receives an element of the array. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the array is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either list or Applyfn are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The list is read-only and there is no more memory to allocate the buffer to copy each element.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if no errors or a negative error code.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

static&nbsp;int&nbsp;Callback(void&nbsp;*pelement,void&nbsp;*pResult)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pelement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*result&nbsp;=&nbsp;pResult;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pResult&nbsp;+=&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;AddVector(Vector&nbsp;*l)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;sum&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*alist&nbsp;=&nbsp;iVector.Create(sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(list,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(alist,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(alist,Callback,&amp;sum);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Here&nbsp;sum&nbsp;should&nbsp;be&nbsp;5.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sum;
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container32"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*Back)(const&nbsp;Vector&nbsp;*v);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the last element of the given vector or&nbsp;NULL if the vector is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.

<div class="p"><!----></div>
<b>Returns:</b>
The last element or&nbsp;NULL if the vector is empty or an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container32"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Vector&nbsp;*l);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The vector header will not be destroyed, and its contents will be the same as when the array was initially created. It is an error to use this function when there are still active iterators for the container.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*Al;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iVector.Clear(Al);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="CompareEqual+\container32"></a> <font size="+1"><b>CompareEqual</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(ValArray&nbsp;*left,ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each element of the mask the result of comparing the corresponding elements of the left and right arrays. Conceptually this operation is: 
<font size=+1><pre>
Mask[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right[i])

</pre></font> 
If the mask argument is&nbsp;NULL it will be allocated and returned. 
The allocator used is the global memory manager. 
If it is not&nbsp;NULL it should contain at least enough positions to hold the data. If it doesn't it will be finalized using <font size="+1"><tt>iMask.Finalize</tt></font> and 
allocated with the necessary length.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was&nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given mask hasn't enough positions available.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The arrays are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray passed or allocated, or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CompareEqualScalar+\container32"></a> <font size="+1"><b>CompareEqualScalar</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(ValArray&nbsp;*left,ElementType&nbsp;right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each bit of the bitarray the result of comparing the elements of the left array with the right argument. 
Conceptually this operation is: 

<font size=+1><pre>
bit[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right)

</pre></font> 
If the bitarray argument is&nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. If it is not&nbsp;NULL it will be allocated if its length is less than the needed length.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was&nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container32"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(Vector&nbsp;*a,void&nbsp;*data);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the given data in the array. The "data" argument is supposed to point to an element at least ElementSize bytes. The array's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either array or data are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
One if the given data is stored in the array, zero otherwise. If either the data pointer or the array pointer are&nbsp;NULL it returns a negative error code.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*a;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Contains(a,&amp;data);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container32"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Copy)(Vector&nbsp;*A);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given array is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the given array's allocator.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given vector pointer is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*newVector,*OldVector;
&nbsp;&nbsp;&nbsp;&nbsp;newVector&nbsp;=&nbsp;iVector.Copy(OldVector);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container32"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Create)(size_t&nbsp;element_size,size_t&nbsp;startsize);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
The creation function returns an empty array, initialized with all the default values.
The current memory manager is used to allocate the space needed for the header. The array is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the array with sizeof(void *) as the size parameter.

<div class="p"><!----></div>

<b>Returns:</b>
A pointer to a newly created array or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given element size is zero.

<div class="p"><!----></div>
Any errors provoke the call the current default error function of the library since this is the creation function.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*DArray&nbsp;=&nbsp;iVector.Create(sizeof(double),100);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container32"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startsize,ContainerMemoryManager&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function is identical to <font size="+1"><tt>Create</tt></font> with the difference that it accepts a pointer to an allocator object. Actually, <font size="+1"><tt>Create</tt></font> can
be written as:
<div class="p"><!----></div>
<font size="+1"><tt>return CreateWithAllocator(elementsize,startsize,CurrentMemoryManager);</tt></font>
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container32"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(Vector&nbsp;*AL,void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches for the given data in the array. The "data" argument is supposed to point to an element at least ElementSize bytes. The array's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.

<div class="p"><!----></div>
<b>Returns:</b>
One if the given data is stored in the array, zero otherwise. If an error occurs, it returns a negative error code.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either array or data are&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Contains(AL,&amp;data);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CopyTo+\container32"></a> <font size="+1"><b>CopyTo</b></font> <hr />


<font size=+1><pre>

void&nbsp;**(*CopyTo)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the whole contents of the given array into a table of pointers to newly allocated elements, finished by a&nbsp;NULL pointer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a table of pointers or&nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="deleteIterator+\container32"></a> <font size="+1"><b>deleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;deleteIterator(Iterator&nbsp;*it);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims the memory used by the given iterator object

<div class="p"><!----></div>
<b>Returns:</b>
Integer smaller than zero with error code or a positive number when the operation completes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container32"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Vector&nbsp;*first,Vector&nbsp;*second);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given arrays. If they differ in their length, flags, or element size they compare unequal. If any of their elements differ, they compare unequal.
If both first and second are&nbsp;NULL they compare equal. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the vectors are equal, zero otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container32"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Vector&nbsp;*AL,void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the vector the element that matches the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that at least one match was found and the elements were removed. 
If the element is not in the vector the result value is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Erase(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;erased|n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("No&nbsp;element&nbsp;with&nbsp;value&nbsp;2.3&nbsp;present\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("error&nbsp;code&nbsp;%d\n",r);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="EraseAll+\container32"></a> <font size="+1"><b>EraseAll</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Vector&nbsp;*v,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the list all elements that match the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that at least a match was found and the element was removed. If the 
element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="EraseAt+\container32"></a> <font size="+1"><b>EraseAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(Vector&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the array the element at the given position.

<div class="p"><!----></div>

<b>Returns:</b>
A negative error code if an error occurred or a positive value that indicates that the element was removed.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.EraseAt(AL,2);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Element&nbsp;at&nbsp;position&nbsp;2&nbsp;erased\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Error&nbsp;code&nbsp;%d\n",r);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container32"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the container, including the array header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The container is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed. A negative error code indicates failure.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Finalize(AL);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container32"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*Front)(const&nbsp;Vector&nbsp;*v);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the first element of the given vector or&nbsp;NULL if the vector is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.

<div class="p"><!----></div>
<b>Returns:</b>
The first element or&nbsp;NULL if the vector is empty or an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="GetCapacity+\container32"></a> <font size="+1"><b>GetCapacity</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements the array can hold before  it needs to reallocate its data<a href="#tthFtNtADA" name="tthFrefADA"><sup>30</sup></a>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The array capacity or zero if there was an error.
 
<div class="p"><!----></div>
<br /><a 
name="GetElementSize+\container32"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the size of the elements stored in the given vector. Note that this value can be different than the value given to the creation function because of alignment requirements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is&nbsp;NULL .

<div class="p"><!----></div>

<b>Returns:</b>
The element size.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iVector.GetElementSize(AL);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="GetData+\container32"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

void&nbsp;**(*GetData)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the data area of the container, or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_READONLY

 The container is read-only.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>The pointer to the array's data or&nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="GetElement+\container32"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(Vector&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a read only pointer to the element at the given index, or&nbsp;NULL if the operation failed.  This function will return&nbsp;NULL if the vector is read only.

<div class="p"><!----></div>
Use the CopyElement function to get a read/write copy of an element of the vector.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given array pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

    The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

    The array is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d&nbsp;=&nbsp;iVector.GetElement(AL,3);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="GetFlags / SetFlags+\container32"></a> <font size="+1"><b>GetFlags / SetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Vector&nbsp;*AL,unsigned&nbsp;newFlags);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
GetFlags returns the state of the container flags, SetFlags sets the flags to a new value and returns the old value. 

<div class="p"><!----></div>
The Vector container supports the following flags:

<div class="p"><!----></div>
 CONTAINER_READONLY
If this flag is set, no modifications to the container are allowed, and the Clear and Finalize functions will not work. The GetElement function will always return&nbsp;NULL . You should use the CopyElement function to access the data

<div class="p"><!----></div>
 
<br /><a 
name="GetRange+\container32"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*GetRange)(Vector&nbsp;*AL,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Selects a series of consecutive elements starting at position start and ending at position end.  Both the elements at start and end are included in the result.
If start &#62; end or start &#62; Size(AL),&nbsp;NULL is returned. If end is bigger than the number of elements in the vector AL, only elements up to the number of elements will be used.
The selected elements are copied into a new array. The original array remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the element given are&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new vector containing the selected elements or&nbsp;NULL if an error occurs.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*range&nbsp;=&nbsp;iVector.GetRange(AL,2,5);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(range&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="IndexIn+\container32"></a> <font size="+1"><b>IndexIn</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*IndexIn)(Vector&nbsp;*SC,Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns an array built from indexing the first argument ("SC") with the array of indexes &#196;L" that should be an array of size_t elements. The number of elements of the resulting array is equal to the number of elements of the indexes array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the indexes array are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 Any given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new array or&nbsp;NULL if an error occurs. No partial results are returned. If any index is out of bounds the whole operation fails.

<div class="p"><!----></div>
 
<br /><a 
name="IndexOf+\container32"></a> <font size="+1"><b>IndexOf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*IndexOf)(Vector&nbsp;*l,void&nbsp;*data,void&nbsp;*ExtraArgs,size_t&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches for an element in the array. If found its zero based index is returned in the pointer "result". Otherwise the result of the search is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
. The &#235;xtraArgs" argument will be passed to the comparison function, that is used to compare elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the element given are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element is found, or a negative number containing an error code or the negative constant 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;6.8;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;pos;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.IndexOf(AL,&amp;data,NULL,&amp;pos);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;CONTAINER_ERROR_NOTFOUND)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Not&nbsp;found\n");

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="InsertAt+\container32"></a> <font size="+1"><b>InsertAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new element. The new element will have the given index, that can go from zero to the vector count inclusive, i.e. one more than the number of elements in the vector. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer or the element given are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

double&nbsp;d;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.InsertAt(AL,2,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;Normal&nbsp;processing&nbsp;*/&nbsp;&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="InsertIn+\container32"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Vector&nbsp;*Destination,&nbsp;size_t&nbsp;pos,&nbsp;Vector&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the array given in  its third argument at the given position in the array pointed to by its first argument. The data is copied, and the source argument is not modified in any way. Both arrays must have elements of the same type. The library only tests the size of each one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The source or the destination vectors are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The destination vector is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The vectors store elements of different size.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintVector(Vector&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Count&nbsp;%ld,&nbsp;Capacity&nbsp;%ld\n",(long)iVector.Size(AL),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)iVector.GetCapacity(AL));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;iVector.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%g&nbsp;",*(double&nbsp;*)iVector.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

static&nbsp;void&nbsp;FillVector(Vector&nbsp;*&nbsp;AL,int&nbsp;start)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i+start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iVector.Add(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;}
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL&nbsp;=&nbsp;iVector.Create(sizeof(double),10);
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL1&nbsp;=iVector.Create(sizeof(double),10);
&nbsp;&nbsp;&nbsp;&nbsp;FillVector(AL,0);
&nbsp;&nbsp;&nbsp;&nbsp;FillVector(AL1,100);
&nbsp;&nbsp;&nbsp;&nbsp;iVector.InsertIn(AL,5,AL1);
&nbsp;&nbsp;&nbsp;&nbsp;PrintVector(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Count&nbsp;20,&nbsp;Capacity&nbsp;20
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;100&nbsp;101&nbsp;102&nbsp;103&nbsp;104&nbsp;105&nbsp;106&nbsp;107&nbsp;108&nbsp;109&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9


</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Load+\container32"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads an array previously saved with the Save function from the stream pointed to by stream. If readFn is not&nbsp;NULL , it will be used to read each element. The <font size="+1"><tt>arg</tt></font> argument will be passed to the read function. If the read function is&nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A new array or&nbsp;NULL if the operation could not be completed. Note that the function pointers in the array are NOT saved, nor any special allocator that was in the original vector. Those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new array.

<div class="p"><!----></div>
 
<br /><a 
name="NewIterator+\container32"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
If no more memory is available it returns&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new iterator or&nbsp;NULL if there is no more memory left.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iVector.NewIterator(AL);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iVector.deleteIterator(it);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Mismatch+\container32"></a> <font size="+1"><b>Mismatch</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Mismatch)(const&nbsp;Vector&nbsp;*a1,const&nbsp;Vector&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the index of the first element that is different when comparing both arrays in the passed pointer <i>mismatch</i>. If one array is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison stops when the first difference is spotted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any of the arguments is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The containers have different comparison functions or store elements of different size.

<div class="p"><!----></div>
<b>Returns:</b>
If a mismatch is found the result is greater than zero and the <i>mismatch</i> argument will contain the index of the first element that compared 
unequal. This will be always the case for arrays of different length.

<div class="p"><!----></div>
If both arrays are the same length and no differences are found the result is zero and the value pointed to by the 
<i>mismatch</i> argument is one more than the length of the arrays.

<div class="p"><!----></div>
If an error occurs, a negative error code is returned. The <i>mismatch</i> argument contains zero.
 
<div class="p"><!----></div>
<br /><a 
name="PopBack+\container32"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Vector&nbsp;*AL,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the last element into the given result buffer and deletes the element from the container. If the result buffer is&nbsp;NULL , no copy is performed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>

<b>Returns:</b>
A negative value if an error occurs, zero if the array is empty or greater than zero if the operation succeeded.
 
<div class="p"><!----></div>
<br /><a 
name="RemoveRange+\container32"></a> <font size="+1"><b>RemoveRange</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*RemoveRange)(Vector&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all elements having an index equal or greater than
<font size="+1"><tt><i>start</i></tt></font>
 and less than
<font size="+1"><tt><i>end</i></tt></font>
. If
<font size="+1"><tt><i>end</i></tt></font>
 is greater than the number of elements 
in the collection it will be adjusted to one more than the number of elements. If
<font size="+1"><tt><i>start</i></tt></font>
 is bigger than
<font size="+1"><tt><i>end</i></tt></font>
 the range is still valid and
starts with the value of
<font size="+1"><tt><i>end</i></tt></font>
 and ends with the value of
<font size="+1"><tt><i>start</i></tt></font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if the vector is empty. Otherwise returns a positive number for success, a negative error code in case of an error.
 
<div class="p"><!----></div>
<br /><a 
name="ReplaceAt+\container32"></a> <font size="+1"><b>ReplaceAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(Vector&nbsp;*AL,size_t&nbsp;idx,void&nbsp;*newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the array element at position idx with the new data starting at the position pointed to by "newData" and extending ElementSize bytes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array or the new element pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;6.7;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.ReplaceAt(AL,2,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Reverse+\container32"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Reverse)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reverses the order of the elements of the given Vector.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory for intermediate storage available

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.

<div class="p"><!----></div>
 
<br /><a 
name="Resize+\container32"></a> <font size="+1"><b>Resize</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Resize)(Vector&nbsp;*AL,&nbsp;size_t&nbsp;newSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resizes the given vector to the new capacity. If the new capacity is smaller than the elements in the vector some elements will be lost.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded. If the requested capacity is equal to the current
capacity nothing is done and the result is zero.
 
<div class="p"><!----></div>
<br /><a 
name="RotateRight+\container32"></a> <font size="+1"><b>RotateRight</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(Vector&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates right the array by the indicated amount. The last n elements will be written to the start of
the array, and the rest will be shifted right.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).

<div class="p"><!----></div>
 
<br /><a 
name="RotateLeft+\container32"></a> <font size="+1"><b>RotateLeft</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(Vector&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates left the array by the indicated amount. The first n elements will be written to the end of
the array, and the rest will be shifted left to fill the empty n places.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory for intermediate storage available

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size), or an error code less than zero if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container32"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;Vector&nbsp;*AL,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given vector are saved into the given stream. If the save function pointer is not&nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer or the stream pointer are&nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iVector.Save(AL,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SearchWithKey+\container32"></a> <font size="+1"><b>SearchWithKey</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SearchWithKey)(Vector&nbsp;*vec,size_t&nbsp;startByte,size_t&nbsp;sizeKey,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startIndex,void&nbsp;*item,&nbsp;size_t*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function searches the vector for a match in a region of the stored objects, ignoring the rest of the data. It will start at the object with <i>startIndex</i> and compare (using memcmp) the specified region of each object. The region of interest within the stored object is specified 
by a byte offset and a size.
If a match is found the search stops and the zero based index of the object will
be written into the <i>result</i> pointer. If the index of the start of the iteration is bigger than the number of elements in the array nothing
is searched and the result is zero.

<div class="p"><!----></div>
If the sum of <i>startByte</i> and <i>sizeKey</i> is bigger than the size of the elements stored, the comparison will start at the given offset but will stop
at the end of the stored element.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array or the item element pointers are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, zero if no match was found, or a positive number indicating that a match was found. The given index pointer is
modified only if a match is found.

<div class="p"><!----></div>
 
<br /><a 
name="Select+\container32"></a> <font size="+1"><b>Select</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Select)(Vector&nbsp;*v,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is zero are eliminated, those with a mask
value different of zero are retained. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="SelectCopy+\container32"></a> <font size="+1"><b>SelectCopy</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*SelectCopy)(Vector&nbsp;*v,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is different from zero are copied into a new array, those with a mask
value different of zero are ignored. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="SetCapacity+\container32"></a> <font size="+1"><b>SetCapacity</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SetCapacity)(Vector&nbsp;*AL,size_t&nbsp;newCapacity);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resizes the given Vector to a new value. The new capacity means there will be that number of elements allocated, avoiding costly resizing operations when new elements are added to the Vector. If the number given is less than the number of elements present in the array, elements are discarded from the end of the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only.

<div class="p"><!----></div>
<b>Returns:</b>A positive value if resizing was completed, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="SetCompareFunction+\container32"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

CompareFunction&nbsp;(*SetCompareFunction)(Vector&nbsp;*AL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;f);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
if the f argument is non&nbsp;NULL , it sets the array comparison function to f.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The array is read only and the function argument is not&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the comparison function.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ErrorFunction&nbsp;fn,newfn;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;iVector.SetErrorFunction(AL,newfn);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetDestructor+\container32"></a> <font size="+1"><b>SetDestructor</b></font> <hr />


<font size=+1><pre>

DestructorFunction&nbsp;(*SetDestructor)(Vector&nbsp;*v,DestructorFunction&nbsp;fn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Sets the destructor function to its given argument. If the function argument is&nbsp;NULL nothing is changed and the call is interpreted as a query since the return value is the current value of the destructor function. If the vector argument is&nbsp;NULL , the result is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the destructor.

<div class="p"><!----></div>
 
<br /><a 
name="SetErrorFunction+\container32"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Vector&nbsp;*V,ErrorFunction);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given vector with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is different from&nbsp;NULL . If 
the
<font size="+1"><tt><i>V</i></tt></font>
parameter is&nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only and the function argument is not&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function or&nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container32"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the array.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elem&nbsp;=&nbsp;iVector.Size(AL);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container32"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the vector, including the header, and all data stored in it. If the argument is&nbsp;NULL , the size of the header only is returned.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the vector or the size of the Vector header if the argument is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;size&nbsp;=&nbsp;iVector.Sizeof(AL);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Sort+\container32"></a> <font size="+1"><b>Sort</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Sort(Vector&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sorts the given array using the its comparison function. The order of the original array is destroyed. You should copy it if you want to preserve it. 

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if sorting succeeded, a negative error code if not.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iVector.Sort(AL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;The bit-string container: iBitString</h2>
<a 
name="BitString40"></a><img src="bitstrings.png" alt="Figure">
<div class="p"><!----></div>
 BitString vocabulary. Specific items are in bold.
<div class="p"><!----></div>
A bit string is a derivation from the Vector container, specialized to hold a sequence of bits. It is a sequential container designed to save space in the storage of boolean values
<a href="#tthFtNtADB" name="tthFrefADB"><sup>31</sup></a>. 

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;The interface</h3>
<a 
name="iBitString41"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagBitStringInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(BitString&nbsp;*BitStr,int);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(BitString&nbsp;*b,&nbsp;size_t&nbsp;bitSize,&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*And)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AndAssign)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(BitString&nbsp;*left,BitString&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(BitString&nbsp;*BitStr,int&nbsp;(*Applyfn)(bool&nbsp;,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;uintmax_t&nbsp;(*BitBlockCount)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitLeftShift)(BitString&nbsp;*bs,size_t&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitRightShift)(BitString&nbsp;*bs,size_t&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(BitString&nbsp;*BitStr,BitString&nbsp;*str,void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Copy)(BitString&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyBits)(BitString&nbsp;*bitstr,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Create)(size_t&nbsp;bitlen);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(BitString&nbsp;*BitStr,bool&nbsp;bit);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(BitString&nbsp;*BitStr,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*(*GetData)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*GetElement)(BitString&nbsp;*BitStr,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(BitString&nbsp;*BitStr);&nbsp;
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*GetRange)(BitString&nbsp;*b,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(BitString&nbsp;*BitStr,bool&nbsp;SearchedBit,void&nbsp;*ExtraArgs,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Init)(BitString&nbsp;*BitStr,size_t&nbsp;bitlen);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(BitString&nbsp;*,void&nbsp;*);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*InitializeWith)(size_t&nbsp;size,void&nbsp;*data);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Insert)(BitString&nbsp;*BitStr,bool&nbsp;bit);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*InsertAt)(BitString&nbsp;*BitStr,size_t&nbsp;idx,bool&nbsp;bit);
&nbsp;&nbsp;&nbsp;int&nbsp;(*LessEqual)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Memset)(BitString&nbsp;*,size_t&nbsp;start,size_t&nbsp;stop,bool&nbsp;newval);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(BitString&nbsp;*);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Not)(BitString&nbsp;*bsl);
&nbsp;&nbsp;&nbsp;int&nbsp;(*NotAssign)(BitString&nbsp;*bsl);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Or)(BitString&nbsp;*left,BitString&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*OrAssign)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(BitString&nbsp;*BitStr);
&nbsp;&nbsp;&nbsp;uintmax_t&nbsp;(*PopulationCount)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Print)(BitString&nbsp;*b,size_t&nbsp;bufsiz,unsigned&nbsp;char&nbsp;*out);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(BitString&nbsp;*BitStr,int&nbsp;val);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(BitString&nbsp;*BitStr,size_t&nbsp;idx,bool&nbsp;newval);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Reverse)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;BitString&nbsp;*bitstr,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(BitString&nbsp;*BitStr,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetElement)(BitString&nbsp;*bs,size_t&nbsp;position,bool&nbsp;b);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;*(*SetErrorFunction)(BitString&nbsp;*,ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(BitString&nbsp;*BitStr,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(BitString&nbsp;*BitStr);&nbsp;
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(BitString&nbsp;*b);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*StringToBitString)(unsigned&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Xor)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*XorAssign)(BitString&nbsp;*bsl,BitString&nbsp;*bsr);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;BitStringInterface;

</pre></font>


     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;API</h3>
Contrary to the other containers presented above like <font size="+1"><tt>iList</tt></font> or <font size="+1"><tt>iVector</tt></font>, bitstring receives and returns not pointers but values of bits. This is an important difference and makes for significant changes in the interface of many functions.

<div class="p"><!----></div>
Other functions like <font size="+1"><tt>Apply</tt></font> do not make much sense for bits and are provided  just to be coherent in the overall design of the library. Obviously a function that needs a function call per bit is not very fast.
The function GetElementSize is provided for compatibility purposes only and returns always 1. Actually it should return 0.125 assuming
8 bits bytes.
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container42"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(BitString&nbsp;*BitStr,int);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds a bit at the end of the given bitstring.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is no memory to carry out the operation.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the bit is added or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="And+\container42"></a> <font size="+1"><b>And</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*And)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical AND between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the newly allocated result or&nbsp;NULL in case of error.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of both bitstring pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c,*d;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(c,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;AND\n");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("=\n");
&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;iBitString.And(b,c);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(d,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010
&nbsp;AND
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
=
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="AndAssign+\container42"></a> <font size="+1"><b>AndAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AndAssign)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical AND of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number or a negative error code in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(c,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;AND\n");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("=\n");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.AndAssign(b,c);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010
&nbsp;AND
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
=
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="BitBlockCount+\container42"></a> <font size="+1"><b>BitBlockCount</b></font> <hr />


<font size=+1><pre>

uintmax_t&nbsp;&nbsp;(*BitBlockCount)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of blocks where 1 or more bits are set.

<div class="p"><!----></div>
<b>Returns:</b>
The number of blocks of set bits.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c,*d;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&amp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(c,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s&nbsp;BitBlockCount=%ld\n",buf,iBitString.BitBlockCount(b));
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s&nbsp;BitBlockCount=%ld\n",buf,iBitString.BitBlockCount(c));
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;&nbsp;1010&nbsp;1010&nbsp;BitBlockCount=16
0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111&nbsp;BitBlockCount=1

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CopyBits+\container42"></a> <font size="+1"><b>CopyBits</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyBits)(BitString&nbsp;*b,&nbsp;void&nbsp;*buffer);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the bits into the given buffer. The size of the buffer is at least:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;1+iBitstring.Size(bitstr)/8

</pre></font>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either the bitstring or the buffer pointer are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number if the bits are copied, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="GetData+\container42"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*(*GetData)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Returns a pointer to the bits stored in the bitstring. If the string is read-only the result is&nbsp;NULL . The size of the needed buffer can be 
calculated according to:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;BitString&nbsp;*bitstr;
&nbsp;&nbsp;&nbsp;size_t&nbsp;bytesize;

&nbsp;&nbsp;&nbsp;bytesize&nbsp;=&nbsp;1+iBitString.GetSize(bitstr)/CHAR_BIT;

</pre></font>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The bit string pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The bitstring is read-only.

<div class="p"><!----></div>
 
<br /><a 
name="GetRange+\container42"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

BitString&nbsp;*(*GetRange)(BitString&nbsp;*b,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns all the bits between the start (inclusive) and the end (inclusive) indices. If end is smaller than start, start and end are exchanged.
If end is greater than the size of the bit string, all elements up to the last one are returned. If both start and end are out of range, an error is issued and the result is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A new bit string with the specified contents.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;outbuf[256];
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs&nbsp;=&nbsp;iBitString.StringToBitString("0001&nbsp;1111&nbsp;0000&nbsp;0000");
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs1&nbsp;=&nbsp;iBitString.GetRange(bs,8,14);
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs2&nbsp;=&nbsp;iBitString.GetRange(bs,7,14);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Original:%s&nbsp;\n",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs1,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Range&nbsp;8,14:&nbsp;%s\n",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs2,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Range&nbsp;7,14:%s\n",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Original:0001&nbsp;1111&nbsp;&nbsp;0000&nbsp;0000&nbsp;
Range&nbsp;8,14:&nbsp;01&nbsp;1111
Range&nbsp;7,14:001&nbsp;1110

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="BitLeftShift+\container42"></a> <font size="+1"><b>BitLeftShift</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*BitLeftShift)(BitString&nbsp;*bs,size_t&nbsp;shift);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Shifts left the given bit string by the specified number of bits. New bits introduced by the right are zeroed.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The bit string pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>An integer bigger than zero if successful, a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
static&nbsp;void&nbsp;Putbs(BitString&nbsp;*bs,char&nbsp;*prompt)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;outbuf[256];
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(bs,sizeof(outbuf),outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s:&nbsp;%s\n",prompt,outbuf);
}
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;outbuf[256];
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ls;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Usage:&nbsp;%s:&nbsp;amount\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ls&nbsp;=&nbsp;atoi(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*bs&nbsp;=&nbsp;iBitString.StringToBitString("0001&nbsp;1111&nbsp;1010&nbsp;0000");
&nbsp;&nbsp;&nbsp;&nbsp;Putbs(bs,"Original&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.BitLeftShift(bs,ls);
&nbsp;&nbsp;&nbsp;&nbsp;sprintf(outbuf,"Shifted&nbsp;left&nbsp;by&nbsp;%d",ls);
&nbsp;&nbsp;&nbsp;&nbsp;Putbs(bs,outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
~/ccl/test&nbsp;$&nbsp;./a.out&nbsp;1
Original&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0001&nbsp;1111&nbsp;&nbsp;1010&nbsp;0000
Shifted&nbsp;left&nbsp;by&nbsp;1:&nbsp;0011&nbsp;1111&nbsp;&nbsp;0100&nbsp;0000
~/ccl/test&nbsp;$&nbsp;./a.out&nbsp;3
Original&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;0001&nbsp;1111&nbsp;&nbsp;1010&nbsp;0000
Shifted&nbsp;left&nbsp;by&nbsp;3:&nbsp;1111&nbsp;1101&nbsp;&nbsp;0000&nbsp;0000

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Not+\container42"></a> <font size="+1"><b>Not</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Not)(BitString&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical NOT of its argument. The result is returned in a new bit string. The length of the resulting bit string is the same as the length of the argument.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the newly allocated bit string or&nbsp;NULL in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The argument is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="NotAssign+\container42"></a> <font size="+1"><b>NotAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*NotAssign)(BitString&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical NOT of its argument and assigns the result into it. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The argument is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code in case of error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.Create(32);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;32;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Add(b,i&lt;16);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.NotAssign(b);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("NOT&nbsp;b&nbsp;=&nbsp;%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
NOT&nbsp;b&nbsp;=&nbsp;1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111&nbsp;&nbsp;0000&nbsp;0000&nbsp;&nbsp;0000&nbsp;0000

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="InitializeWith+\container42"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*ObjectToBitString)(size_t&nbsp;size,void&nbsp;*p);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The bits starting by the given pointer are copied into a new bit string using the size (in bytes) indicated by the second parameter <font size="+1"><tt>size</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The pointer is&nbsp;NULL 

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough ressources to finish the operation.

<div class="p"><!----></div>
<b>Returns:</b>A new bit string or&nbsp;NULL if there is an error.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
/*&nbsp;This&nbsp;example&nbsp;changes&nbsp;the&nbsp;sign&nbsp;of&nbsp;a&nbsp;double&nbsp;precision
number&nbsp;by&nbsp;changing&nbsp;its&nbsp;sign&nbsp;bit&nbsp;*/
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;-0.125;&nbsp;/*&nbsp;Number&nbsp;is&nbsp;negative&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b&nbsp;=&nbsp;iBitString.ObjectToBitString(sizeof(double),&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Now&nbsp;set&nbsp;sign&nbsp;to&nbsp;zero,&nbsp;making&nbsp;the&nbsp;number&nbsp;positive&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.SetElement(b,63,0);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.CopyBits(b,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%g\n",d);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
0.125

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Or+\container42"></a> <font size="+1"><b>Or</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Or)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical OR between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of both bitstring pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="OrAssign+\container42"></a> <font size="+1"><b>OrAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*OrAssign)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical OR of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code in case of error.
 
<div class="p"><!----></div>
<br /><a 
name="PopulationCount+\container42"></a> <font size="+1"><b>PopulationCount</b></font> <hr />


<font size=+1><pre>

uintmax_t&nbsp;&nbsp;(*PopulationCount)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of 1 bits in the bit string.

<div class="p"><!----></div>
<b>Returns:</b>
The number of set bits in the string.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Print+\container42"></a> <font size="+1"><b>Print</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;size_t&nbsp;(*Print)(BitString&nbsp;*b,size_t&nbsp;bufsiz,unsigned&nbsp;char&nbsp;*out);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Prints into the given buffer the contents of the bitstring <font size="+1"><tt>b</tt></font> without exceeding the length of the given buffer <font size="+1"><tt>bufsiz</tt></font>. The bits will 
be grouped into 4 bits separated by a space. Each group of 8 bits will be separated from the rest by two spaces.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

. The bit string pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of characters written to the output string, including the terminating zero. If the output string pointer is&nbsp;NULL , it returns 
the number of characters that would be needed to print the contents of the bitstring.
 
<div class="p"><!----></div>
<br /><a 
name="Reverse+\container42"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Reverse)(BitString&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The bit sequence of the argument is reversed

<div class="p"><!----></div>
<b>Returns:</b>
A new bit string containing the reversed argument.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given argument is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;pos;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b,*c;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Usage:&nbsp;%s&nbsp;&lt;bitstring&#62;\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.StringToBitString(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Reversing&nbsp;bits&nbsp;of&nbsp;%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;iBitString.Reverse(b);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(c,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Reversing&nbsp;bits&nbsp;of&nbsp;1111&nbsp;1100&nbsp;&nbsp;0000&nbsp;1111&nbsp;&nbsp;1111&nbsp;1111
1111&nbsp;1111&nbsp;&nbsp;1111&nbsp;0000&nbsp;&nbsp;0011&nbsp;1111

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RemoveAt+\container42"></a> <font size="+1"><b>RemoveAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveAt)(BitString&nbsp;*bitStr,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes the bit at the specified position. If the position is greater than the length of the string the last position will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given bit string pointer is&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A positive number when the bit was removed, a negative error code otherwise. If the bit string is empty the result is zero.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;pos;
&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*b;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;buf[512];

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Usage:&nbsp;%s&nbsp;bitstring&nbsp;pos\n",argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;iBitString.StringToBitString(argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;pos&nbsp;=&nbsp;atoi(argv[2]);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("Erasing&nbsp;bit&nbsp;%d&nbsp;of&nbsp;%s\n",pos,buf);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.EraseAt(b,pos);
&nbsp;&nbsp;&nbsp;&nbsp;iBitString.Print(b,sizeof(buf),buf);
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
Erasing&nbsp;bit&nbsp;2&nbsp;of&nbsp;11&nbsp;&nbsp;1000&nbsp;1110&nbsp;&nbsp;0011&nbsp;1000
1&nbsp;&nbsp;1100&nbsp;0111&nbsp;&nbsp;0001&nbsp;1100

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Set+\container42"></a> <font size="+1"><b>Set</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Set)(BitString&nbsp;*B,size_t&nbsp;start,size_t&nbsp;stop,bool&nbsp;newvalue);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the range of bits delimiteded by its <i>start</i> and <i>end</i> arguments to the value given by its <i>newvalue</i> argument. If the new
value is different than zero a '1' bit is written, otherwise the bit is set to zero. If the <i>stop</i> argument is bigger than the length of the
bitstring, the end of the string will be used.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The bit string pointer is NULL.

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The <i>start</i> argument is bigger or equal to the length of the bitstring.
 
<div class="p"><!----></div>
<br /><a 
name="StringToBitString+\container42"></a> <font size="+1"><b>StringToBitString</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*StringToBitString)(unsigned&nbsp;char&nbsp;*);

</pre></font>
Reads a bitstring from a character string. The character string should contain only the characters '1', '0', space and tab.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The character string pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new bitstring or&nbsp;NULL if there was an error or the given character string did not contain any '1' or '0'.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Xor+\container42"></a> <font size="+1"><b>Xor</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BitString&nbsp;*(*Xor)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical XOR between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to its result or&nbsp;NULL in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of both bitstring pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory is available to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="XorAssign+\container42"></a> <font size="+1"><b>XorAssign</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*XorAssign)(BitString&nbsp;*left,BitString&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a logical XOR of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code in case of error.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Its argument is&nbsp;NULL .

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;The string collection container: istrCollection, iWstrCollection</h2>
<a 
name="istrCollection50"></a><a 
name="iWstrCollection50"></a><a 
name="WstrCollection50"></a>A string collection is a derivation from the Vector container, specialized to hold character strings.

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;The interface</h3>
To avoid unnecessary repetitions in this document here is documented a generic interface.
The word <font size="+1"><tt>ElementType</tt></font> is either <font size="+1"><tt>char</tt></font> for multi-byte strings, or
<font size="+1"><tt>wchar_t</tt></font> for wide character strings. The word <font size="+1"><tt>strCollection</tt></font> in this context means either 

<ul>
<li> a multi-byte string collection using the <font size="+1"><tt>strCollectionInterface</tt></font>
<div class="p"><!----></div>
</li>

<li> a wide character string collection using the <font size="+1"><tt>WstrCollectionInterface</tt></font>
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagstrCollectionInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(strCollection&nbsp;*SC,const&nbsp;char&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(strCollection&nbsp;*SC,size_t&nbsp;n,const&nbsp;char&nbsp;**newvalues);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(strCollection&nbsp;*,strCollection&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(strCollection&nbsp;*SC,int&nbsp;(*Applyfn)(char&nbsp;*,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*Back)(const&nbsp;strCollection&nbsp;*str);
&nbsp;&nbsp;&nbsp;struct&nbsp;_Vector&nbsp;*(*CastToArray)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqual)(const&nbsp;strCollection&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;strCollection&nbsp;*right,Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqualScalar)(const&nbsp;strCollection&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*str,Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*str);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Copy)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;char&nbsp;**(*CopyTo)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Create)(size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*CreateFromFile)(const&nbsp;char&nbsp;*fileName);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsiz,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;strCollection&nbsp;*SC1,const&nbsp;strCollection&nbsp;*SC2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(strCollection&nbsp;*SC,const&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(strCollection&nbsp;*SC,const&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(strCollection&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*FindFirst)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*FindNext)(const&nbsp;strCollection&nbsp;*SC,&nbsp;const&nbsp;char&nbsp;*text,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*FindText)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*FindTextIndex)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*FindTextPositions)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*text);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*Front)(const&nbsp;strCollection&nbsp;*str);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;strCollection&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;char&nbsp;**(*GetData)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*GetElement)(const&nbsp;strCollection&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*GetRange)(strCollection&nbsp;*SC,&nbsp;size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*IndexIn)(const&nbsp;strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;Vector&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*SearchedString,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Init)(strCollection&nbsp;*result,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(strCollection&nbsp;*SC,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*InitWithAllocator)(strCollection&nbsp;*c,size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*InitializeWith)(size_t&nbsp;n,&nbsp;char&nbsp;**data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(strCollection&nbsp;*SC,char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(strCollection&nbsp;*SC,size_t&nbsp;idx,const&nbsp;char&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(strCollection&nbsp;*source,&nbsp;size_t&nbsp;idx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*newData);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mismatch)(const&nbsp;strCollection&nbsp;*a1,const&nbsp;strCollection&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*PopBack)(strCollection&nbsp;*,&nbsp;char&nbsp;*result,size_t&nbsp;bufsize);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*PopFront)(strCollection&nbsp;*SC,char&nbsp;*outbuf,size_t&nbsp;buflen);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(strCollection&nbsp;*,const&nbsp;char&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(strCollection&nbsp;*SC,char&nbsp;*str);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(strCollection&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(strCollection&nbsp;*SC,size_t&nbsp;idx,char&nbsp;*newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;strCollection&nbsp;*SC,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(strCollection&nbsp;*src,&nbsp;const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*SelectCopy)(const&nbsp;strCollection&nbsp;*src,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(strCollection&nbsp;*SC,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;StringCompareFn&nbsp;(*SetCompareFunction)(strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCompareFn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(strCollection&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(strCollection&nbsp;*SC,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;strCollection&nbsp;*l);
&nbsp;&nbsp;&nbsp;bool&nbsp;(*Sort)(strCollection&nbsp;*SC);
&nbsp;&nbsp;&nbsp;int&nbsp;(*WriteToFile)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*filename);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;strCollectionInterface;

</pre></font>


     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;API</h3>
Most of the functions present in the interface are exactly like the functions in Vector. Only those that differ will be documented here.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="AddRange+\container52"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(strCollection&nbsp;*SC,size_t&nbsp;n,const&nbsp;ElementType&nbsp;*data[]);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds each string of the array of string pointers at the end of the container. It is assumed that "data" points to a contiguous array of string pointers whose size is given by the "n" parameter. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise.  If n is zero nothing is done and no errors are issued, even if the array pointer or the data pointer are&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer or the data pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The collection is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.


<div class="p"><!----></div>
 <b>Invariants:</b>
The data added is copied and not modified in any way.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

strCollection&nbsp;*SC&nbsp;=&nbsp;istrCollection.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*data[]&nbsp;=&nbsp;{&nbsp;"one","two,"three"};
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;istrCollection.AddRange(SC,3,data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="CastToArray+\container52"></a> <font size="+1"><b>CastToArray</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CastToArray)(const&nbsp;strCollection&nbsp;*SC);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Converts a string collection into an vector.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.


<div class="p"><!----></div>
 <b>Invariants:</b>
The given collection is not modified in any way.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, negative error code otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="CreateFromFile+\container52"></a> <font size="+1"><b>CreateFromFile</b></font> <hr />


<font size=+1><pre>

strCollection&nbsp;*(*CreateFromFile)(const&nbsp;char&nbsp;*fileName);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads the given text file and stores each line in a string of the collection. The end of line characters are discarded.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The fileName pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_NOENT

 The file doesn't exist or can't be opened for reading.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new string collection with the contents of the file. If an error occurs the result is&nbsp;NULL and the current error function (in the iError interface) is called.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="FindFirst+\container52"></a> <font size="+1"><b>FindFirst</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*FindFirstText)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;ElementType&nbsp;*text);

</pre></font>
 
<div class="p"><!----></div>
  <b>Description:</b> 
Finds the first occurrence of the given text in the string collection. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input collection, nor the given text are modified.

<div class="p"><!----></div>
<b>Returns:</b>
The zero based index of the line that contains the given text or the constant 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
if the text is not found.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="FindNext+\container52"></a> <font size="+1"><b>FindNext</b></font> <hr />


<font size=+1><pre>

Iterator&nbsp;*(*Find)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;ElementType&nbsp;*txt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Starts searching for the given text at the specified line.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection or the text pointer are&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input collection, nor the given text are modified in any way.

<div class="p"><!----></div>
<b>Returns:</b>
An iterator that points to the element found or&nbsp;NULL if nothing was found.
 
<div class="p"><!----></div>
<br /><a 
name="FindTextPositions+\container52"></a> <font size="+1"><b>FindTextPositions</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*FindTextPositions)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;ElementType&nbsp;*text);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches all occurrences of the given text in the given string collection.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection or the text pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough storage for holding the resulting array.


<div class="p"><!----></div>
 <b>Invariants:</b>
Neither the input collection, nor the given text are modified.

<div class="p"><!----></div>
<b>Returns:</b>
An array list containing a pair of integers for each occurrence containing the zero based position of the line where the text was found and a second number indicating the character index within the line where the searched text occurs.
The result is&nbsp;NULL if there wasn't any occurrences of the searched text in the string collection or an error was detected.
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container52"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

const&nbsp;CHARTYPE&nbsp;*(*Front)(const&nbsp;strCollection&nbsp;*l);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the first element of the given list or&nbsp;NULL if the collection is empty.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The collection pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The collection is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The input collection is not modified. The resulting pointer should not be modified in any way.

<div class="p"><!----></div>
<b>Returns:</b>
The first element or&nbsp;NULL if the collection is empty or an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Init+\container52"></a> <font size="+1"><b>Init</b></font> <hr />


<font size=+1><pre>

strCollection&nbsp;*(*Init)(strCollection&nbsp;*result,&nbsp;size_t&nbsp;startsize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the given string collection to contain at least the number of strings given. Uses the current memory manager.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is no more memory left to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The string collection pointer is&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the initialized string collection or&nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="InitWithAllocator+\container52"></a> <font size="+1"><b>InitWithAllocator</b></font> <hr />


<font size=+1><pre>

strCollection&nbsp;*(*InitWithAllocator)(strCollection&nbsp;*result,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;startsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the given string collection to contain at least the number of strings given. Uses the given memory manager.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is no more memory left to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The string collection pointer is&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the initialized string collection or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="InsertIn+\container52"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*InsertIn)(strCollection&nbsp;*dst,&nbsp;size_t&nbsp;pos,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;strCollection&nbsp;*newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the given strCollection into the destination strCollection at the given position. If the position is greater than the actual length of the string collection the new data will be inserted at the end.
 
<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The source or destination pointers are&nbsp;NULL .
 
<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The destination is read only.


<div class="p"><!----></div>
 <b>Invariants:</b>
The new data is not modified in any way.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
static&nbsp;void&nbsp;PrintStringCollection(strCollection&nbsp;*AL)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;printf("Count&nbsp;%ld,&nbsp;Capacity&nbsp;%ld\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)istrCollection.Size(AL),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)istrCollection.GetCapacity(AL));
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;istrCollection.Size(AL);i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s&nbsp;",istrCollection.GetElement(AL,i));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}

static&nbsp;void&nbsp;FillStringCollection(strCollection&nbsp;*&nbsp;AL,int&nbsp;start)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[256];

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;i+start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(buf,"%g",d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Add(AL,buf);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*AL&nbsp;=&nbsp;istrCollection.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*AL1&nbsp;=istrCollection.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;FillStringCollection(AL,0);
&nbsp;&nbsp;&nbsp;&nbsp;FillStringCollection(AL1,100);
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.InsertIn(AL,5,AL1);
&nbsp;&nbsp;&nbsp;&nbsp;PrintStringCollection(AL);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

</pre></font>
The example creates two string collections, fills them with the string representation of the numbers from 0 to 9 and from 100 to 109, then inserts the second collection into the first one at position 5.

<div class="p"><!----></div>
OUTPUT:

<font size=+1><pre>
Count&nbsp;20,&nbsp;Capacity&nbsp;20
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;100&nbsp;101&nbsp;102&nbsp;103&nbsp;104&nbsp;105&nbsp;106&nbsp;107&nbsp;108&nbsp;109&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Mismatch+\container52"></a> <font size="+1"><b>Mismatch</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Mismatch)(const&nbsp;strCollection&nbsp;*a1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;strCollection&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the index of the first element that is different when comparing both collections in the passed pointer <i>mismatch</i>. If one  is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison also stops when the first difference is spotted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any of the arguments is&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input collections are not modified in any way. Both collections could be the same.

<div class="p"><!----></div>
<b>Returns:</b>
If a mismatch is found the result is greater than zero and the <i>mismatch</i> argument will contain the index of the first element that compared 
unequal. This will be always the case for arrays of different length.

<div class="p"><!----></div>
If both arrays are the same length and no differences are found the result is zero and the value pointed to by the 
<i>mismatch</i> argument is one more than the length of the arrays.

<div class="p"><!----></div>
If an error occurs, a negative error code is returned. The <i>mismatch</i> argument contains zero.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
char&nbsp;*table[]&nbsp;=&nbsp;{"String&nbsp;1",&nbsp;"String&nbsp;2","String&nbsp;3","String&nbsp;4",};

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*sc&nbsp;=&nbsp;istrCollection.Create(4);
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*sc2;
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.AddRange(sc,sizeof(table)/sizeof(table[0]),table);
&nbsp;&nbsp;&nbsp;&nbsp;sc2&nbsp;=&nbsp;istrCollection.Copy(sc);
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.ReplaceAt(sc,2,"String456");
&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Mismatch(sc,sc2,&amp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;printf("String&nbsp;collections&nbsp;differ&nbsp;at&nbsp;position&nbsp;%d\n",idx);
}
OUTPUT:
String&nbsp;collections&nbsp;differ&nbsp;at&nbsp;position&nbsp;2

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="PopBack+\container52"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*PopBack)(strCollection&nbsp;*SC,ElementType&nbsp;*buf,size_t&nbsp;buflen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
If the string collection is not empty, it will copy at most buflen characters into the given buffer. If the buffer pointer is&nbsp;NULL or the length of the buffer is zero it will return the length of the element that would be popped.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if the collection was empty, a negative error code if an error occurs, or a positive value if the range was erased.
 
<div class="p"><!----></div>
<br /><a 
name="RemoveRange+\container52"></a> <font size="+1"><b>RemoveRange</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*RemoveRange)(strCollection&nbsp;*SC,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all strings having an index equal or greater than
<font size="+1"><tt><i>start</i></tt></font>
 and less than
<font size="+1"><tt><i>end</i></tt></font>
. If
<font size="+1"><tt><i>end</i></tt></font>
 is greater than the number of elements 
in the collection it will be adjusted to one more than the number of elements. If
<font size="+1"><tt><i>start</i></tt></font>
 is bigger than
<font size="+1"><tt><i>end</i></tt></font>
 the range is still valid and
starts with the value of
<font size="+1"><tt><i>end</i></tt></font>
 and ends with the value of
<font size="+1"><tt><i>start</i></tt></font>
.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
Zero if the string collection is empty. Otherwise returns a positive number for success, a negative error code in case of an error.
 
<div class="p"><!----></div>
<br /><a 
name="SetCompareFunction+\container52"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

StringCompareFn&nbsp;(*SetCompareFunction)(strCollection&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringCompareFn&nbsp;StrCmp);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the function used for comparing two strings to the given one. If the value of the new function is&nbsp;NULL the current value is returned.

<div class="p"><!----></div>
Note that the definition of the <font size="+1"><tt>StringCompareFn</tt></font> differs from the
normal <font size="+1"><tt>CompareFunction</tt></font> used in all other containers. Its definition is as follows:

<font size=+1><pre>
typedef&nbsp;int&nbsp;(*StringCompareFn)(const&nbsp;void&nbsp;**s1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;**s2,CompareInfo&nbsp;*info);

</pre></font>
<a 
name="StringCompareFn52"></a>
The reason for this change is that a string container holds pointers to characters, hence a double indirection is needed by functions like
<font size="+1"><tt>sort</tt></font>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the comparison function.
 
<div class="p"><!----></div>
<br /><a 
name="WriteToFile+\container52"></a> <font size="+1"><b>WriteToFile</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*WriteToFile)(const&nbsp;strCollection&nbsp;*SC,const&nbsp;char&nbsp;*fileName);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Writes the contents of the given string collection into a file with the given name. If the collection is empty an empty file is created. The resulting file contains a line for each string in the collection.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The strCollection pointer or the fileName are&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The input collection is not modified.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completes, or a negative error code otherwise. If the collection is empty the result is zero.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;The dictionary container: iDictionary</h2>
<a 
name="Dictionary60"></a>
<img src="Dictionary.png" alt="Figure">
<div class="p"><!----></div>
 The dictionary vocabulary.
<div class="p"><!----></div>
A dictionary is an associative container that associates a text key with a piece of data. It can be implemented by means of a hash table that uses a hash function to map the key into a restricted integer range, used to index a table. A common usage is to associate some data with a character key,
but it can also be used to just store character keys without any data associated with them. The container is then used just to see if a given key
is stored there or not. In this case the container should be created with object size of zero.

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;The dictionary interface</h3>
This interface (like the string collection container) comes in two flavors: One with keys of 8 bit characters, another with keys in the wide character
set. Both interfaces are identical, except for the keys parameter.
<a 
name="iDictionary61"></a>
This is the interface for the multi-byte character set.

<div class="p"><!----></div>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagDictionaryInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Dictionary&nbsp;*Dict,int&nbsp;(*Applyfn)(const&nbsp;char&nbsp;*Key,
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CastToArray)(const&nbsp;Dictionary&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;Dictionary&nbsp;*dict,const&nbsp;char&nbsp;*key);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Copy)(const&nbsp;Dictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Create)(size_t&nbsp;ElementSize,size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;Dictionary&nbsp;*d1,const&nbsp;Dictionary&nbsp;*d2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*Key);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Dictionary&nbsp;*d);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;strCollection&nbsp;*(*GetKeys)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Init)(Dictionary&nbsp;*dict,size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Dictionary&nbsp;*dict,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*InitWithAllocator)(Dictionary&nbsp;*D,size_t&nbsp;elemsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint,const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;**Keys,const&nbsp;void&nbsp;*Values);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(Dictionary&nbsp;*dst,Dictionary&nbsp;*src);
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*&nbsp;(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Dictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(Dictionary&nbsp;*dict,const&nbsp;char&nbsp;*Key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Dictionary&nbsp;*Dict,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Dictionary&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Dictionary&nbsp;*Dict,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;HashFunction&nbsp;(*SetHashFunction)(Dictionary&nbsp;*d,HashFunction&nbsp;newFn);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;Dictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;Dictionary&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;DictionaryInterface;

</pre></font>


<div class="p"><!----></div>
This is the interface for the wide character set.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagWDictionaryInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*key,const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(WDictionary&nbsp;*Dict,int&nbsp;(*Applyfn)(const&nbsp;wchar_t&nbsp;*Key,
&nbsp;&nbsp;&nbsp;Vector&nbsp;*(*CastToArray)(const&nbsp;WDictionary&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;WDictionary&nbsp;*dict,const&nbsp;wchar_t&nbsp;*key);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*Copy)(const&nbsp;WDictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*Create)(size_t&nbsp;ElementSize,size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;WDictionary&nbsp;*d1,const&nbsp;WDictionary&nbsp;*d2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*Key);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;WDictionary&nbsp;*d);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;WstrCollection&nbsp;*(*GetKeys)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*Init)(WDictionary&nbsp;*dict,size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(WDictionary&nbsp;*dict,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*InitWithAllocator)(WDictionary&nbsp;*D,size_t&nbsp;elemsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;hint,const&nbsp;ContainerMemoryManager&nbsp;*mm);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;wchar_t&nbsp;**Keys,const&nbsp;void&nbsp;*Values);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(WDictionary&nbsp;*Dict,const&nbsp;wchar_t&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(WDictionary&nbsp;*dst,WDictionary&nbsp;*src);
&nbsp;&nbsp;&nbsp;WDictionary&nbsp;*&nbsp;(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(WDictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(WDictionary&nbsp;*dict,const&nbsp;wchar_t&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;WDictionary&nbsp;*Dict,FILE&nbsp;*stream,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(WDictionary&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(WDictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(WDictionary&nbsp;*Dict,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;WHashFunction&nbsp;(*SetHashFunction)(WDictionary&nbsp;*d,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHashFunction&nbsp;newFn);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;WDictionary&nbsp;*Dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;WDictionary&nbsp;*dict);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;WDictionary&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;WDictionaryInterface;

</pre></font>


     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container62"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(Dictionary&nbsp;*Dict,char&nbsp;*key,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the container using the given "key" string. It is assumed that "data" points to a contiguous memory area of at least ElementSize bytes.  Both the key and the data are copied into the container. If the size of dictionary data elements is zero the 
<font size="+1"><tt><i>data</i></tt></font>

<div class="p"><!----></div>
argument is ignored and can be&nbsp;NULL .

<div class="p"><!----></div>
If an element exists with the given key, its contents are replaced with the new data. For a different behavior use <font size="+1"><tt>Insert</tt></font> or <font size="+1"><tt>Replace</tt></font>.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The dictionary, or the key pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The dictionary is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, zero if the data was written into an existing element, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*dict;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iDictionary.Add(dict,"Interest&nbsp;rate",&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container62"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(Applyfn)(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element of the array. The first argument of the callback function receives they key ,the second is a pointer to the element of the Dictionary. The  third argument of the callback is the &#235;xtraArg" argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable function type cast.
If the dictionary is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

  Either the dictionary pointer or Applyfn are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The dictionary is read-only and there is no more memory to allocate the buffer to copy each element.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

static&nbsp;int&nbsp;print(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pResult)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s:&nbsp;%g\n",key,*p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;main(void)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*dict&nbsp;=&nbsp;iDictionary.Create(sizeof(double),5);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"First&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"Second&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Apply(dict,print,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>

<div class="p"><!----></div>
Output should be:

<font size=+1><pre>
First&nbsp;item:&nbsp;2
Second&nbsp;item:&nbsp;3

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CastToArray+\container62"></a> <font size="+1"><b>CastToArray</b></font> <hr />


<font size=+1><pre>

Vector&nbsp;*(*CastToArray)(Dictionary&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a vector containing all the elements in the dictionary (without any keys). If the element size of the dictionary is zero the result is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

  The dictionary pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The creation of the resulting vector failed or the dictionary is read-only and there is no more memory to allocate 
the buffer to copy each element.

<div class="p"><!----></div>
<b>Returns:</b>The new vector or&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container62"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Dictionary&nbsp;*dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The dictionary header is not destroyed, and its contents will be the same as when it was initially created. It is an error to use this function when there are still active iterators for the container.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The vector is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iDictionary.Clear(Dict);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Contains+\container62"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*Key);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns one if the given key is stored in the dictionary, zero otherwise.  If an error occurs it returns a negative error code.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either Dict or Key are&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*dict;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iDictionary.Contains(dict,"Item&nbsp;1");

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Copy+\container62"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Copy)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given dictionary is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the allocator in the source dictionary.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a copy of the given dictionary or&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*newDict,*Old;
&nbsp;&nbsp;&nbsp;&nbsp;newDict&nbsp;=&nbsp;iDictionary.Copy(Old);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="CopyElement+\container62"></a> <font size="+1"><b>CopyElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(Dictionary&nbsp;*Dict,cont&nbsp;char&nbsp;*Key,&nbsp;void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A shallow copy of the given dictionary element is performed. 
Only element size bytes will be copied. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the allocator in the source dictionary. If the element size is zero nothing is copied and the result is zero.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, zero if the element size of the dictionary is zero, or a negative error code.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iDictionary.CopyElement(Dict,"Key",outbuf);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;//&nbsp;handle&nbsp;error
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;nothing&nbsp;was&nbsp;copied
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;//&nbsp;Use&nbsp;outbuf&nbsp;data&nbsp;here

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container62"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*Create)(size_t&nbsp;ElementSize,size_t&nbsp;hint);
&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementsize,size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator);

</pre></font>
<a 
name="CreateWithAllocator62"></a>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new dictionary with the given element size and with a table big enough to store <font size="+1"><tt>hint</tt></font> entries. The <font size="+1"><tt>Create</tt></font> function
uses the current memory manager as the allocator for the new dictionary. <font size="+1"><tt>CreateWithAllocator</tt></font> uses the given allocator object.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new dictionary or&nbsp;NULL if there is not enough memory to create it.
 
<div class="p"><!----></div>
<br /><a 
name="deleteIterator+\container62"></a> <font size="+1"><b>deleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;deleteIterator(Iterator&nbsp;*it);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims the memory used by the given iterator object

<div class="p"><!----></div>
<b>Returns:</b>
Integer smaller than zero with error code or a positive number when the operation completes.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The iterator pointer is&nbsp;NULL .

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Equal+\container62"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Dictionary&nbsp;*d1,Dictionary&nbsp;*d2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given dictionaries using their comparison function. If the dictionaries differ in their size, flags, or hash functions they compare unequal. If any of their elements differ, they compare unequal.
If both d1 and d2 are&nbsp;NULL they compare equal. If Both d1 and d2 are empty they compare equal.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the dictionaries are equal, zero otherwise.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container62"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the dictionary the element that matches the given key.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value that indicates that a match was found and the element was removed. If no element matched the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
. If an error occurs, a negative error code is returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

double&nbsp;d&nbsp;=&nbsp;2.3;
&nbsp;&nbsp;&nbsp;&nbsp;Vector&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iVector.Erase(AL,&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("2.3&nbsp;erased|n");
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("No&nbsp;element&nbsp;with&nbsp;value&nbsp;2.3&nbsp;present\n");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("error&nbsp;code&nbsp;%d\n",r);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container62"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Dictionary&nbsp;*dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the dictionary, including the array header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The dictionary is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed. A negative error code indicates failure.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*AL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iDictionary.Finalize(AL);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetAllocator+\container62"></a> <font size="+1"><b>GetAllocator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;(*GetAllocator)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the memory manager of the given dictionary. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL .

<div class="p"><!----></div>

<b>Returns:</b>
The memory manager object or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetElementSize+\container62"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the size of the elements stored in the given dictionary. Note that this value can be different than the value given to the creation function because of alignment requirements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL .

<div class="p"><!----></div>

<b>Returns:</b>
The element size or zero if an error.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iDictionary.GetElementSize(Dict);

</pre></font>

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="GetElement+\container62"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*GetElement)(Dictionary&nbsp;*Dict,const&nbsp;char&nbsp;*key);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the element at the given index, or&nbsp;NULL if the operation failed.  This function will return&nbsp;NULL if the dictionary is read only.

<div class="p"><!----></div>
Use the CopyElement function to get a read/write copy of an element of the dictionary.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given dictionary pointer or the key are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

    The array is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d&nbsp;=&nbsp;iDictionary.GetElement(Dict,"Index");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="GetFlags+\container62"></a> <font size="+1"><b>GetFlags</b></font> <hr />


<font size=+1><pre>

unsigned&nbsp;(*GetFlags)(Dictionary&nbsp;*dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the flags element of the given dictionary.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given dictionary pointer is&nbsp;NULL .

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="InsertIn+\container62"></a> <font size="+1"><b>InsertIn</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*InsertIn)(Dictionary&nbsp;*dst,Dictionary&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts all keys of the
<font size="+1"><tt><i>src</i></tt></font>
dictionary into the
<font size="+1"><tt><i>dst</i></tt></font>
dictionary. If the container changes during the insertion process 
the operation aborts.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given dictionary pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

. There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if successful, zero if the container changed during the operation, or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Init+\container62"></a> <font size="+1"><b>Init</b></font> <hr />


<font size=+1><pre>

	Dictionary&nbsp;*(*Init)(Dictionary&nbsp;*Dict,size_t&nbsp;elementsize,size_t&nbsp;hint);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the indicated storage for use asa dictionary object. This procedure is completely equivalent to <font size="+1"><tt>Create</tt></font> with the difference
that there is no allocation done for the dictionary header. Uses the current memory manager for the allocations of the slot table.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to its first argument if successfull or&nbsp;NULL if there is no memory to complete the operation.
 
<div class="p"><!----></div>
<br /><a 
name="InitializeWith+\container62"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

Dictionary&nbsp;*(*InitializeWith)(size_t&nbsp;elemSize,&nbsp;size_t&nbsp;n,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;**keys,void&nbsp;*Values);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Construct a dictionary from the given keys and values. The <font size="+1"><tt>Values</tt></font> argument should be either&nbsp;NULL or a valid pointer to <font size="+1"><tt>n</tt></font> elements
of size <font size="+1"><tt>elementSize</tt></font>. The <font size="+1"><tt>keys</tt></font> argument should be a table of string pointers with each string associated with each element of the
<font size="+1"><tt>Values</tt></font> table.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The keys argument is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

. There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>The new dictionary object or&nbsp;NULL if an error occurs
 
<div class="p"><!----></div>
<br /><a 
name="InitWithAllocator+\container62"></a> <font size="+1"><b>InitWithAllocator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;	Dictionary&nbsp;*(*InitWithAllocator)(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elementsize,&nbsp;size_t&nbsp;hint,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Initializes the indicated storage for use as a dictionary object. This procedure is completely equivalent to <font size="+1"><tt>CreateWithAllocator</tt></font> with the difference
that there is no allocation done for the dictionary header. Uses the given memory manager for the allocations of the slot table.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to its first argument if successfull or&nbsp;NULL if there is no memory to complete the operation.

<div class="p"><!----></div>
 
<div class="p"><!----></div>
<br /><a 
name="Insert+\container62"></a> <font size="+1"><b>Insert</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Insert)(Dictionary&nbsp;*Dict,&nbsp;const&nbsp;char&nbsp;*key,void&nbsp;*Data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new key and its corresponding data into the given dictionary. If the key is already present, nothing is changed. This contrasts with the 
behavior of <font size="+1"><tt>Add</tt></font> that will replace an existing key.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Any of the given pointers is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

    The array is read only.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A positive value if the key was inserted, zero if the key was already present, or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Load+\container62"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;Dictionary&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a dictionary previously saved with the Save function from the stream pointed to by stream. If readFn is not&nbsp;NULL , it will be used to read each 
element. The &#228;rg" argument will be passed to the read function. If the read function is&nbsp;NULL , this argument is ignored and a default read function is 
used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new dictionary or&nbsp;NULL if the operation could not be completed. Note that the function pointers in the array are NOT saved, nor any special allocator 
that was in the original dictionary. Those values will be the values by default. To rebuild the original state the user should replace the pointers 
again in the new array.

<div class="p"><!----></div>
 
<br /><a 
name="NewIterator+\container62"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this dictionary. The exact sequence is implementation defined but it will be the same for 
the same dictionary with the same number of elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
If no more memory is available it returns&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new iterator or&nbsp;NULL if there is no more memory left.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iDictionary.NewIterator(Dict);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.deleteIterator(it);

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SetDestructor+\container62"></a> <font size="+1"><b>SetDestructor</b></font> <hr />


<font size=+1><pre>

DestructorFunction&nbsp;SetDestructor(Dictionary&nbsp;*d,DestructorFunction&nbsp;fn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Sets the destructor function to its given argument. If the function argument is&nbsp;NULL nothing is changed and the call is interpreted as 
a query since the return value is the current value of the destructor function. If the dictionary argument is&nbsp;NULL , the result is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The old value of the destructor.

<div class="p"><!----></div>
 
<br /><a 
name="SetHashFunction+\container62"></a> <font size="+1"><b>SetHashFunction</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*SetHashFunction)(Dicttionary&nbsp;*dict,HashFunction&nbsp;newFn);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> This function is both a query function  and a function to change the hash function used by the given dictionary.


<ul>      
<li> If the dictionary pointer is&nbsp;NULL returns the value of the default hash function used by the library at startup.
<div class="p"><!----></div>
</li>

<li> If the <font size="+1"><tt>newFn</tt></font> parameter is&nbsp;NULL it returns the hash function used by the given dictionary without modifying it.
<div class="p"><!----></div>
</li>

<li> Otherwise it sets the hash function in the given dictionary to the new one, returning the value of the old one.

<div class="p"><!----></div>
</li>
</ul>


<div class="p"><!----></div>
 
<br /><a 
name="Size+\container62"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the dictionary or  SIZE_MAX if the dictionary pointer is&nbsp;NULL .

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

    The given array pointer or the key are&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elem&nbsp;=&nbsp;iDictionary.Size(Dict);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container62"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;Dictionary&nbsp;*D,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given dictionary are saved into the given stream. If the save function pointer is not&nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The dictionary pointer or the stream pointer are&nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iDictionary.Save(Dict,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container62"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Dictionary&nbsp;*Dict);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the dictionary, including the header, and all data stored in the dictionary, including the size of the dictionary header.
If Dict is&nbsp;NULL , the result is the size of the <font size="+1"><tt>Dictionary</tt></font> structure.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the dictionary or the size of the Dictionary structure if the argument is&nbsp;NULL .


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;size&nbsp;=&nbsp;iDictionary.Sizeof(Dict);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="SetErrorFunction+\container62"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

ErrorFunction&nbsp;(*SetErrorFunction)(Dictionary&nbsp;*dict,ErrorFunction&nbsp;efn);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given dictionary with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is 
different from&nbsp;NULL . If the
<font size="+1"><tt><i>dict</i></tt></font>
parameter is&nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The dictionary pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The dictionary is read only and the function argument is not&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function or&nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container62"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;Dictionary&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the dictionary. If the argument is&nbsp;NULL the result is zero.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Dictionary&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elem&nbsp;=&nbsp;iDictionary.Size(d);

</pre></font>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;The TreeMap interface: iTreeMap</h2>
<a 
name="TreeMap70"></a>
<a 
name="iTreeMap70"></a>The tree map container uses a tree to associate  keys to values. Trees are extremely efficient data structures that allow access to millions
of items with a few comparisons. Disadvantages include a greater overhead than other containers, and a complex machinery to maintain
them.

<div class="p"><!----></div>
This associative container is special in that it contains no separate key, the elements themselves are the key. Obviously they need imperatively 
a comparison function, and that comparison function could use some parts of the stored object as a key, but that is transparent to the interface.

<div class="p"><!----></div>
An essential point in this container is the comparison function. Since all insertions searches and deletions from/to the tree are done using that
function, it is essential that is defined correctly. Like all other comparison functions it can receive an extra argument that conveys some kind
of context to it. This implies that functions like 'Add' have an extra argument to be able to pass this context to the comparison function.

      <h4><a name="tth_sEc7.0.1">
7.0.1</a>&nbsp;&nbsp;The comparison function must be consistent</h4>
It is important to stress that for this container it is <b>essential</b> that the comparison function returns always the <b>same</b> result for
two given elements. The context passed through this auxiliary arguments must not be used to change the result of the element comparison according
to some external factor. Any inconsistency in the comparison function will destroy completely the whole container and the user will be unable
to retrieve the data stored or (worst) retrieve the wrong data.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;The interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagTreeMapInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(TreeMap&nbsp;*ST,&nbsp;void&nbsp;*Data,void&nbsp;*ExtraArgs);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(TreeMap&nbsp;*ST,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Applyfn)(const&nbsp;void&nbsp;*data,void&nbsp;*arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*Copy)(TreeMap&nbsp;*src);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*CreateWithAllocator)(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*m);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*Create)(size_t&nbsp;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(TreeMap&nbsp;*ST);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(TreeMap&nbsp;*ST);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(TreeMap&nbsp;*ST,void&nbsp;*element,void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(TreeMap&nbsp;*tree,&nbsp;void&nbsp;*element,void&nbsp;*ExtraArgs);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(TreeMap&nbsp;*t1,&nbsp;TreeMap&nbsp;*t2);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(TreeMap&nbsp;*ST);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*Find)(TreeMap&nbsp;*tree,void&nbsp;*element,void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(TreeMap&nbsp;*d);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*InitializeWith)(size_t&nbsp;elementSize,&nbsp;size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*Elements);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(TreeMap&nbsp;*RB,&nbsp;const&nbsp;void&nbsp;*Data,&nbsp;void&nbsp;*ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(TreeMap&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;TreeMap&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(TreeMap&nbsp;*src,FILE&nbsp;*stream,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(TreeMap&nbsp;*ST,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(TreeMap&nbsp;*Tree,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(TreeMap&nbsp;*ST,&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(TreeMap&nbsp;*ST,&nbsp;unsigned&nbsp;flags);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(TreeMap&nbsp;*ST);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(TreeMap&nbsp;*ST);&nbsp;&nbsp;
}&nbsp;TreeMapInterface;

</pre></font>
All the above functions were described for the sequential containers and their syntax is here the same.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Hash Table: iHashTable</h2>
<a 
name="HashTable80"></a>Hash table is a similar container as dictionary, but allows for more features at the expense of a slightly more complicated interface. 
Keys aren't restricted to zero terminated strings but can be any kind of data. 
The table resizes itself as it grows.
Merging two hash tables

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;The interface</h3>
<a 
name="iHashTable81"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagHashTableInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(HashTable&nbsp;*HT,const&nbsp;void&nbsp;*key,size_t&nbsp;klen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(HashTable&nbsp;*HT,int&nbsp;(*Applyfn)(void&nbsp;*Key,size_t&nbsp;klen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*data,void&nbsp;*arg),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;HashTable&nbsp;*ht,const&nbsp;void&nbsp;*Key,size_t&nbsp;klen);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Copy)(const&nbsp;HashTable&nbsp;*Orig,Pool&nbsp;*pool);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Create)(size_t&nbsp;ElementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(HashTable&nbsp;*HT,const&nbsp;void&nbsp;*key,size_t&nbsp;klen);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(const&nbsp;HashTable&nbsp;*HT,const&nbsp;void&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;klen);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Init)(HashTable&nbsp;*ht,size_t&nbsp;ElementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(HashTable&nbsp;*SC,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Merge)(Pool&nbsp;*p,&nbsp;const&nbsp;HashTable&nbsp;*overlay,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base,&nbsp;void&nbsp;*&nbsp;(*merger)(Pool&nbsp;*p,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*key,&nbsp;size_t&nbsp;klen,&nbsp;const&nbsp;void&nbsp;*h1_val,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*h2_val,&nbsp;const&nbsp;void&nbsp;*data),&nbsp;const&nbsp;void&nbsp;*data);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(HashTable&nbsp;*);
&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Overlay)(Pool&nbsp;*p,&nbsp;const&nbsp;HashTable&nbsp;*overlay,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(HashTable&nbsp;*HT,const&nbsp;void&nbsp;*key,&nbsp;size_t&nbsp;klen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*val);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(HashTable&nbsp;*HT,size_t&nbsp;newSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;HashTable&nbsp;*HT,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Search)(HashTable&nbsp;*ht,int&nbsp;(*Comparefn)(void&nbsp;*rec,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*key,size_t&nbsp;klen,const&nbsp;void&nbsp;*value),&nbsp;void&nbsp;*rec);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(HashTable&nbsp;*v,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(HashTable&nbsp;*HT,ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(HashTable&nbsp;*HT,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;GeneralHashFunction&nbsp;(*SetHashFunction)(HashTable&nbsp;*ht,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GeneralHashFunction&nbsp;hf);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;HashTable&nbsp;*HT);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;HashTable&nbsp;*ht);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;HashTableInterface;

</pre></font>


     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container82"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Add)(HashTable&nbsp;*ht,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the container using the given "key" string. It is assumed that "data" points to a contiguous memory area of at least ht-&#62;ElementSize bytes.  Both the key and the data are copied into the container.

<div class="p"><!----></div>
If an element exists with the given key, its contents are replaced with the new data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table, the key or the data pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

: The hash table is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, zero if the data was written into an existing element, or a negative error code if an error occurred.

<div class="p"><!----></div>

<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*ht;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iHashTable.Add(ht,"Interest&nbsp;rate",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strlen("Interest&nbsp;rate"),&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Apply+\container82"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(HashTable&nbsp;*ht,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(Applyfn)(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*data,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*extraArg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Apply will call the given function for each element of the array. The first argument of the callback function receives they key ,the second is the length of the key. The third is a pointer to one element of the table. The fourth argument of the callback is the &#235;xtraArg" argument that the Apply function receives and passes to the callback. This way some context can be passed to the callback, and from one element to the next.

<div class="p"><!----></div>
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable function type cast.

<div class="p"><!----></div>
If the dictionary is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

  Either the hash table pointer or Applyfn are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The hash table is read-only and there is no more memory to allocate the buffer to copy each element.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

static&nbsp;int&nbsp;print(const&nbsp;char&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pResult)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p&nbsp;=&nbsp;pElement;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s:&nbsp;%g\n",key,*p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;main(void)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*dict&nbsp;=&nbsp;iDictionary.Create(sizeof(double),5);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"First&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d&nbsp;=&nbsp;3;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Add(dict,"Second&nbsp;item",&amp;d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Apply(dict,print,NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
Output&nbsp;should&nbsp;be:
First&nbsp;item:&nbsp;2
Second&nbsp;item:&nbsp;3

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container82"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(HashTable&nbsp;*ht);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all stored data and releases the memory associated with it. The hash table header is not destroyed, and its contents will be the same as it was when initially created. It is an error to use this function when there are still active iterators for the container.

<div class="p"><!----></div>
<b>Returns:</b>
The result is greater than zero if successful, or an error code if an error occurs. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The hash table is read only.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*ht;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;m&nbsp;=&nbsp;iHashTable.Clear(ht);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Copy+\container82"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Copy)(const&nbsp;HashTable&nbsp;*Orig,Pool&nbsp;*pool);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the given hash table using the given pool. If "pool" is&nbsp;NULL ,the pool of the given hash table will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container82"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Create)(size_t&nbsp;ElementSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new hash table and initializes all fields. The table will use the current memory manager for its pool.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is zero or bigger than the maximum size the implementation supports.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="deleteIterator+\container82"></a> <font size="+1"><b>deleteIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases the memory used by the given iterator.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container82"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(HashTable&nbsp;*HT,void&nbsp;*key,size_t&nbsp;keyLength);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the hash table the element with the given key.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table parameter or the key pointer are&nbsp;NULL , or the keyLength is zero.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, a negative error code otherwise.

<div class="p"><!----></div>
Finalize
Synopsis:
    int (*Finalize)(HashTable *HT);
Description:
Releases all memory used by the hash table and destroys the hash table header itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is&nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="GetElement+\container82"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

void&nbsp;*(*GetElement)(const&nbsp;HashTable&nbsp;*H,const&nbsp;void&nbsp;*Key,size_t&nbsp;keyLen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the given hash table element. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table parameter or the key pointer are&nbsp;NULL , or the keyLen parameter is zero.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the element or&nbsp;NULL if no element with the specified key exists.

<div class="p"><!----></div>
 
<br /><a 
name="GetFlags+\container82"></a> <font size="+1"><b>GetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns an unsigned integer with the state of the table.

<div class="p"><!----></div>
 
<br /><a 
name="Load+\container82"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;HashTable&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a table previously saved with the Save function from the stream pointed to by stream. If readFn is not&nbsp;NULL , it will be used to read each element. The &#228;rg" argument will be passed to the read function. If the read function is&nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new table or&nbsp;NULL if the operation could not be completed. Note that the function pointers in the array are NOT saved in most implementations, nor any special allocator that was in the original table. In most implementations those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new table.

<div class="p"><!----></div>
 
<br /><a 
name="Merge+\container82"></a> <font size="+1"><b>Merge</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Merge)(Pool&nbsp;*p,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*overlay,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*&nbsp;(*merger)(Pool&nbsp;*p,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*h1_val,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*h2_val,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Merge two hash tables into one new hash table. If the same key is present in both tables, call the supplied merge function to produce a merged value for the key in the new table. Both hash tables must use the same hash function. 
The arguments should be:

<ol type="1">
<li>The pool to use when allocating memory. If&nbsp;NULL , the pool of the "base" hash table will be used.
<div class="p"><!----></div>
</li>

<li>
The first table to be used in the merge.
<div class="p"><!----></div>
</li>

<li>
The second table
<div class="p"><!----></div>
</li>

<li>
An argument to pass to the merger function.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
 
<br /><a 
name="NewIterator+\container82"></a> <font size="+1"><b>NewIterator</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Allocates and initializes a new iterator object to iterate this table. The exact sequence of each object returned is implementation defined but it will be the same for the same dictionary with the same number of elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a new iterator or&nbsp;NULL if the operation couldn't be completed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*HT;
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iHashTable.NewIterator(HT);
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(d=it-&#62;GetFirst(it);&nbsp;d&nbsp;!=&nbsp;NULL;&nbsp;d&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;val&nbsp;=&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Work&nbsp;with&nbsp;the&nbsp;value&nbsp;here
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iHashTable.deleteIterator(it);

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Overlay+\container82"></a> <font size="+1"><b>Overlay</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;HashTable&nbsp;*(*Overlay)(Pool&nbsp;*p,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*overlay,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;HashTable&nbsp;*base);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies overlay into base. If conflicts arise, the data in base will be copied in the result.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of the arguments is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
 
<br /><a 
name="Resize+\container82"></a> <font size="+1"><b>Resize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(HashTable&nbsp;*HT,size_t&nbsp;newSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will resize the given hash table to a new size. If the given new size is zero, the new size is implementation defined, and equal to the amount when automatic resizing occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The parameter is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation completed, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Replace+\container82"></a> <font size="+1"><b>Replace</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;(*Replace)(HashTable&nbsp;*HT,&nbsp;const&nbsp;void&nbsp;*key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;keyLength,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Will replace the contents of the given element if found.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The hash table pointer, the key or the replacement data are&nbsp;NULL , or the keyLength is zero.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element was replaced or zero if the element wasn't found. If the operation didn't complete a negative error code is returned.

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container82"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;HashTable&nbsp;*HT,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given table are saved into the given stream. If the save function pointer is not&nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The array pointer or the stream pointer are&nbsp;NULL .

<div class="p"><!----></div>
 EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

HashTable&nbsp;*HT;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iHashTable.Save(HT,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="SetErrorFunction+\container82"></a> <font size="+1"><b>SetErrorFunction</b></font> <hr />


<font size=+1><pre>

ErrorFunction&nbsp;(*SetErrorFunction)(HashTable&nbsp;*HT,ErrorFunction&nbsp;fn);&nbsp;

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Replaces the current error function  for the given table with the new error function if the
<font size="+1"><tt><i>ErrorFunction</i></tt></font>
parameter is different from&nbsp;NULL . If 
the
<font size="+1"><tt><i>HT</i></tt></font>
parameter is&nbsp;NULL the function returns the value of the current default error function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The table pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The table is read only and the function argument is not&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The old value of the error function or&nbsp;NULL if there is an error.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container82"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements stored in the given table.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The table pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The number of elements stored in the table

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container82"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;HashTable&nbsp;*HT);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of bytes of storage used in the given table including the size of the elements stored in it.
If HT is&nbsp;NULL the result is the size of the HashTable header.

<div class="p"><!----></div>
<b>Returns:</b>
The number of elements stored in the table or the size of the HashTable header if the HT pointer is&nbsp;NULL .

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Queues: iQueue</h2>
<a 
name="Queue90"></a>Queues are a type of container adaptors, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other.

<div class="p"><!----></div>
The sample implementation shows how to implement this container as an &#228;daptor" container, i.e. based on another container. The implementation uses a linked list to implement a queue
<a href="#tthFtNtADC" name="tthFrefADC"><sup>32</sup></a>.

     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Interface</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagQueueInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Back)(Queue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Queue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;Queue&nbsp;*(*Create)(size_t&nbsp;elementSize);
&nbsp;&nbsp;&nbsp;Queue&nbsp;*(*CreateWithAllocator)(size_t&nbsp;elementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Dequeue)(Queue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Enqueue)(Queue&nbsp;*Q,&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Queue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Front)(Queue&nbsp;*Q,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;List&nbsp;*(*GetData)(Queue&nbsp;*q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Queue&nbsp;*Q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Queue&nbsp;*Q);
}&nbsp;QueueInterface;

</pre></font>


     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;The API</h3>
All methods are exactly like the ones in other containers except for Enqueue, that is equivalent to &#196;dd" since adds one element at the end of the container, and Dequeue, that is the same as PopFront, i.e. pops the first element of the container.
 
<div class="p"><!----></div>
<br /><a 
name="Front+\container92"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;(*Front)(Queue&nbsp;*Q,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the contents of the first element in the given memory area that should be at least the size of the element size of the queue. Note that nothing is changed, and the first element is not erased from the container.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number for success, zero if the queue is empty or a negative error code.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Queue pointer is&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container92"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;(*Back)(Queue&nbsp;*Q,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the contents of the last element in the given memory area that should be at least the size of the element size of the queue. Note that nothing is changed, and the last element is not erased from the container.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number for success, zero if the queue is empty or a negative error code.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The Queue pointer is&nbsp;NULL .
 
<div class="p"><!----></div>
<br /><a 
name="GetData+\container92"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

List&nbsp;*(*GetData)(Queue&nbsp;*q);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Queues are based on the list container. It is not necessary to duplicate all the list functions in the queue interface: this function allows you to access the underlying list and use all the list specific APIs with it.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the list container or&nbsp;NULL if the queue pointer passed is&nbsp;NULL .

<div class="p"><!----></div>

 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Deque: iDeque</h2>
<a 
name="Deque100"></a>
Deque (usually pronounced like "deck") is an irregular acronym of double-ended queue. Double-ended queues are a kind of sequence containers. As such, their elements are ordered following a strict linear sequence.
Deques may be implemented by specific libraries in different ways, but in all cases they allow for adding and retrieving elements at both ends, with storage always handled automatically (expanding and contracting as needed). 

<div class="p"><!----></div>
Operations to insert and retrieve elements in the middle are not provided because if users need a plain sequential container they can use one. Individual implementation can offer those if they think it is useful. This differs from the C++ implementation.

<div class="p"><!----></div>
Here is a little table with a Rosetta stone for deque:

<div class="p"><!----></div>
<font size="-2">
<table>
<tr><td align="left">C </td><td align="left">Ada </td><td align="left">C++ </td><td align="left">Java </td><td align="left">Perl </td><td align="left">PHP </td><td align="left">Python 
</td></tr>
<tr><td align="left"></td></tr>
<tr><td align="left">PushBack </td><td align="left">Append </td><td align="left">push_back </td><td align="left">offerLast </td><td align="left">push </td><td align="left">array_push </td><td align="left">append 
</td></tr>
<tr><td align="left">PushFront </td><td align="left">Prepend </td><td align="left">push_front </td><td align="left">offerFirst </td><td align="left">unshift </td><td align="left">array_unshift </td><td align="left">appendleft 
</td></tr>
<tr><td align="left">PopBack </td><td align="left">Delete_Last </td><td align="left">pop_back </td><td align="left">pollLast </td><td align="left">pop </td><td align="left">array_pop </td><td align="left">pop 
</td></tr>
<tr><td align="left">PopFront </td><td align="left">Delete_First </td><td align="left">pop_front </td><td align="left">pollFirst </td><td align="left">shift </td><td align="left">array_shift </td><td align="left">popleft 
</td></tr>
<tr><td align="left">Back </td><td align="left">Last_Element </td><td align="left">back </td><td align="left">peekLast </td><td align="left">$array[-1] </td><td align="left">end </td><td align="left"> &lt; obj &gt; [-1]  
</td></tr></table>

</font>

<div class="p"><!----></div>
Some functions that the C++ interface provides like is_empty() can be obtained in this implementation simply by invoking:

<font size=+1><pre>
iDeque.Size(deque)&nbsp;==&nbsp;0

</pre></font>

     <h3><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;Interface</h3>
The interface iDeque is as follows:
<a 
name="iDeque101"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagDequeInterface&nbsp;{
&nbsp;&nbsp;&nbsp;void&nbsp;(*Apply)(Deque&nbsp;*Q,int&nbsp;(*Applyfn)(void&nbsp;*,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Back)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Contains)(Deque&nbsp;*&nbsp;d,&nbsp;void*&nbsp;item);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Copy)(Deque&nbsp;*d);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Create)(size_t&nbsp;elementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Deque&nbsp;*d1,Deque&nbsp;*d2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Deque&nbsp;*&nbsp;d,&nbsp;const&nbsp;void*&nbsp;item);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(Deque&nbsp;*&nbsp;d,&nbsp;const&nbsp;void*&nbsp;item);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Front)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Init)(Deque&nbsp;*d,size_t&nbsp;elementSize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(Deque&nbsp;*dc,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;Deque&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;readFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(Deque&nbsp;*Deq);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(Deque&nbsp;*d,void&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Deque&nbsp;*Q,const&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(Deque&nbsp;*Q,&nbsp;void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(Deque&nbsp;*&nbsp;d);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;Deque&nbsp;*d,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(Deque&nbsp;*Q,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(Deque&nbsp;*d,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(Deque&nbsp;*Q,unsigned&nbsp;newFlags);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(Deque&nbsp;*Q);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(Deque&nbsp;*d);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(Deque&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;DequeInterface;

</pre></font>


<div class="p"><!----></div>
The deque container can be implemented as an adaptor container, for instance based on a double linked list or in an vector. In any case the underlying container interface is not visible.
 
<div class="p"><!----></div>
<br /><a 
name="Apply+\container101"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;(*Apply)(Deque&nbsp;*d,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg);

</pre></font> 

<div class="p"><!----></div>
  <b>Description:</b> 
Will call the given function for each element. The first argument of the callback function receives an element of the array. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the array is read-only, a copy of the element will be passed to the callback function.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either the deque or Applyfn are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 The list is read-only and there is no more memory to allocate the buffer to copy each element.
 
<div class="p"><!----></div>
<br /><a 
name="Back+\container101"></a> <font size="+1"><b>Back</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Back)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the last element stored in the Deque d.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container101"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*Clear)(Deque&nbsp;*Q);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases all elements stored in the queue and reclaims the memory used. The Deque object itself is not destroyed.
Errors

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The deque pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
 
<br /><a 
name="Contains+\container101"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;&nbsp;(*Contains)(Deque&nbsp;*&nbsp;d,&nbsp;void*&nbsp;item);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the deque for the given data, returning its (index one based) position or zero if not found. 
Errors

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The deque pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The index of element or zero if not found.

<div class="p"><!----></div>
 
<br /><a 
name="Copy+\container101"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Deque&nbsp;&nbsp;*(*Copy)(Deque&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Makes a copy of the given deque. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new container or&nbsp;NULL if the operation did not complete.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container101"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;Deque&nbsp;&nbsp;*(*Create)(size_t&nbsp;elementSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new Deque container using &#235;lementSize" as the size that each element will have.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The elementSize parameter is zero or bigger than what the implementation supports.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to the new container or&nbsp;NULL if the operation did not complete.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d&nbsp;=&nbsp;iDeque.Create(sizeof(myType));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(d&nbsp;==&nbsp;NULL)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Equal+\container101"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(Deque&nbsp;*d1,Deque&nbsp;*d2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Compares the given deques using their comparison function. If they differ in their size, flags, or compare functions they compare unequal. If any of their elements differ, they compare unequal.
If both d1 and d2 are&nbsp;NULL they compare equal. If both are empty, they compare equal.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The result is one if the deques are equal, zero otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Front+\container101"></a> <font size="+1"><b>Front</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PeekFront)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the first element stored in the Deque d.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Erase+\container101"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(Deque&nbsp;*&nbsp;d,&nbsp;void*&nbsp;item);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Erases the first occurrence of the given element from the container if found, starting from the front.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer or the item pointer are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the item was found and erased, zero if the item wasn't found, or a negative error code if the operation did not complete.

<div class="p"><!----></div>
 
<br /><a 
name="Finalize+\container101"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(Deque&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the container erasing all elements, if any. Then it destroys the container object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque or the element pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation completed, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="GetFlags+\container101"></a> <font size="+1"><b>GetFlags</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(Deque&nbsp;*d);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Retrieves the state of the flags. If the implementation doesn't support this field this function always returns zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
The state of the flags field. 

<div class="p"><!----></div>
 
<br /><a 
name="Load+\container101"></a> <font size="+1"><b>Load</b></font> <hr />


<font size=+1><pre>

&nbsp;Deque&nbsp;*(*Load)(FILE&nbsp;*stream,ReadFunction&nbsp;readFn,void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads a deque previously saved with the Save function from the stream pointed to by stream. If readFn is not&nbsp;NULL , it will be used to read each element. The &#228;rg" argument will be passed to the read function. If the read function is&nbsp;NULL , this argument is ignored and a default read function is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given stream pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new deque or&nbsp;NULL if the operation could not be completed. Note that the function pointers in the deque are NOT saved in most implementations, nor any special allocator that was in the original table. In most implementations those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new table.

<div class="p"><!----></div>
 
<br /><a 
name="PopBack+\container101"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the last element stored in the Deque d, then erases the element from the deque.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="PopFront+\container101"></a> <font size="+1"><b>PopFront</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(Deque&nbsp;*d,void&nbsp;*outbuf);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given buffer the first element stored in the Deque d, thnen erases the element from the deque.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either d or outbuf are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="PushBack+\container101"></a> <font size="+1"><b>PushBack</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(Deque&nbsp;*d,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the end of the deque. It is assumed that &#235;lement" points to a contiguous memory area of at least ElementSize bytes.  

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque or the element pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iDeque.PushBack(d,&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="PushFront+\container101"></a> <font size="+1"><b>PushFront</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PushFront)(Deque&nbsp;*d,void&nbsp;*element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given element to the start of the deque. It is assumed that &#235;lement" points to a contiguous memory area of at least ElementSize bytes.  

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque or the element pointers are&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_READONLY

 The deque is read-only. No modifications allowed.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the operation added a new element, or a negative error code if an error occurred.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;data&nbsp;=&nbsp;4.5;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;iDeque.PushFront(d,&amp;data);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;/*&nbsp;Error&nbsp;handling&nbsp;*/&nbsp;}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container101"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;Deque&nbsp;*d,&nbsp;FILE&nbsp;*out,&nbsp;SaveFunction&nbsp;Fn,&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given deque are saved into the given stream. If the save function pointer is not&nbsp;NULL , it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The deque pointer or the stream pointer are&nbsp;NULL .
EOF A disk input/output error occurred.

<div class="p"><!----></div>
<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

Deque&nbsp;*d;
&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*outFile;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iDeque.Save(d,outFile,NULL,NULL)&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}

</pre></font>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Bloom filters</h2>
<a 
name="Bloomfilter110"></a>Bloom filters allow you to determine cheaply and quickly if an element is member of a set without actually looking into the large set. This container
doesn't store any data, just a series of bits indicating whether the element is there. 
It can return false answers, specifically a false positive meaning
it can answer &#255;es, the element is there" when in fact it is not. When it tells you however that the element is <b>not</b> there you can be sure
it is not in the set. The probability that a false answer occurs can be calculated in function of the size reserved for the bit table: the bigger
the table, the smaller the probability of a false answer for a fixed number of elements. <a href="#tthFtNtADD" name="tthFrefADD"><sup>33</sup></a>
<img src="BloomFilter.png" alt="Figure">
<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;The interface: iBloomFilter</h3>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagBloomFilterInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*CalculateSpace)(size_t&nbsp;maxfElements,double&nbsp;probability);
&nbsp;&nbsp;&nbsp;&nbsp;BloomFilter&nbsp;*(*Create)(size_t&nbsp;maxElements,double&nbsp;probability);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Add)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Find)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(BloomFilter&nbsp;*b);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(BloomFilter&nbsp;*b);
}&nbsp;BloomFilterInterface;

</pre></font>

     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;The API</h3>
 
<div class="p"><!----></div>
<br /><a 
name="CalculateSpace+\container112"></a> <font size="+1"><b>CalculateSpace</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*CalculateSpace)(size_t&nbsp;maxElements,double&nbsp;probability);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the space in bytes that would occupy a bloom filter to hold the given number of elements with the given probability. The probability parameter
should be greater than zero and smaller than 1.0. For values very close to the values zero and one, 
a huge number of bits can be necessary and the filter
creation function will return&nbsp;NULL because of lack memory problems.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The probability is smaller or equal than zero, or bigger or equal than one.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes needed or zero in case of error.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container112"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;BloomFilter&nbsp;*(*Create)(size_t&nbsp;maxElements,double&nbsp;probability);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates and initializes a filter with space enough to hold <i>MaxElements</i> with the given probability for a false answer. The probability parameter
should be greater than zero and smaller than 1.0. For values very close to the values zero and one, 
a huge number of bits can be necessary and the filter
creation function will return NULL because of lack memory problems.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The probability is smaller or equal than zero, or bigger or equal than one.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEM

 There is no memory for the allocation of the necessary data structures.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a newly allocated bloom filter or&nbsp;NULL in case of error.
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container112"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Add)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given key to the filter. The <font size="+1"><tt>keylen</tt></font> argument should be the length of the key, that should never be zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The filter pointer or the key pointer are&nbsp;NULL , or the <font size="+1"><tt>keylen</tt></font> is zero.

<div class="p"><!----></div>
CONTAINER_ERROR_CONTAINER_FULL

. The maximum number of elements has been reached.

<div class="p"><!----></div>
<b>Returns:</b>
The number of elements in the filter or zero if there is an error.
 
<div class="p"><!----></div>
<br /><a 
name="Find+\container112"></a> <font size="+1"><b>Find</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Find)(BloomFilter&nbsp;*b,const&nbsp;void&nbsp;*key,size_t&nbsp;keylen);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the given key in the filter.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The filter pointer or the key pointer are&nbsp;NULL , or the <font size="+1"><tt>keylen</tt></font> is zero.

<div class="p"><!----></div>
<b>Returns:</b>
One if the element is found, zero if it is not, or a negative error code if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container112"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(BloomFilter&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes all elements from the filter. No memory is released.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
One if all elements were cleared, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container112"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(BloomFilter&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases all memory held by the filter.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
One if all elements were cleared, a negative error code otherwise.
<BR CLEAR=LEFT><BR><BR>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Value arrays</h2>
<a 
name="iValArray120"></a>
<a 
name="ValArray120"></a>
Value arrays are a group of containers that store the basic types of the language: <font size="+1"><tt>short, int, long, long long, float, double, long double</tt></font>
and have some specialized operations that should be done in hardware when the underlying CPU allows it. The objective here is to simplify the 
<font size="+1"><tt>vector</tt></font> interface replacing the <font size="+1"><tt>void *</tt></font> with the concrete type that these arrays hold.

<div class="p"><!----></div>
We have the following ValArrays:

<center>

<table>
<tr><td align="left"><b>Name</b></td><td align="left"><b>Interface name</b></td><td align="left"><b>Element type</b></td></tr>
<tr><td align="left">ValArrayShort</td><td align="left">iValArrayShort</td><td align="left">short</td></tr>
<tr><td align="left">ValArrayInt</td><td align="left">iValArrayInt</td><td align="left">int</td></tr>
<tr><td align="left">ValArrayUInt</td><td align="left">iValArrayUInt</td><td align="left">unsigned</td></tr>
<tr><td align="left">ValArrayLong</td><td align="left">iValArrayLong</td><td align="left">long</td></tr>
<tr><td align="left">ValArrayDouble</td><td align="left">iValArrayDouble</td><td align="left">double</td></tr>
<tr><td align="left">ValArrayFloat</td><td align="left">iValArrayFloat</td><td align="left">float</td></tr>
<tr><td align="left">ValArrayLongDouble</td><td align="left">iValArrayLongDouble</td><td align="left">long double</td></tr>
<tr><td align="left">ValArrayLLong</td><td align="left">iValArrayLLong</td><td align="left">long long</td></tr>
<tr><td align="left">ValArrayULLong</td><td align="left">iValArrayULLong</td><td align="left">unsigned long long</td></tr>
<tr><td align="left">ValArraySize_t</td><td align="left">iValArraySize_t</td><td align="left">size_t</td></tr></table>

</center>
Some types can be just aliases for other types. For instance when int and long have the same size there is no point in providing a separate
implementation. This will be always the case with the type <font size="+1"><tt>size_t</tt></font> that will be an alias for one of the unsigned types. This type is needed to
represent arrays of indices that can be used to select elements into another array.

<div class="p"><!----></div>
The operations supported are the same as the vector data type with several differences:

<ul>
<li> Simplified interfaces. For instance in the vector container the result of GetElement is always a pointer to the data. ValArray simplifies this by
using directly the underlying type as return value. The functions that change their signature are:

<ol type="1">
<li> Contains. Second parameter is not a pointer but the underlying type.
<div class="p"><!----></div>
</li>

<li> Erase. Second parameter is not a pointer but the underlying type.
<div class="p"><!----></div>
</li>

<li> Apply. The apply function receives the underlying type and not a pointer.
<div class="p"><!----></div>
</li>

<li> Add. The second argument is the underlying type.
<div class="p"><!----></div>
</li>

<li> GetElement. Returns the underlying type.
<div class="p"><!----></div>
</li>

<li> PushBack.Second argument changes.
<div class="p"><!----></div>
</li>

<li> PopFront. Returns the underlying type.
<div class="p"><!----></div>
</li>

<li> InsertAt. Second argument.
<div class="p"><!----></div>
</li>

<li> ReplaceAt. Third argument
<div class="p"><!----></div>
</li>

<li> IndexOf. Second argument.
<div class="p"><!----></div>
</li>

<li> Insert. Second argument
<div class="p"><!----></div>
</li>

<li> AddRange. Second argument is not a void pointer but a pointer to the underlying type.
<div class="p"><!----></div>
</li>

<li> CopyElement. Second argument is not a void pointer but a pointer to the underlying type.
<div class="p"><!----></div>
</li>

<li> CopyTo. The return type is not a <font size="+1"><tt>void **</tt></font> but a pointer to an array of the underlying type.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li> No destructors. There is no point in using destructors with the basic types.
<div class="p"><!----></div>
</li>

<li> No extra arguments used in the comparison function. The comparison is done inline whenever possible. The function <font size="+1"><tt>SetComparisonFunction</tt></font>
is accepted but does nothing.
<div class="p"><!----></div>
</li>

<li> Creation functions do not need the element size parameter.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>GetElementSize</tt></font> returns the size in bytes of the underlying type but doesn't use its argument that can be&nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>Save</tt></font> and <font size="+1"><tt>Load</tt></font> functions do not need a save/load function. Their signature is changed.
<div class="p"><!----></div>
</li>

<li> Iterators are unchanged and still return a pointer to an element. This way is it possible to return&nbsp;NULL to stop the iteration of course.
<div class="p"><!----></div>
</li>

<li> No tests for&nbsp;NULL arguments in the default version. 
Obviously those tests can be added in other versions or implementation since any&nbsp;NULL arguments
provokes undefined behavior.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;Operations</h3>
Each operation described below needs two compatible arrays, i.e. arrays that have the same number of elements. If that is not the case an error
occurs. A single number can be used in place of an array, extending it to the shape of the array. The naming convention is to add the "Scalar" token
to the operation name, so we have for instance <font size="+1"><tt>MultiplyWith</tt></font> and <font size="+1"><tt>MultiplyWithScalar</tt></font>.

<div class="p"><!----></div>
In general all operations use the data of the left argument and write their results into the left argument. The right argument remains unmodified.
This allows to construct efficient RPN evaluators to avoid allocating intermediate results.

     <h3><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;Slices and masks</h3>
A <b>slice</b> is a description of a certain portion of the array. It has three fields:

<ol type="1">
<li> <b>Start</b>, The zero based index of the element that starts the slice.
<div class="p"><!----></div>
</li>

<li> <b>Length</b>. The number of elements that are selected by the slice.
<div class="p"><!----></div>
</li>

<li> <b>Increment</b>. The number of elements that are skipped between elements when passing from one element of the slice to the next.
<div class="p"><!----></div>
</li>
</ol>
When a ValArray is created, the slice used is the default one: <font size="+1"><tt>0, Size(ValArray), 1</tt></font>. The slice starts at element zero,
has the same number of elements that the number of elements in the array, and its increment is 1. Using the API <font size="+1"><tt>SetSlice</tt></font> and
<font size="+1"><tt>ResetSlice</tt></font> you can modify the elements that will be selected for all operations. When a slice is active, all elements that aren't in the
selected slice are ignored.

<div class="p"><!----></div>
Slices are maintained by the library automatically. If you erase elements from the array until the slice is empty, the library automatically
resets the slice. If you add elements, the length of the slice will increase if necessary.

<div class="p"><!----></div>
A <b>Mask</b> is a boolean vector of ones or zeroes that selects elements from the array. It can be implemented as a bitstring or as a sequence
of bytes, this is implementation defined. When used in combination with some ValArray operation, it selects the elements that will be affected
by the operation.

     <h3><a name="tth_sEc12.3">
12.3</a>&nbsp;&nbsp;The interface</h3>
This is a generic interface description. The <font size="+1"><tt>ElementType</tt></font> token is replaced in each ValArray by the underlying type: 
int, double, etc. In the same
style, <font size="+1"><tt>ValArray</tt></font> and the <font size="+1"><tt>ValArrayInterface</tt></font> tokens are replaced with the corresponding value array name and interface name.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagValArrayInterface&nbsp;{
&nbsp;&nbsp;&nbsp;int&nbsp;(*Abs)(ValArray&nbsp;*src);&nbsp;
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Accumulate)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(ValArray&nbsp;*AL,ElementType&nbsp;newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(ValArray&nbsp;*AL,size_t&nbsp;n,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;*newvalues);
&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*AndScalar)(ValArray&nbsp;*left,&nbsp;const&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(ValArray&nbsp;*AL1,&nbsp;ValArray&nbsp;*AL2);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Apply)(ValArray&nbsp;*AL,int&nbsp;(*Applyfn)(ElementType&nbsp;element,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*&nbsp;arg),void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Back)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitLeftShift)(ValArray&nbsp;*data,int&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*BitRightShift)(ValArray&nbsp;*data,&nbsp;const&nbsp;int&nbsp;shift);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*Compare)(const&nbsp;ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqual)(const&nbsp;ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*CompareEqualScalar)(const&nbsp;ValArray&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;right,&nbsp;Mask&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;char&nbsp;*(*CompareScalar)(const&nbsp;ValArray&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;right,char&nbsp;*bytearray);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(const&nbsp;ValArray&nbsp;*AL,ElementType&nbsp;data);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Copy)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*CopyElement)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;*outbuf);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;*(*CopyTo)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Create)(size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*CreateSequence)(size_t&nbsp;n,ElementType&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;increment);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideBy)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideByScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideScalarBy)(ElementType&nbsp;left,ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(const&nbsp;ValArray&nbsp;*first,&nbsp;const&nbsp;ValArray&nbsp;*second);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(ValArray&nbsp;*AL,ElementType&nbsp;elem);
&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(ValArray&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;Mask&nbsp;*(*FCompare)(const&nbsp;ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bytearray,ElementType&nbsp;tolerance);
&nbsp;&nbsp;&nbsp;int&nbsp;(*FillSequential)(ValArray&nbsp;*dst,size_t&nbsp;length,ElementType&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;increment);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ForEach)(ValArray&nbsp;*src,ElementType&nbsp;(*ApplyFn)(ElementType));
&nbsp;&nbsp;&nbsp;int&nbsp;(*Fprintf)(const&nbsp;ValArray&nbsp;*src,FILE&nbsp;*out,const&nbsp;char&nbsp;*fmt);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Front)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*(*GetAllocator)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;*(*GetData)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*GetElement)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*GetRange)(const&nbsp;ValArray&nbsp;*AL,&nbsp;size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*GetSlice)(ValArray&nbsp;*array,size_t&nbsp;*start,size_t&nbsp;*length,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*increment);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*IndexIn)(const&nbsp;ValArray&nbsp;*SC,const&nbsp;ValArraySize_t&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(ValArray&nbsp;*AL,ElementType&nbsp;data,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Init)(ValArray&nbsp;*AL,size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InitIterator)(ValArray&nbsp;*AL,void&nbsp;*buf);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*InitializeWith)(size_t&nbsp;n,&nbsp;ElementType&nbsp;*data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Insert)(ValArray&nbsp;*AL,ElementType);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(ValArray&nbsp;*AL,size_t&nbsp;idx,ElementType&nbsp;newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertIn)(ValArray&nbsp;*AL,&nbsp;size_t&nbsp;idx,&nbsp;ValArray&nbsp;*newData);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Inverse)(ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Load)(FILE&nbsp;*stream);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Max)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Memset)(ValArray&nbsp;*dst,ElementType&nbsp;fillValue,size_t&nbsp;length);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Min)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mismatch)(const&nbsp;ValArray&nbsp;*a1,const&nbsp;ValArray&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Mod)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ModScalar)(ValArray&nbsp;*left,const&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWith)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWithScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Not)(ValArray&nbsp;*left);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*OrScalar)(ValArray&nbsp;*left,&nbsp;const&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PopBack)(ValArray&nbsp;*AL,ElementType&nbsp;*result);
&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Product)(const&nbsp;ValArray&nbsp;*src);
&nbsp;&nbsp;&nbsp;int&nbsp;(*PushBack)(ValArray&nbsp;*AL,ElementType&nbsp;data);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RemoveRange)(ValArray&nbsp;*src,size_t&nbsp;start,size_t&nbsp;end);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(ValArray&nbsp;*AL,size_t&nbsp;idx,ElementType&nbsp;newval);
&nbsp;&nbsp;&nbsp;int&nbsp;(*ResetSlice)(ValArray&nbsp;*array);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Reverse)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(ValArray&nbsp;*AL,&nbsp;size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(ValArray&nbsp;*AL,size_t&nbsp;n);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(const&nbsp;ValArray&nbsp;*AL,FILE&nbsp;*stream);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Select)(ValArray&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*SelectCopy)(const&nbsp;ValArray&nbsp;*src,const&nbsp;Mask&nbsp;*m);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetCapacity)(ValArray&nbsp;*AL,size_t&nbsp;newCapacity);
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;(*SetCompareFunction)(ValArray&nbsp;*l,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;(*SetDestructor)(ValArray&nbsp;*cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(ValArray&nbsp;*AL,ErrorFunction);
&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(ValArray&nbsp;*AL,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SetSlice)(ValArray&nbsp;*src,size_t&nbsp;start,size_t&nbsp;length,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;increment);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;size_t&nbsp;(*SizeofIterator)(const&nbsp;ValArray&nbsp;*);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFrom)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFromScalar)(ElementType&nbsp;left,&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractScalarFrom)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SumScalarTo)(ValArray&nbsp;*left,ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*SumTo)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*Xor)(ValArray&nbsp;*left,&nbsp;const&nbsp;ValArray&nbsp;*right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*XorScalar)(ValArray&nbsp;*left,&nbsp;const&nbsp;ElementType&nbsp;right);
&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
}&nbsp;ValArrayInterface;

</pre></font>

<BR CLEAR=LEFT><BR><BR>
<img src="ValArray.png" alt="Figure">

<div class="p"><!----></div>
 
<br /><a 
name="Abs+\container123"></a> <font size="+1"><b>Abs</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Abs)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
If any of the values in the source array is smaller than zero it will be negated. This function is only defined for signed or floating point types.
It has no meaning with unsigned types.

<div class="p"><!----></div>
<b>Returns:</b>Zero if the array was empty, a positive number if successful.
 
<div class="p"><!----></div>
<br /><a 
name="Accumulate+\container123"></a> <font size="+1"><b>Accumulate</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;(*Accumulate)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Calculates the sum of all the elements of the given vector. If a slice definition is active only the slice elements are considered.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None are mandatory but implementations should check for overflow when possible.

<div class="p"><!----></div>
<b>Returns:</b>The sum of the elements.

<div class="p"><!----></div>
 
<br /><a 
name="Add+\container123"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(ValArray&nbsp;*AL,ElementType&nbsp;newval);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds an element at the end of the array. If a slice is active, the increment field (stride) will be used: the new element will be separated by the 
increment field of the slice and empty fields will be filed with zeroes. The length of the slice will be incremented by one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element was added or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="AddRange+\container123"></a> <font size="+1"><b>AddRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*AddRange)(ValArray&nbsp;*AL,size_t&nbsp;n,ElementType&nbsp;*newvalues);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds a range of elements at the end of the array. If a slice is active, the increment field (stride) will be used: each new element will be separated by 
the increment field of the slice and empty fields will be filed with zeroes. The length of the slice will be incremented by n. If n is zero no error
will be issued and the result is a positive number.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the elements were added or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Apply+\container123"></a> <font size="+1"><b>Apply</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Apply)(ValArray&nbsp;*AL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Applyfn)(ElementType&nbsp;element,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Calls the given function for each element of the array. If a slice is active only the elements in the slice will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>A positive number

<div class="p"><!----></div>
 
<br /><a 
name="And+\container123"></a> <font size="+1"><b>And</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*And)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise AND operation between each element of the right argument with the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;&amp;=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning. If a slice is active only the slice elements are affected. If both arrays have slices they must be compatible, i.e. they must have the
same length.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays or slices have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="BitLeftShift+\container123"></a> <font size="+1"><b>BitLeftShift</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*BitLeftShift)(ValArray&nbsp;*dst,int&nbsp;shift);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Shifts left each element of the given ValArray by <font size="+1"><tt>shift</tt></font> bits. If <font size="+1"><tt>shift</tt></font> is negative it performs a right shift instead.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors. 

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code if an implementation detects an invalid pointer. This error is not required to be detected.

<div class="p"><!----></div>
 
<br /><a 
name="BitRightShift+\container123"></a> <font size="+1"><b>BitRightShift</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*BitRightShift)(ValArray&nbsp;*dst,int&nbsp;shift);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Shifts right each element of the given ValArray by <font size="+1"><tt>shift</tt></font> bits. If <font size="+1"><tt>shift</tt></font> is negative it performs a left shift instead.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors. 

<div class="p"><!----></div>
<b>Returns:</b>A positive number or a negative error code if an implementation detects an invalid pointer. This error is not required to be detected.

<div class="p"><!----></div>
 
<br /><a 
name="Clear+\container123"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(ValArray&nbsp;*array);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the number of elements to zero but doesn't release any memory. Any slice definitions are cleared.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>A positive integer.
 
<div class="p"><!----></div>
<br /><a 
name="Compare+\container123"></a> <font size="+1"><b>Compare</b></font> <hr />


<font size=+1><pre>

char&nbsp;*(*Compare)(ValArray&nbsp;*left,ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each byte of the bitarray the result of comparing the corresponding elements of the left and right arrays. Conceptually this operation is: 
<font size=+1><pre>
byte[i]&nbsp;=&nbsp;(left[i]&nbsp;&lt;&nbsp;right[i])&nbsp;?&nbsp;-1&nbsp;:&nbsp;(left[i]&nbsp;==&nbsp;right[i])&nbsp;?&nbsp;0&nbsp;:&nbsp;1

</pre></font>
If the bytearray argument is&nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. 
If it is not&nbsp;NULL it will be assumed that it contains at least
<font size="+1"><tt>GetSize(left)</tt></font>
positions available.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was&nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The arrays are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CompareScalar+\container123"></a> <font size="+1"><b>CompareScalar</b></font> <hr />


<font size=+1><pre>

char&nbsp;*(*CompareScalar)(const&nbsp;ValArray&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ElementType&nbsp;right,&nbsp;char&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each byte of the bitarray the result of comparing the elements of the left array with the right argument. 
Conceptually this operation is: 

<font size=+1><pre>
byte[i]&nbsp;=&nbsp;(left[i]&nbsp;&lt;&nbsp;right)&nbsp;?&nbsp;-1&nbsp;:&nbsp;(left[i]&nbsp;==&nbsp;right)&nbsp;?&nbsp;0&nbsp;:&nbsp;1

</pre></font>
If the bitarray argument is&nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. If it is not&nbsp;NULL it will be assumed that it contains at least
<font size="+1"><tt>GetSize(left)</tt></font>
positions available.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was&nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CompareEqual+\container123"></a> <font size="+1"><b>CompareEqual</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(ValArray&nbsp;*left,ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each element of the mask the result of comparing the corresponding elements of the left and right arrays. Conceptually this operation is: 
<font size=+1><pre>
bit[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right[i])

</pre></font> 
If the bitarray argument is&nbsp;NULL it will be allocated and returned. The allocator used is the global memory manager. 
If it is not&nbsp;NULL it should contain at least enough positions to hold the data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was&nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given mask hasn't enough positions available.

<div class="p"><!----></div>
CONTAINER_ERROR_INCOMPATIBLE

 The arrays are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray passed or allocated, or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CompareEqualScalar+\container123"></a> <font size="+1"><b>CompareEqualScalar</b></font> <hr />


<font size=+1><pre>

Mask&nbsp;*(*CompareEqual)(ValArray&nbsp;*left,ElementType&nbsp;right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*bitarray);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each bit of the bitarray the result of comparing the elements of the left array with the right argument. 
Conceptually this operation is: 

<font size=+1><pre>
bit[i]&nbsp;=&nbsp;(left[i]&nbsp;==&nbsp;right)

</pre></font> 
If the bitarray argument is&nbsp;NULL it will be allocated and returned. The allocator used is the one from the left argument. If it is not&nbsp;NULL it will be assumed that it contains at least
<div class="p"><!----></div>
<font size="+1"><tt>1+GetSize(left)/CHAR_BIT</tt></font>
<div class="p"><!----></div>
positions available.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was&nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Contains+\container123"></a> <font size="+1"><b>Contains</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Contains)(ValArray&nbsp;*a,ElementType&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches the given data in the array. If any slice specifications are active, only the slice is searched.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
One if the given data is stored in the array, zero otherwise. 

<div class="p"><!----></div>
 
<br /><a 
name="Copy+\container123"></a> <font size="+1"><b>Copy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*Copy)(const&nbsp;ValArray&nbsp;*A);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
A copy of the given array is performed. The new memory will be allocated using the given array's allocator. If any slice specifications are current, 
only the elements of the slice will be copied into the resulting vector, that will have the size of the slice. Slice specifications are not copied.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>The new array. 

<div class="p"><!----></div>
 
<br /><a 
name="CopyTo+\container123"></a> <font size="+1"><b>CopyTo</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;*(*CopyTo)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the whole contents of the given array into a table of newly allocated elements. If a slice specification is active only the slice will be
returned.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A pointer to a table or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container123"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*Create)(size_t&nbsp;capacity);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an empty array with enough storage to hold <font size="+1"><tt>capacity</tt></font> elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough storage to complete this operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the empty array or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="CreateSequence+\container123"></a> <font size="+1"><b>CreateSequence</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*CreateSequence)(size_t&nbsp;size,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;startValue,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an array with <font size="+1"><tt>size</tt></font> elements and fills it with elements of the ValArray data type starting with
the <font size="+1"><tt>startValue</tt></font> argument, and increasing it by the value of <font size="+1"><tt>increment</tt></font> at each step. The <font size="+1"><tt>increment</tt></font> value can be negative or zero. If it is zero the array is filled with the same value. This is equivalent to the <font size="+1"><tt>Fill</tt></font> API<a href="#tthFtNtADE" name="tthFrefADE"><sup>34</sup></a>.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough storage to complete this operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the sequence or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="DivideBy+\container123"></a> <font size="+1"><b>DivideBy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideBy)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Divides each element of the left argument by the corresponding element of the right argument. Conceptually this operation is: <font size="+1"><tt>left /= right</tt></font>. 
If any of the elements of the right argument is zero, an error occurs and the computation stops, leaving the left argument with some elements divided
and others not<a href="#tthFtNtADF" name="tthFrefADF"><sup>35</sup></a>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
CONTAINER_ERROR_DIVIDE_BY_ZERO

 The second argument has an element that is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="DivideByScalar+\container123"></a> <font size="+1"><b>DivideByScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideByScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Divides each element of the left argument by the right argument. Conceptually this operation is: <font size="+1"><tt>left /= right</tt></font>. If the right argument is zero
an error occurs and the left argument remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_DIVIDE_BY_ZERO

 The second argument is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="DivideScalarBy+\container123"></a> <font size="+1"><b>DivideScalarBy</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*DivideScalarBy)(ElementType&nbsp;left,&nbsp;ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Divides each element of the left argument by the right argument. Conceptually this operation is: <font size="+1"><tt>right = left / right</tt></font>. If the left argument is zero
an error occurs and the right argument remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_DIVIDE_BY_ZERO

 The first argument is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Equal+\container123"></a> <font size="+1"><b>Equal</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Equal)(const&nbsp;ValArray&nbsp;*src1,const&nbsp;ValArray&nbsp;*src2);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns 1 if both arrays are equal, zero otherwise. It is legal to compare an array with&nbsp;NULL . If both arrays are&nbsp;NULL they compare equal. Any slice
definitions in the arrays must be equal. If equal, they restrict the number of elements compared. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>True or false depending if the arrays are equal or not.
 
<div class="p"><!----></div>
<br /><a 
name="Erase+\container123"></a> <font size="+1"><b>Erase</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(ValArray&nbsp;*AL,ElementType&nbsp;data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the vector the element that matches the given data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOTFOUND

 No match was found.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not
in the ValArray the result value is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.
 
<div class="p"><!----></div>
<br /><a 
name="EraseAll+\container123"></a> <font size="+1"><b>EraseAll</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAll)(ValArray&nbsp;*v,const&nbsp;void&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the array all elements that match the given data, that is assumed to be a pointer to an element.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred, or a positive value that indicates that at least a match was found and the element was removed. If the 
element is not in the list the result is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
 
<br /><a 
name="EraseAt+\container123"></a> <font size="+1"><b>EraseAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(ValArray&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Removes from the array the element at the given position. If a slice specification is defined for the array, the index is understood as an
index within the slice and not as an index in the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given vector pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurred or a positive value that indicates that the element was removed.

<div class="p"><!----></div>
 
<br /><a 
name="FCompare+\container123"></a> <font size="+1"><b>FCompare</b></font> <hr />


<font size=+1><pre>

char&nbsp;*(*FCompare)(const&nbsp;ValArray&nbsp;*left,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ValArray&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*bytearray,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;tolerance);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function is exactly like the Compare function but designed for comparing floating point numbers. Direct comparison of floating point numbers are known to be problematic. This comparison will be realized within the tolerance defined by the fourth parameter

<div class="p"><!----></div>
The sample implementation uses the ideas of Donald Knuth
<a href="#tthFtNtADG" name="tthFrefADG"><sup>36</sup></a>
as implemeted by Theodore C. Belding
<a href="#tthFtNtADH" name="tthFrefADH"><sup>37</sup></a>
In the documentation of its software, Mr Belding writes:

<blockquote>
What is needed is a comparison operator that takes into account a
certain amount of uncertainty:

<font size=+1><pre>
if&nbsp;(fabs(x&nbsp;-&nbsp;y)&nbsp;&lt;=&nbsp;epsilon)&nbsp;{
&nbsp;&nbsp;/*&nbsp;code&nbsp;to&nbsp;be&nbsp;executed&nbsp;if&nbsp;x&nbsp;==&nbsp;y&nbsp;*/
}

if&nbsp;(x&nbsp;-&nbsp;y&nbsp;&#62;&nbsp;epsilon)&nbsp;{
&nbsp;&nbsp;/*&nbsp;code&nbsp;to&nbsp;be&nbsp;executed&nbsp;if&nbsp;x&nbsp;&#62;&nbsp;y&nbsp;*/
}

if&nbsp;(x&nbsp;-&nbsp;y&nbsp;&lt;&nbsp;-epsilon)&nbsp;{
&nbsp;&nbsp;/*&nbsp;code&nbsp;to&nbsp;be&nbsp;executed&nbsp;if&nbsp;x&nbsp;&lt;&nbsp;y&nbsp;*/
}

</pre></font>
In the above code, a neighborhood is defined that extends a distance
epsilon to either side of y on the real number line.  If x falls
within epsilon of y, x is declared to be equal to y (the first case,
above).  If x is greater than y by an amount that is greater than
epsilon, x is declared to be greater than y (the second case, above).
If x is less than y by an amount that is greater than epsilon, x is
declared to be less than y (the third case, above).

<div class="p"><!----></div>
The problem then becomes to determine an appropriate value of epsilon.
A fixed value of epsilon would not work for all x and y; epsilon
should be scaled larger or smaller depending on the magnitudes of the
numbers to be compared.

<div class="p"><!----></div>
A floating point number is represented by two numbers, the significand
(also called the fraction or mantissa) and the exponent, and a sign,
where

<div class="p"><!----></div>
<font size="+1"><tt>0&nbsp;&lt;=&nbsp;significand&nbsp;&lt;&nbsp;1</tt></font> 

<div class="p"><!----></div>
and 

<div class="p"><!----></div>
<font size="+1"><tt>number = sign * significand * pow(2, exponent)</tt></font>.

<div class="p"><!----></div>
Knuth's suggestion is to scale epilon by the exponent of the larger of the
two floating point numbers to be compared:

<div class="p"><!----></div>
delta = epsilon * maxExponent,

<div class="p"><!----></div>
where maxExponent is the exponent of max(x, y).  Delta can then be
substituted for epsilon in the code snippets above.

<div class="p"><!----></div>
<b>Determining epsilon</b>

<div class="p"><!----></div>
Now that we have found a way to scale epsilon to work with a wide
range of x and y, we still need to choose an appropriate epsilon,
before scaling.  

<div class="p"><!----></div>
If the number of binary digits of error, e, is known, then epsilon
can be calculated as follows:

<font size=+1><pre>
epsilon&nbsp;=&nbsp;(pow(2,&nbsp;e)&nbsp;-&nbsp;1)&nbsp;*&nbsp;FLT_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for&nbsp;floats)
epsilon&nbsp;=&nbsp;(pow(2,&nbsp;e)&nbsp;-&nbsp;1)&nbsp;*&nbsp;DBL_EPSILON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(for&nbsp;doubles)

</pre></font>
<font size="+1"><tt>FLT_EPSILON</tt></font> and <font size="+1"><tt>DBL_EPSILON</tt></font> are equivalent to 1 ulp for single- and
double-precision numbers, respectively; they are defined in the
standard C header file <font size="+1"><tt>&lt;float.h&gt;</tt></font>. (An ulp is one unit in the last
place of the significand, or fraction part, of a floating point
number; see Knuth for more details.)
</blockquote>

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. The given byte array argument was&nbsp;NULL but there is no memory to allocate the result.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the bitarray or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="FillSequential+\container123"></a> <font size="+1"><b>FillSequential</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*FillSequential)(ValArray&nbsp;*a,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;start,ElementType&nbsp;increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to all members of the array a sequence that starts at <font size="+1"><tt>start</tt></font>, and is incremented by the given amount at each array position.
The start and increment arguments can hold any value without restrictions, unless they go beyond the maximum value allowed for the given data
type

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors. 

<div class="p"><!----></div>
<b>Returns:</b>A positive number.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

ValARray&nbsp;*myValARray&nbsp;=&nbsp;iValArray.Create(6);
iValArray.FillSequential(myValArray,5,2);
//&nbsp;Now&nbsp;the&nbsp;contents&nbsp;of&nbsp;myValArray&nbsp;are:
5,7,9,11,13,15

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="Finalize+\container123"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the container, including the array header object itself.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
A positive value means the operation completed.

<div class="p"><!----></div>
 
<br /><a 
name="ForEach+\container123"></a> <font size="+1"><b>ForEach</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*ForEach)(ValArray&nbsp;*src,ElementType&nbsp;(*ApplyFn)(ElementType));

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Applies the one argument <font size="+1"><tt>ApplyFn</tt></font> to each element of the array and stores the result in that element.

<div class="p"><!----></div>
<b>Returns:</b>Always 1<a href="#tthFtNtADI" name="tthFrefADI"><sup>38</sup></a>.

<div class="p"><!----></div>
 
<br /><a 
name="Fprintf+\container123"></a> <font size="+1"><b>Fprintf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Fprintf)(ValArray&nbsp;*src,FILE&nbsp;*out,const&nbsp;char&nbsp;*fmt);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Prints in the indicated stream each element of the given array using the indicated format string. If the array is empty nothing is printed and
the result is zero. There is a newline character appended to the output if the array wasn't empty and no error occurred.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_EOF

 An output error occurred: impossible to write to the stream.

<div class="p"><!----></div>
<b>Returns:</b>
The number of characters written to the stream, zero if the array was empty, or a negative error code.
 
<div class="p"><!----></div>
<br /><a 
name="GetCapacity+\container123"></a> <font size="+1"><b>GetCapacity</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetCapacity)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the number of elements the array can hold before  it needs to reallocate its data.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
The array capacity.

<div class="p"><!----></div>
 
<br /><a 
name="GetData+\container123"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;*(*GetData)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the data area of the container, or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_READONLY

 The container is read-only.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The given pointer is&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>The pointer to the array's data or&nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="GetElement+\container123"></a> <font size="+1"><b>GetElement</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*GetElement)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the value stored at the element with the given index.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INDEX

    The given position is out of bounds.

<div class="p"><!----></div>
<b>Returns:</b>The element's value or the minimum value that can be stored in ElementType if the index is out of bounds.

<div class="p"><!----></div>
 
<br /><a 
name="GetElementSize+\container123"></a> <font size="+1"><b>GetElementSize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;size_t&nbsp;(*GetElementSize)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the size of the elements stored in the ValArray. The argument is not used and can be&nbsp;NULL .

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
 
<br /><a 
name="GetRange+\container123"></a> <font size="+1"><b>GetRange</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*GetRange)(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;start,size_t&nbsp;end);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Selects a series of consecutive elements starting at position start and ending at position one less than end.
If start  &gt;  end or start  &gt;  Size(ValArray), &nbsp;NULL is returned. If end is bigger than the number of elements in the array, only elements up to the number of elements will be used.
<div class="p"><!----></div>
If a slice is active in the array, the arguments will be understood as indices in the slice and <b>not</b> in the original array.
<div class="p"><!----></div>
The selected elements are copied into a new array. The original array remains unchanged.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>:
A pointer to a new ValArray containing the selected elements or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="GetSlice+\container123"></a> <font size="+1"><b>GetSlice</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*GetSlice)(ValArray&nbsp;*array,size_t&nbsp;*start,&nbsp;size_t&nbsp;*length,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies into the given pointers the contents of the current slice specifications for the given array. If any of the given pointers is&nbsp;NULL nothing is 
copied into it and no error is issued. If the array has no slice specification all fields will be set to zero if not&nbsp;NULL , and the result is zero.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors

<div class="p"><!----></div>
<b>Returns:</b>Zero if there isn't any slice specification, a positive number otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

/*&nbsp;This&nbsp;allows&nbsp;to&nbsp;know&nbsp;if&nbsp;there&nbsp;is&nbsp;a&nbsp;slice&nbsp;defined&nbsp;for&nbsp;a&nbsp;given&nbsp;array&nbsp;*/
if&nbsp;(iValArray.GetSlice(myValArray,NULL,NULL,NULL))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;array&nbsp;has&nbsp;a&nbsp;slice&nbsp;defined&nbsp;into&nbsp;it&nbsp;*/
}

</pre></font>

<div class="p"><!----></div>
 
<br /><a 
name="IndexIn+\container123"></a> <font size="+1"><b>IndexIn</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*IndexIn)(const&nbsp;ValArray&nbsp;*source,ValArraySize_t&nbsp;*indices);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns an array built from indexing the first argument (&#223;ource") with the array of indexes &#239;ndices" that should be an array of 
size_t elements. The number of elements of the resulting array is equal to the number of elements of the indexes array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INDEX

 Any given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>
A new array or&nbsp;NULL if an error occurs. No partial results are returned. If any index is out of bounds the whole operation fails.

<div class="p"><!----></div>
 
<br /><a 
name="IndexOf+\container123"></a> <font size="+1"><b>IndexOf</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*IndexOf)(const&nbsp;ValArray&nbsp;*l,ElementType&nbsp;data,size_t&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Searches for an element in the array. If found its zero based index is returned in the pointer "result". Otherwise the result of the search is 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
. The &#235;xtraArgs" argument will be passed to the comparison function, that is used to compare elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given array pointer or the element given are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if the element is found, or a negative number containing an error code or the negative constant 
<font size="-2">CONTAINER_ERROR_NOTFOUND</font>
.

<div class="p"><!----></div>
 
<br /><a 
name="InitializeWith+\container123"></a> <font size="+1"><b>InitializeWith</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ValArray&nbsp;*(*InitializeWith)(size_t&nbsp;n,&nbsp;ElementType&nbsp;*data);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates and initializes a new ValArray with the given data table. The first argument is the number of items in the table and the second
is a pointer to a storage area that should contain at least the given number of items. 
The data is copied into the new array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new array or&nbsp;NULL if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="InsertAt+\container123"></a> <font size="+1"><b>InsertAt</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(ValArray&nbsp;*src,size_t&nbsp;idx,ElementType&nbsp;newData);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Inserts the new element. The new element will have the given index, that can go from zero to the vector count inclusive, i.e. one more than the number of elements in the vector.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INDEX

 The given position is out of bounds.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to complete the operation.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation succeeded, or a negative error code if the operation failed.
 
<div class="p"><!----></div>
<br /><a 
name="Inverse+\container123"></a> <font size="+1"><b>Inverse</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Inverse)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes for each element the inverse (1/element) and stores it in-place. 
If a slice definition is active only their elements will be used. If any of the elements is
zero the computation stops and the result is an error code.

<div class="p"><!----></div>
This function is defined for the floating point types only<a href="#tthFtNtADJ" name="tthFrefADJ"><sup>39</sup></a>.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_DIVISION_BY_ZERO

 One of the elements is zero.

<div class="p"><!----></div>
<b>Returns:</b>A positive number if successful, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Max+\container123"></a> <font size="+1"><b>Max</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Max)(const&nbsp;ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the biggest element in the container. If the container is empty it returns the smallest element that can be stored into the array's data
type<a href="#tthFtNtAEA" name="tthFrefAEA"><sup>40</sup></a>.

<div class="p"><!----></div>
 
<br /><a 
name="Memset+\container123"></a> <font size="+1"><b>Memset</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Memset)(ValArray&nbsp;*dst,ElementType&nbsp;data,size_t&nbsp;length);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Assigns to each element of the argument the given data. Conceptually this operation is: <font size="+1"><tt>dst = data</tt></font>. If a slice is active in the destination 
array only the elements described by the slice are modified. If the given length is bigger than the number of elements in the array, the array
will be expanded to accomodate the new elements.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is not enough ressources to expand the array to the desired length.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Min+\container123"></a> <font size="+1"><b>Min</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;ElementType&nbsp;(*Min)(const&nbsp;ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the smallest element in the container. If the container is empty it returns the biggest element that can be stored into the array's data
type<a href="#tthFtNtAEB" name="tthFrefAEB"><sup>41</sup></a>.

<div class="p"><!----></div>
 
<br /><a 
name="Mismatch+\container123"></a> <font size="+1"><b>Mismatch</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Mismatch)(const&nbsp;ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*a2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*mismatch);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the index of the first element that is different when comparing both arrays in the passed pointer <i>mismatch</i>. If one array is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison stops when the first difference is spotted.

<div class="p"><!----></div>
If there are slice definitions in one or both arrays, they will be used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
If a mismatch is found the result is greater than zero and the <i>mismatch</i> argument will contain the index of the first element that compared
unequal. This will be always the case for arrays of different length.

<div class="p"><!----></div>
If both arrays are the same length and no differences are found the result is zero and the value pointed to by the
<i>mismatch</i> argument is one more than the length of the arrays.

<div class="p"><!----></div>
If an error occurs, a negative error code is returned. The <i>mismatch</i> argument contains zero.

<div class="p"><!----></div>
 
<br /><a 
name="MultiplyWith+\container123"></a> <font size="+1"><b>MultiplyWith</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWith)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Multiplies each element of the right argument with the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left *= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="MultiplyWithScalar+\container123"></a> <font size="+1"><b>MultiplyWithScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*MultiplyWithScalar)(ValArray&nbsp;*left,&nbsp;ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Multiplies each element of the left argument with the right argument. Conceptually this operation is: <font size="+1"><tt>left *= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None. Some implementations could detect a bad pointer.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Not+\container123"></a> <font size="+1"><b>Not</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Not)(ValArray&nbsp;*v);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise Not operation of each element of the argument. Conceptually this operation is: <font size="+1"><tt>v&nbsp;=&nbsp;~v</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning. If a slice is active, only its elements will be affected.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Or+\container123"></a> <font size="+1"><b>Or</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise or operation between each element of the right argument with the corresponding element of the left argument. Conceptually this
operation is: <font size="+1"><tt>left&nbsp;|=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning. This operation will only affect the elements in the active slice, if a slice is active.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="OrScalar+\container123"></a> <font size="+1"><b>OrScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Or)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise or operation between each element of the left argument with the right argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;|=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="PopBack+\container123"></a> <font size="+1"><b>PopBack</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*PopBack)(ValArray&nbsp;*AL,ElementType&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies the last element into the given result buffer and deletes the element from the container. If the result buffer is&nbsp;NULL , no copy is performed.
If a slice specification is active, the element deleted will be the last element of the slice, and the length of the slice will be reduced by one.
If the slice becomes empty, the slice specifications are reset.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>
A negative value if an error occurs, zero if the array is empty or greater than zero if the operation succeeded.

<div class="p"><!----></div>
 
<br /><a 
name="Product+\container123"></a> <font size="+1"><b>Product</b></font> <hr />


<font size=+1><pre>

ElementType&nbsp;(*Product)(ValArray&nbsp;*src);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Calculates the product of all the elements of the given vector. If a slice definition is active only the slice elements are considered.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None are mandatory but implementations should check for overflow when possible.

<div class="p"><!----></div>
<b>Returns:</b>The product of the elements.

<div class="p"><!----></div>
 
<br /><a 
name="Reverse+\container123"></a> <font size="+1"><b>Reverse</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Reverse)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reverses the order of the elements of the given array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Not enough memory for intermediate storage available

<div class="p"><!----></div>
<b>Returns:</b>
A negative error code if an error occurs, or a positive value if the operation succeeded.

<div class="p"><!----></div>
 
<br /><a 
name="ResetSlice+\container123"></a> <font size="+1"><b>ResetSlice</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ResetSlice)(ValArray&nbsp;*array);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Eliminates any slices specifications from the given array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>If a slice specification was removed returns 1, if no slice was defined in the given array returns zero.

<div class="p"><!----></div>
 
<br /><a 
name="RotateLeft+\container123"></a> <font size="+1"><b>RotateLeft</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateLeft)(ValArray&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates left the array by the indicated amount. The first n elements will be written to the end of
the array, and the rest will be shifted left to fill the empty n places.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValArrayInt&nbsp;*&nbsp;vInt&nbsp;=&nbsp;iValArrayInt.CreateSequence(24,0,1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Original&nbsp;array:&nbsp;\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Rotating&nbsp;left&nbsp;by&nbsp;4\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.RotateLeft(vInt,4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Rotating&nbsp;left&nbsp;by&nbsp;48\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.RotateLeft(vInt,48);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Rotating&nbsp;left&nbsp;by&nbsp;55\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.RotateLeft(vInt,55);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(vInt,stdout,"%d&nbsp;");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Finalize(vInt);
}

OUTPUT
Original&nbsp;array:&nbsp;
0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;
Rotating&nbsp;left&nbsp;by&nbsp;4
4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;
Rotating&nbsp;left&nbsp;by&nbsp;48
4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;
Rotating&nbsp;left&nbsp;by&nbsp;55
11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;20&nbsp;21&nbsp;22&nbsp;23&nbsp;0&nbsp;1&nbsp;2&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;7&nbsp;8&nbsp;9&nbsp;10

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="RotateRight+\container123"></a> <font size="+1"><b>RotateRight</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*RotateRight)(ValArray&nbsp;*src,size_t&nbsp;n);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Rotates right the array by the indicated amount. The last n elements will be written to the start of
the array, and the rest will be shifted right.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>A positive number if something was moved, zero otherwise (the input was zero or a 
modulo of the array size).

<div class="p"><!----></div>
 
<br /><a 
name="Save+\container123"></a> <font size="+1"><b>Save</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Save)(const&nbsp;ValArray&nbsp;*AL,&nbsp;FILE&nbsp;*out);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
The contents of the given ValArray are saved into the given stream. This function is a simplified version of the Save function in the Vector container
since it doesn't feature a save function. Since ValArrays hold primitive types they are saved in a single write into the output stream.
The output stream must be opened for writing and must be in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
EOF A disk input/output error occurred.

<div class="p"><!----></div>

<b>Returns:</b>
A positive value if the operation completed, a negative value or EOF otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="SetCompareFunction+\container123"></a> <font size="+1"><b>SetCompareFunction</b></font> <hr />


<font size=+1><pre>

CompareFunction&nbsp;(*SetCompareFunction)(ValArray&nbsp;*AL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;f);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
This function does nothing and returns always&nbsp;NULL . It is retained for compatibility purposes with other containers.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None

<div class="p"><!----></div>
<b>Returns:</b>Always&nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="Select+\container123"></a> <font size="+1"><b>Select</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*Select)(ValArray&nbsp;*va,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is zero are eliminated, those with a mask
value different of zero are retained. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;"containers.h"
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;Mask&nbsp;*m&nbsp;=&nbsp;iMask.Create(18);
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayInt&nbsp;*va&nbsp;=&nbsp;iValArrayInt.CreateSequence(18,0,1);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;18;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iMask.Set(m,i,(i&amp;1)&nbsp;?&nbsp;0&nbsp;:&nbsp;1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(va,stdout,"%3d&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Select(va,m);
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.Fprintf(va,stdout,"%3d&nbsp;");
}
OUTPUT:
0&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15&nbsp;&nbsp;16&nbsp;&nbsp;17
0&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;10&nbsp;&nbsp;12&nbsp;&nbsp;14&nbsp;&nbsp;16&nbsp;

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="SelectCopy+\container123"></a> <font size="+1"><b>SelectCopy</b></font> <hr />


<font size=+1><pre>

ValArray&nbsp;*(*SelectCopy)(ValArray&nbsp;*va,Mask&nbsp;*m);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Using the given mask, the elements where the corresponding mask element is different from zero are copied into a new array, those with a mask
value different of zero are ignored. The mask must have the same length as the array.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The mask and the array are of different length.

<div class="p"><!----></div>
<b>Returns:</b>A positive value for success, or a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="SetSlice+\container123"></a> <font size="+1"><b>SetSlice</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SetSlice)(ValArray&nbsp;*s,size_t&nbsp;start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;length,size_t&nbsp;increment);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Defines a slice for the given array. The slice starts at the given index, and has <font size="+1"><tt>length</tt></font> elements. Between each element and the next
there are <font size="+1"><tt>increment</tt></font> positions. All operations done with the array will be done to the elements defined by the slice.

<div class="p"><!----></div>
Constraints:

<ul>
<li> The <font size="+1"><tt>start</tt></font> argument can't be greater or equal than the number of elements in the array.
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>increment</tt></font> argument must be greater than zero
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>length</tt></font> argument must be greater than zero. If it is greater than the number of elements in the array or greater than the number of 
elements that would fit with the given increment and start it will be adjusted accordingly.
<div class="p"><!----></div>
</li>
</ul>
If any slice specification was defined for the given array it will be replaced by the new one.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One of the arguments doesn't meet the above constraints.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

. There is no memory to allocate the slice specifications.

<div class="p"><!----></div>
<b>Returns:</b>
Positive number if successful; negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Size+\container123"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total number of elements stored in the array. If there is a slice definition it will <font size="+1"><tt>not</tt></font> be used. To know the size of a slice use the<font size="+1"><tt>GetSlice</tt></font> API.

<div class="p"><!----></div>
 
<br /><a 
name="Sizeof+\container123"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the total size in bytes of the ValArray, including the header, and all data stored in it. If the argument is&nbsp;NULL , the size of the header only is returned.

<div class="p"><!----></div>
<b>Returns:</b>
The number of bytes used by the vector or the size of the ValArray header if the argument is&nbsp;NULL .

<div class="p"><!----></div>
 
<br /><a 
name="Sort+\container123"></a> <font size="+1"><b>Sort</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Sort)(ValArray&nbsp;*AL);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sorts the given array. The order of the original array is destroyed. You should copy it if you want to preserve it. If a slice specification is active
only the elements in the slice will be sorted.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 Temporary storage for the operation is absent.

<div class="p"><!----></div>
<b>Returns:</b>
A positive number if sorting succeeded, a negative error code if not.

<div class="p"><!----></div>
 
<br /><a 
name="SubtractFrom+\container123"></a> <font size="+1"><b>SubtractFrom</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFrom)(ValArray&nbsp;*left,const&nbsp;ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Subtracts each element of the right argument from the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left -= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SubtractFromScalar+\container123"></a> <font size="+1"><b>SubtractFromScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractFromScalar)(ElementType&nbsp;left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Subtracts from the left argument the right argument. Conceptually this operation is: <font size="+1"><tt>right = left - right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SubtractScalarFrom+\container123"></a> <font size="+1"><b>SubtractScalarFrom</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SubtractScalarFrom)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Subtracts from the left argument the right argument. Conceptually this operation is: <font size="+1"><tt>left -= right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SumTo+\container123"></a> <font size="+1"><b>SumTo</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SumTo)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds each element of the right argument to the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left += right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="SumToScalar+\container123"></a> <font size="+1"><b>SumToScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SumTo)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds each element of the left argument the right argument. Conceptually this operation is: <font size="+1"><tt>left += right</tt></font>. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
No errors.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="Xor+\container123"></a> <font size="+1"><b>Xor</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Xor)(ValArray&nbsp;*left,ValArray&nbsp;*right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise Xor operation between each element of the right argument with the corresponding element of the left argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;^=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_INCOMPATIBLE

 The arrays have a different number of elements.

<div class="p"><!----></div>
<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
 
<br /><a 
name="XorScalar+\container123"></a> <font size="+1"><b>XorScalar</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*XorScalar)(ValArray&nbsp;*left,ElementType&nbsp;right);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Performs a bitwise Xor operation between each element of the left argument with the right argument. Conceptually this operation is: <font size="+1"><tt>left&nbsp;^=&nbsp;right</tt></font>. This operation is allowed only between unsigned integer types. For floating point data this operation has no 
meaning.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

<b>Returns:</b>A positive number for success, or a negative error code.

<div class="p"><!----></div>
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;Buffers</h2>
<a 
name="Buffers130"></a>
The buffers interface is greatly simplified compared to the interface of a general container. 
The usage of a buffer as an intermediate storage means there is no sense in including all  the functionality of a container. The library provides two 
types:

<ol type="1">
<li> Stream buffers provide linear storage that grows automatically as needed.
<div class="p"><!----></div>
</li>

<li> Circular buffers store the last n items of a stream
<div class="p"><!----></div>
</li>
</ol>
Other languages provide similar features:

<ul>
<li> The Java language provides a typed buffer functionality. This buffers are not resizable, have a cursor and other more sophisticated operations 
than the buffers proposed here like slicing and compacting.Their place in the Java class hierarchy is: Object &#8594; Native I/O &#8594; 
ByteBuffer. There are methods for viewing the buffer as float, doubles, etc.
<div class="p"><!----></div>
</li>

<li> The C# language provides also a typed buffer class of the primitive types (char, float, int, etc). It is called System.Buffer and provides a few 
methods for determining its length and read/write a single byte. The language itself doesn't provide any circular buffers class but several 
implementations are available in the net. The same situation applies for Java.
<div class="p"><!----></div>
</li>

<li> The C++ STL doesn't provide circular buffers directly but the <font size="+1"><tt>boost</tt></font> C++ library does provide an implementation. See:

<div class="p"><!----></div>
<font size="-1">http://www.boost.org/doc/libs/1_48_0/libs/circular_buffer/doc/circular_buffer.html</font>

<div class="p"><!----></div>
In the usual simplicity of that language, the class has around 60 entry points, including specialized templates for some functions. Around 14 auxiliary 
types are involved and the documentation for this component goes for around 50 pages. That is the exact opposite of this proposal.
<div class="p"><!----></div>
</li>
</ul>
The design objective in this library is to keep buffers small and, while providing functionality, reduce the interface to a minimum. Compacting is not 
feasible in C due to the wide use of pointers. If there is a pointer to the data in the buffer, moving it would invalidate the pointer making for hard 
to debug crashes <a href="#tthFtNtAEC" name="tthFrefAEC"><sup>42</sup></a>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc13.1">
13.1</a>&nbsp;&nbsp;Stream buffers</h3>
<img src="StreamBuffer.png" alt="Figure">
<div class="p"><!----></div>
This objects are designed to store sequentially arbitrary data, resizing themselves as necessary. There is a cursor, a pointer that indicates where 
the next data item will be written. You can move the cursor, overwriting old data, or leaving holes in the buffer structure
<a href="#tthFtNtAED" name="tthFrefAED"><sup>43</sup></a>
.  

<div class="p"><!----></div>
      <h4><a name="tth_sEc13.1.1">
13.1.1</a>&nbsp;&nbsp;The interface</h4>
 
<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagStreamBufferInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*Create)(size_t&nbsp;startsize);
&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsize,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*CreateFromFile)(char&nbsp;*FileName);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Read)(StreamBuffer&nbsp;*b,&nbsp;void&nbsp;*data,&nbsp;size_t&nbsp;siz);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Write)(StreamBuffer&nbsp;*b,void&nbsp;*data,&nbsp;size_t&nbsp;siz);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*SetPosition)(StreamBuffer&nbsp;*b,size_t&nbsp;pos);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetPosition)(const&nbsp;StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*(*GetData)(const&nbsp;StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(StreamBuffer&nbsp;*b,size_t&nbsp;newSize);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(StreamBuffer&nbsp;*b);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(StreamBuffer&nbsp;*b);
}&nbsp;StreamBufferInterface;

</pre></font>

      <h4><a name="tth_sEc13.1.2">
13.1.2</a>&nbsp;&nbsp;The API</h4>
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container131"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the cursor at position zero and zeroes the whole buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful, a negative error code otherwise.

<div class="p"><!----></div>
 
<br /><a 
name="Create+\container131"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*Create)(size_t&nbsp;startsize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new buffer with the given start size. If the size is zero it will use a default start value. The allocator used is the current memory manager.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. There is no more memory to create the buffer.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a newly created buffer or&nbsp;NULL if there is no more memory left.

<div class="p"><!----></div>
 
<br /><a 
name="CreateFromFile+\container131"></a> <font size="+1"><b>CreateFromFile</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*(*CreateFromFile)(char&nbsp;*FileName);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new buffer with the contents of the given file. The allocator used is the current memory manager. The file is read in binary mode.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. There is no more memory to create the buffer.

<div class="p"><!----></div>
CONTAINER_ERROR_NOENT

 The file given can't be found (or it exists but the current user has no read permission).

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a newly created buffer or&nbsp;NULL if there is no more memory left or the file can't be opened.
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container131"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

StreamBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;startsize,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates a new buffer using the given allocator and start size. If the start size is zero a default value is used.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

 There is no more memory to complete the operation.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the new buffer or&nbsp;NULL if there is no memory left.
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container131"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Releases all memory used by the buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful or anegative error code.
 
<div class="p"><!----></div>
<br /><a 
name="GetData+\container131"></a> <font size="+1"><b>GetData</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*(*GetData)(const&nbsp;StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns a pointer to the data stored in the buffer. The data is read-only (const).

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is&nbsp;NULL 


<div class="p"><!----></div>
 <b>Invariants:</b>
The given buffer is not modified. The returned pointer should not be modified.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to the buffer's data or NULL, if an error occurs.

<div class="p"><!----></div>
 
<br /><a 
name="GetPosition+\container131"></a> <font size="+1"><b>GetPosition</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*GetPosition)(const&nbsp;StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Returns the current cursor position.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The stream buffer pointer is&nbsp;NULL 


<div class="p"><!----></div>
 <b>Invariants:</b>
The stream buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The cursor position or zero if there is an error. Note that zero is also a valid cursor position.<a href="#tthFtNtAEE" name="tthFrefAEE"><sup>44</sup></a>

 
<div class="p"><!----></div>
<br /><a 
name="Read+\container131"></a> <font size="+1"><b>Read</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Read)(StreamBuffer&nbsp;*b,&nbsp;void&nbsp;*data,&nbsp;size_t&nbsp;siz);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reads <i>siz</i> bytes from the given buffer, starting from the position of the cursor. If the buffer finishes before <i>siz</i> characters are
read, reading stops, and less characters than requested are returned. It is assumed that the <i>data</i> buffer contains at least <i>siz</i> 
characters.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 Either the stream buffer, the data buffer are&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
None. The given buffer is modified since the cursor is updated to the new position. The given buffer is modified since the data is copied 
into it.

<div class="p"><!----></div>
<b>Returns:</b>The number of characters copied or zero if there is an error. Note that if the number of requested characters is zero, this function
will also return zero.
 
<div class="p"><!----></div>
<br /><a 
name="Resize+\container131"></a> <font size="+1"><b>Resize</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;int&nbsp;(*Resize)(StreamBuffer&nbsp;*b,size_t&nbsp;newSize);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resizes the buffer to the requested size. The new size can be bigger or smaller than the current size. All pointers to the data in the buffer 
are invalid after this operation.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The stream buffer pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEMORY

 There is not enough memory to satisfy the request.

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, zero if the requested size is equal to the current size, or a positive number
if the request was satisfied.
 
<div class="p"><!----></div>
<br /><a 
name="SetPosition+\container131"></a> <font size="+1"><b>SetPosition</b></font> <hr />


<font size=+1><pre>

int&nbsp;(*SetPosition)(StreamBuffer&nbsp;*b,&nbsp;size_t&nbsp;pos);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Sets the cursor at the given position. If the position is bigger than the size of the buffer the cursor is moved to the end of the buffer.

<div class="p"><!----></div>

  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The given buffer pointer is&nbsp;NULL 

<div class="p"><!----></div>
<b>Returns:</b>A positive value if successful, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="Size+\container131"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Size)(const&nbsp;StreamBuffer&nbsp;*b);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> Returns the allocated size of the buffer. If the buffer pointer is&nbsp;NULL returns the size of the buffer header.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>
None


<div class="p"><!----></div>
 <b>Invariants:</b>
The given buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The size of the buffer.
 
<div class="p"><!----></div>
<br /><a 
name="Write+\container131"></a> <font size="+1"><b>Write</b></font> <hr />


<font size=+1><pre>

&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Write)(StreamBuffer&nbsp;*b,void&nbsp;*data,&nbsp;size_t&nbsp;siz);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Writes into the buffer <i>siz</i> characters from the passed pointer <i>data</i>. The characters are written starting at the cursor
position. If the buffer is too small to hold the data, it will be enlarged using its allocator. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_NOMEMORY

. There is no more memory to enlarge the buffer.

<div class="p"><!----></div>
CONTAINER_ERROR_BADARG

 The stream buffer pointer or the data pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>The number of characters written.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StreamBuffer&nbsp;*sb&nbsp;=&nbsp;iStreamBuffer.Create(10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[20],*p;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;10;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(buf,"item&nbsp;%d",i+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.Write(sb,buf,1+strlen(buf));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[0]=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.Write(sb,&amp;buf,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Buffer&nbsp;size&nbsp;is:&nbsp;%d,&nbsp;position&nbsp;is&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)iStreamBuffer.Size(sb),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(int)&nbsp;iStreamBuffer.GetPosition(sb));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.SetPosition(sb,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;iStreamBuffer.GetData(sb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*p)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;+=&nbsp;1&nbsp;+&nbsp;strlen(p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iStreamBuffer.Finalize(sb);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
OUTPUT:
Buffer&nbsp;size&nbsp;is:&nbsp;82,&nbsp;position&nbsp;is&nbsp;72
item&nbsp;1
item&nbsp;2
item&nbsp;3
item&nbsp;4
item&nbsp;5
item&nbsp;6
item&nbsp;7
item&nbsp;8
item&nbsp;9
item&nbsp;10

</pre></font>
This example does the following:

<ul>
<li> Creates a stream buffer. It assumes success and does not test the return value of the creation function. The buffer is dimensioned too small 
for the data it will contain so it has to resize several times.
<div class="p"><!----></div>
</li>

<li> Prepares a string buffer with sprintf and writes the resulting string including its terminating zero in the stream buffer. Note that
zeroes have no special significance in buffers. It loops ten times doing this operation.
<div class="p"><!----></div>
</li>

<li> It ends the buffer with a terminating double zero.
<div class="p"><!----></div>
</li>

<li> It prints the buffer size and the number of characters it has written. Note that they are not the same. The buffer has been resized 
several times, and at each time the new capacity is determined by an internal algorithm. Since we did not move the cursor the position of the
cursor give us the number of characters written.
<div class="p"><!----></div>
</li>

<li> It obtains a pointer to the data in the buffer
<div class="p"><!----></div>
</li>

<li> It prints all the strings in the buffer to standard output. Each character string from 1 to 9 is 7 bytes long, including its terminating zero.
The tenth string is 9 bytes, also including the terminating zero. We have then: (7*9)+9 = 72.
<div class="p"><!----></div>
</li>

<li> It destroys the buffer.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc13.2">
13.2</a>&nbsp;&nbsp;Circular buffers</h3>
<img src="Circular.png" alt="Figure">
<div class="p"><!----></div>
This objects are designed to store the last n items of a stream. When they are full, the new items are stored in the same place as the oldest
item <a href="#tthFtNtAEF" name="tthFrefAEF"><sup>45</sup></a>. 

      <h4><a name="tth_sEc13.2.1">
13.2.1</a>&nbsp;&nbsp;The interface: iCircularBuffer</h4>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;tagCircularBufferInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(&nbsp;CircularBuffer&nbsp;*&nbsp;b,&nbsp;const&nbsp;void&nbsp;*data_element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(CircularBuffer&nbsp;*cb);
&nbsp;&nbsp;&nbsp;&nbsp;CircularBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;sizElement,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;sizeBuffer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;ContainerMemoryManager&nbsp;*allocator);
&nbsp;&nbsp;&nbsp;&nbsp;CircularBuffer&nbsp;*(*Create)(size_t&nbsp;sizElement,size_t&nbsp;sizeBuffer);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(CircularBuffer&nbsp;*cb);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PopFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*PeekFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;CircularBuffer&nbsp;*cb);
&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;SetDestructor(CircularBuffer&nbsp;*cb,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DestructorFunction&nbsp;NewFn);
}&nbsp;CircularBufferInterface;

</pre></font>

      <h4><a name="tth_sEc13.2.2">
13.2.2</a>&nbsp;&nbsp;The API</h4>
 
<div class="p"><!----></div>
<br /><a 
name="Add+\container132"></a> <font size="+1"><b>Add</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*Add)(&nbsp;CircularBuffer&nbsp;*&nbsp;b,&nbsp;const&nbsp;void&nbsp;*data_element);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Adds the given data element to the circular buffer. If the buffer is full, the oldest element's place will be overwritten with the new data
and the container remains full with the same number of elements. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The given data element is not modified but copied into the container.

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs. If the container is full zero is returned. If a new element was added a positive number is returned.
 
<div class="p"><!----></div>
<br /><a 
name="Clear+\container132"></a> <font size="+1"><b>Clear</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*Clear)(CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Resets the number of elements inside the container to empty without freeeing the memory used by the buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer b is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, or a positive number when the container is reset.
 
<div class="p"><!----></div>
<br /><a 
name="CreateWithAllocator+\container132"></a> <font size="+1"><b>CreateWithAllocator</b></font> <hr />


<font size=+1><pre>

	CircularBuffer&nbsp;*(*CreateWithAllocator)(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;sizeBuffer,&nbsp;ContainerMemoryManager&nbsp;*allocator);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an empty circular buffer that can hold at most sizeBuffer elements, each element being of size ElementSize. Uses the given allocator
to allocate memory.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both sizes are zero, or the allocator pointer is&nbsp;NULL .

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEM

 There is no memory left.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new circular buffer or&nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Create+\container132"></a> <font size="+1"><b>Create</b></font> <hr />


<font size=+1><pre>

	CircularBuffer&nbsp;*(*Create)(size_t&nbsp;ElementSize,&nbsp;size_t&nbsp;sizeBuffer);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Creates an empty circular buffer that can hold at most sizeBuffer elements, each element being of size ElementSize. Uses the CurrentMemoryManager
to allocate memory.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 One or both arguments are zero.

<div class="p"><!----></div>
CONTAINER_ERROR_NOMEM

 There is no memory left.

<div class="p"><!----></div>
<b>Returns:</b>A pointer to a new circular buffer or&nbsp;NULL if an error occurs.
 
<div class="p"><!----></div>
<br /><a 
name="Finalize+\container132"></a> <font size="+1"><b>Finalize</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*Finalize)(CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Reclaims all memory used by the given buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A positive value if the container is destroyed, a negative error code otherwise.
 
<div class="p"><!----></div>
<br /><a 
name="PeekFront+\container132"></a> <font size="+1"><b>PeekFront</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*PeekFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies one item from the front of the circular buffer into the given buffer without removing the item from the container. 

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer or the result buffer are&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, zero if the buffer was empty, or a positive number if an item was copied.

<div class="p"><!----></div>
 
<br /><a 
name="PopFront+\container132"></a> <font size="+1"><b>PopFront</b></font> <hr />


<font size=+1><pre>

	int&nbsp;(*PopFront)(CircularBuffer&nbsp;*b,void&nbsp;*result);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Copies one item from the front of the circular buffer into the given buffer and removes the item from the container. If the result pointer is&nbsp;NULL 
the item is removed but nothing is copied.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer is&nbsp;NULL .

<div class="p"><!----></div>
<b>Returns:</b>A negative error code if an error occurs, zero if the buffer was empty, or a positive number if an item was removed.


<div class="p"><!----></div>
<b>Example:</b>

<font size=+1><pre>

#include&nbsp;&lt;containers.h&#62;
int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;CircularBuffer&nbsp;*cb&nbsp;=&nbsp;iCircularBuffer.Create(sizeof(int),10);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,integer;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;20;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iCircularBuffer.Add(cb,&amp;i);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("There&nbsp;are&nbsp;%d&nbsp;elements\n",iCircularBuffer.Size(cb));
&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;container&nbsp;uses&nbsp;%d&nbsp;bytes\n",iCircularBuffer.Sizeof(cb));
&nbsp;&nbsp;&nbsp;&nbsp;printf("The&nbsp;size&nbsp;of&nbsp;the&nbsp;header&nbsp;is&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iCircularBuffer.Sizeof(NULL));
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Print&nbsp;all&nbsp;elements&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(iCircularBuffer.PopFront(cb,&amp;integer)&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;",integer);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
OUTPUT:
There&nbsp;are&nbsp;10&nbsp;elements
The&nbsp;container&nbsp;uses&nbsp;88&nbsp;bytes
The&nbsp;size&nbsp;of&nbsp;the&nbsp;header&nbsp;is&nbsp;48
10&nbsp;11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19

</pre></font>
 
<div class="p"><!----></div>
<br /><a 
name="Size+\container132"></a> <font size="+1"><b>Size</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Size)(const&nbsp;CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of items in the given circular buffer.

<div class="p"><!----></div>
  <b>Errors:</b>
<div class="p"><!----></div>

CONTAINER_ERROR_BADARG

 The buffer pointer is&nbsp;NULL .


<div class="p"><!----></div>
 <b>Invariants:</b>
The given buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The number of items in the buffer.
 
<div class="p"><!----></div>
<br /><a 
name="Sizeof+\container132"></a> <font size="+1"><b>Sizeof</b></font> <hr />


<font size=+1><pre>

size_t&nbsp;(*Sizeof)(const&nbsp;CircularBuffer&nbsp;*cb);

</pre></font>

<div class="p"><!----></div>
  <b>Description:</b> 
Computes the number of bytes used by given circular buffer. If the pointer is&nbsp;NULL returns the size of the circular buffer header structure.


<div class="p"><!----></div>
 <b>Invariants:</b>
the given buffer is not modified.

<div class="p"><!----></div>
<b>Returns:</b>The number of bytes used by the buffer.
<BR CLEAR=LEFT><BR><BR>

 <h2><a name="tth_sEc14">
14</a>&nbsp;&nbsp;The generic interfaces</h2>
This interface allows the user to use containers in a generic way, ignoring its specific type.
Note that there is no "GenericContainer" object; you can't create any generic container. Once a specific container is created, it can be used as a generic container at any time since all containers comply with the generic interface. This interface just dispatches internally to the actual container and therefore incurs in a slight performance cost.
<a href="#tthFtNtAEG" name="tthFrefAEG"><sup>46</sup></a>

<div class="p"><!----></div>
Conceptually, the generic interfaces represent a base class (GenericContainer) and two derived classes: Sequential and Associative containers.
It would be possible to derive more classes, for instance a numeric container class that could be implemented in the future, This is left open for future releases of this specification.
<a href="#tthFtNtAEH" name="tthFrefAEH"><sup>47</sup></a>

     <h3><a name="tth_sEc14.1">
14.1</a>&nbsp;&nbsp;Generic containers</h3>
The general generic interface that encloses associative and sequential containers is as follows:
<a 
name="iGenericContainer141"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;GenericContainer&nbsp;GenericContainer;
typedef&nbsp;struct&nbsp;tagGenericContainerInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*GetFlags)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*SetFlags)(GenericContainer&nbsp;*Gen,unsigned&nbsp;flags);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Clear)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(GenericContainer&nbsp;*Gen,void&nbsp;*Value);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(GenericContainer&nbsp;*Gen,void&nbsp;*objectToDelete);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Finalize)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;(*Apply)(GenericContainer&nbsp;*Gen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Applyfn)(void&nbsp;*,void&nbsp;*&nbsp;arg),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Equal)(GenericContainer&nbsp;*Gen1,GenericContainer&nbsp;*Gen2);
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainer&nbsp;*(*Copy)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;(*SetErrorFunction)(GenericContainer&nbsp;*Gen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Sizeof)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*(*NewIterator)(GenericContainer&nbsp;*Gen);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*deleteIterator)(Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Save)(GenericContainer&nbsp;*Gen,FILE&nbsp;*stream,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainer&nbsp;*(*Load)(FILE&nbsp;*stream,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ReadFunction&nbsp;readFn,void&nbsp;*arg);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;GetElementSize(GenericContainer&nbsp;*Gen);
}&nbsp;GenericContainerInterface;
extern&nbsp;GenericContainerInterface&nbsp;iGenericContainer;

</pre></font>
This functions return the obvious results already described in the documentation of their container-specific counterparts and not repeated here. We only note the absence of a creation function, or any means to add an object.
<a href="#tthFtNtAEI" name="tthFrefAEI"><sup>48</sup></a>

<div class="p"><!----></div>
Based on the generic interface, we have generic sequential and associative interfaces. They contain generic functions for adding and removing objects.

     <h3><a name="tth_sEc14.2">
14.2</a>&nbsp;&nbsp;Sequential containers</h3>
These containers include all the functions of the GenericContainer interface, adding functions to use any sequential container as a stack, and functions for managing object replacement or addition.
<a 
name="iSequentiaContainer142"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;SequentialContainer&nbsp;SequentialContainer;
typedef&nbsp;struct&nbsp;tagSequentialContainerInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainerInterface&nbsp;Generic;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(SequentialContainer&nbsp;*SC,void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(SequentialContainer&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Push)(SequentialContainer&nbsp;*Gen,void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Pop)(SequentialContainer&nbsp;*Gen,void&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*InsertAt)(SequentialContainer&nbsp;*SC,size_t&nbsp;idx,&nbsp;void&nbsp;*newval);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*EraseAt)(SequentialContainer&nbsp;*SC,size_t&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*ReplaceAt)(SequentialContainer&nbsp;*SC,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx,&nbsp;void&nbsp;*element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*IndexOf)(SequentialContainer&nbsp;*SC,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ElementToFind,size_t&nbsp;*result);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Append)(SequentialContainer&nbsp;*SC1,SequentialContainer&nbsp;*SC2);
}&nbsp;SequentialContainerInterface;
extern&nbsp;SequentialContainerInterface&nbsp;iSequentialContainer;

</pre></font>

     <h3><a name="tth_sEc14.3">
14.3</a>&nbsp;&nbsp;Associative containers</h3>
These containers include all the functions of the GenericContainer interfaces and add functions for inserting and removing objects.
<a 
name="iAssociativeContainer143"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;AssociativeContainer&nbsp;AssociativeContainer;
typedef&nbsp;struct&nbsp;tagAssociativeContainerInterface&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainerInterface&nbsp;Generic;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Add)(SequentialContainer&nbsp;*SC,void&nbsp;*key,void&nbsp;*Element);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetElement)(AssociativeContainer&nbsp;*SC,void&nbsp;*Key);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Replace)(AssociativeContainer&nbsp;*SC,&nbsp;void&nbsp;*Key,&nbsp;void&nbsp;*element);
}&nbsp;AssociativeContainerInterface;
extern&nbsp;AssociativeContainerInterface&nbsp;iAssociativeContainer;

</pre></font> 

 <h1><a name="tth_chAp6">
Chapter 6 </a><br />Enhancing the library</h1>
No design can ever cover all special cases that can arise during development. The advantage of the interface design is that you can enhance the library by subclassing functions that add functionality you need when absent.
Subclassing means in this context that you replace a function of the library with a new function written by you that either replaces completely the functionality of the library or that either before or after the library function adds some code that implements an enhancement.

<div class="p"><!----></div>
There are several ways to enhance the library in this way:

<ol type="1">
<li> Replace the function in the container interface object. This affects all containers of this type, including those that are already created. This involves simply assigning to the function you want to replace a new function pointer that points to a compatible function. You can save the old value and add some functionality, call the old function pointer to do what the library does, then you can add code that runs after the old library function has finished.
<div class="p"><!----></div>
</li>

<li> Replace the function in a copy of the functions table of a single object. This way is less intrusive than the former, since only one container is affected: the one where you modify the function table. The downside is that instead of using the simple syntax:
<div class="p"><!----></div>
 <font size="+1"><tt>iList.Add</tt></font> 
<div class="p"><!----></div>
 you have to use the container's table:
<div class="p"><!----></div>
 <font size="+1"><tt>Container-&#62;VTable-&#62;Add(...)</tt></font> 
<div class="p"><!----></div>
 This represents quite a different syntax, but this can be less of a problem if you hide it under some convenient macros <a href="#tthFtNtAEJ" name="tthFrefAEJ"><sup>49</sup></a>.

<div class="p"><!----></div>
On the up side, another advantage of this syntax is that you do not need to change your source code if you change the type of the container. If you write: 
<div class="p"><!----></div>
  <font size="+1"><tt>myContainer-&#62;Vtable-&#62;Add(myContainer,object);</tt></font>
<div class="p"><!----></div>
  this will stay the same for lists, arrays, string collections or whatever sequential container you are using. You can then change completely the type of the container just by changing the declaration.
<div class="p"><!----></div>
</li>
</ol>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Adding conversions between containers</h2>
Converting one type of container into another, or creating a new container with some or all the data of an existing one are routine operations not
specified in the core library.

<div class="p"><!----></div>
The reason is that there is a downside to the interface definitions as presented here: all functions within an interface module are declared 
<font size="+1"><tt>static</tt></font> to avoid polluting the user name space with those names. This has the consequence that interfaces are a monolithic  piece of
code that can't be splitted.

<div class="p"><!----></div>
Converting an object from type &#196;" to another of type "B" implies then that we have <b>both</b> interfaces present. If for every container
we would define a conversion into all others, the function table of each container would need all other interfaces and if a user uses just
a single container it would need to link with the <b>whole</b> library. To avoid this problem, no conversions are specified even when surely
converting a ValArrayInt into a ValArrayDouble is an operation that will be needed sooner or later.

<div class="p"><!----></div>
There are many solutions to this problem using the existing APIs:

<ol type="1">
<li> Using a simple loop:

<font size=+1><pre>
ValArrayDouble&nbsp;*CastToDouble(ValArrayInt&nbsp;*src)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iValArrayInt.Size(src);
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayDouble&nbsp;*result&nbsp;=&nbsp;iValArrayDouble.Create(siz);
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;siz;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;d&nbsp;=&nbsp;iValArrayInt.GetElement(src,i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iValArrayDouble.Add(result,d);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
This function stops at an error returning a partial result. Other error handling strategies could be to finalize the 
incomplete container and return&nbsp;NULL , or call the iError interface and then do a long jump to a recovery point, etc.
<div class="p"><!----></div>
</li>

<li> Using iterators:

<font size=+1><pre>
ValArrayDouble&nbsp;*CastToDouble(ValArrayInt&nbsp;*src)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iValArrayInt.Size(src);
&nbsp;&nbsp;&nbsp;&nbsp;ValArrayDouble&nbsp;*result&nbsp;=&nbsp;iValArrayDouble.Create(siz);
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iValArrayInt.NewIterator(src);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;*ip;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(ip&nbsp;=&nbsp;it-&#62;GetFirst(src);&nbsp;ip;ip&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iValArrayDouble.Add(result,*ip);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;iValArrayInt.DeleteIterator(it);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
<div class="p"><!----></div>
</li>

<li> Using the Apply API.
There are surely more complex requirements for conversions. For instance we could need to extract only certain parts of the input 
container. In that case
writing a special function to be called by <font size="+1"><tt>Apply</tt></font> is justified. For instance if we have an array of structures representing customers
we could want to make a string collection with the names of all of them. 

<font size=+1><pre>
//&nbsp;We&nbsp;want&nbsp;to&nbsp;extract&nbsp;the&nbsp;second&nbsp;field&nbsp;of&nbsp;this&nbsp;structure
struct&nbsp;customer&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;NumericID;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*Name;
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;double&nbsp;Balance;
};

int&nbsp;ApplyFn(void&nbsp;*data,void&nbsp;*container)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;customer&nbsp;*pData&nbsp;=&nbsp;(struct&nbsp;customer&nbsp;*)data;
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*Collection&nbsp;=&nbsp;(strCollection&nbsp;*)container;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;istrCollection.Add(Collection,pData-&#62;Name);
}&nbsp;&nbsp;

strCollection&nbsp;*GetAllNames(Vector&nbsp;*CustomerDB)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz&nbsp;=&nbsp;iVector.Size(CustomerDB);
&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*result&nbsp;=&nbsp;istrCollection.Create(siz);
&nbsp;&nbsp;&nbsp;&nbsp;iVector.Apply(CustomerDB,ApplyFn,result);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
 <h1><a name="tth_chAp7">
Chapter 7 </a><br />Applications</h1>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Unique</h2>
The main point in using the C containers library is the increase in
program abstraction. In this example we will see how the library
can be used to solve in a few lines a classroom problem.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.1">
1.0.1</a>&nbsp;&nbsp;Task description</h4>
Given a text file, print in standard output the lines that are
unique in it, i.e. filtering all duplicated lines.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.2">
1.0.2</a>&nbsp;&nbsp;Algorithm</h4>
Normally this involves keeping a sorted list/array of lines
and testing if a line is in the set or  not.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.3">
1.0.3</a>&nbsp;&nbsp;Solution using the CCL</h4>

<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;#include&nbsp;&lt;containers.h&#62;
&nbsp;&nbsp;2&nbsp;int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
&nbsp;&nbsp;3&nbsp;{
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*f;
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i=1,r;
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*dict;
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[8192];
&nbsp;&nbsp;8
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"%s&nbsp;&lt;file&nbsp;name&#62;\n",argv[0]);
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;fopen(argv[1],"r");
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(f&nbsp;==&nbsp;NULL)
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict&nbsp;=&nbsp;iDictionary.Create(0,500);
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dict&nbsp;==&nbsp;NULL)
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(fgets(buf,sizeof(buf),f))&nbsp;{
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r=&nbsp;iDictionary.Add(dict,buf,NULL);
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("[%3d]&nbsp;%s",i,buf);
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;break;
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iDictionary.Finalize(dict);
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(f);
&nbsp;28&nbsp;}

</pre></font>

      <h4><a name="tth_sEc1.0.4">
1.0.4</a>&nbsp;&nbsp;Algorithm</h4>
A hash table will be used to determine if a line is a duplicate
or not.

<div class="p"><!----></div>
      <h4><a name="tth_sEc1.0.5">
1.0.5</a>&nbsp;&nbsp;Commentary</h4>
We use the following local variables (lines 4-7):

<div class="p"><!----></div>

<table>
<tr><td align="left">Name   </td><td align="left">Usage</td></tr>
<tr><td align="left">f      </td><td align="left">Input stream bound to the file to read</td></tr>
<tr><td align="left">i      </td><td align="left">Counter for lines read</td></tr>
<tr><td align="left">r      </td><td align="left">Result of adding a line</td></tr>
<tr><td align="left">dict   </td><td align="left">Dictionary (Hash table)</td></tr>
<tr><td align="left">buf    </td><td align="left">Line buffer limited to 8K per line</td></tr></table>


<div class="p"><!----></div>
Lines 9-15 are concerned with opening the input file, with some error
checking.

<div class="p"><!----></div>
In line 16 we create a dictionary, requesting a size of zero for the
data associated with the key since we aren't storing any data, just the
key, and we suppose that the table will contain more or less 500
entries. If the file contains much more lines performance could
suffer but the algorithm would still work.

<div class="p"><!----></div>
Lines 19-25 are the main loop of the program. We read each line into
the buffer and add it to then dictionary. If the &#196;dd" API returns
a positive number the line wasn't there, if it returns zero the
line was already in the dictionary. If the result is negative it
is an error code and we stop the loop aborting the operation. Failure
can be provoked only by lack of memory.

<div class="p"><!----></div>
If the result is positive we print the line.

<div class="p"><!----></div>
Cleanup is performed in lines 26 and 27: we dispose of the dictionary
and close the file.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Paste</h2>

      <h4><a name="tth_sEc2.0.6">
2.0.6</a>&nbsp;&nbsp;Task description</h4>
Given two text files, print each line of them in the same line separated by a tab character. If files have a different number of lines
stop when the first file is exhausted.

<div class="p"><!----></div>
Note that this specifications may be different from the Unix utility of the same name.

      <h4><a name="tth_sEc2.0.7">
2.0.7</a>&nbsp;&nbsp;Solution</h4>

<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;#include&nbsp;"containers.h"
&nbsp;&nbsp;2&nbsp;int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
&nbsp;&nbsp;3&nbsp;{
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*f1,*f2;
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*line1,*line2;
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strCollection&nbsp;*file1,*file2;
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it1,*it2;
&nbsp;&nbsp;8&nbsp;
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;3)&nbsp;{
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"%s:&nbsp;file1&nbsp;file2\n",argv[0]);
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file1&nbsp;=&nbsp;istrCollection.CreateFromFile(argv[1]);
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file2&nbsp;=&nbsp;istrCollection.CreateFromFile(argv[2]);
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(file1&nbsp;!=&nbsp;NULL&nbsp;&amp;&amp;&nbsp;file2&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it1&nbsp;=&nbsp;istrCollection.NewIterator(file1);
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it2&nbsp;=&nbsp;istrCollection.NewIterator(file2);
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line2&nbsp;=&nbsp;it2-&#62;GetFirst(it2);&nbsp;line1&nbsp;=&nbsp;it1-&#62;GetFirst(it1);
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;&nbsp;line1;&nbsp;line1&nbsp;=&nbsp;it1-&#62;GetNext(it1))&nbsp;{
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(line2)&nbsp;{
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\t%s\n",line1,line2);
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line2&nbsp;=&nbsp;it2-&#62;GetNext(it2);
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;printf("%s\n",line1);
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.deleteIterator(it1);
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.deleteIterator(it2);
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Finalize(file1);
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;istrCollection.Finalize(file2);
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;32&nbsp;}

</pre></font>

      <h4><a name="tth_sEc2.0.8">
2.0.8</a>&nbsp;&nbsp;Commentary</h4>
We create two string collections containing the text (lines 13-14). Two iterators are used to get each line of both files( lines 16 17). The rest
is just cleanup: we delete the iterators (lines 26-27) and finalize the string collections (lines 29 30).

<div class="p"><!----></div>
This solution using the library is shorter and easier to write than a solution reading each line with <font size="+1"><tt>fgets()</tt></font> but needs enough memory
to hold both files in memory at the same time.

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Mapcar</h2>
<a 
name="mapcar30"></a>
The lisp function "mapcar" produces a map by applying a given function to each element of a list.

<font size=+1><pre>
(mapcar&nbsp;#'abs&nbsp;'(3&nbsp;-4&nbsp;2&nbsp;-5&nbsp;-6))&nbsp;=&#62;&nbsp;(3&nbsp;4&nbsp;2&nbsp;5&nbsp;6)&nbsp;

</pre></font>
We can reproduce this function by using &#196;pply". In the extra argument we pass a structure of two members: 

<ul>
<li> A function to call (in the above example it would be a function to calculate the absolute value)
<div class="p"><!----></div>
</li>

<li> A list container where the result would be stored
<div class="p"><!----></div>
</li>
</ul>
Our function receives then (as all functions called by Apply) two arguments, the element and a pointer to our structure. Here is a sketch of how could it be done:

<font size=+1><pre>
#include&nbsp;&lt;containers.h&#62;
struct&nbsp;MapcarArgs&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;*(*fn)(void&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*Result;
};

</pre></font>
We keep some generality by using a general prototype and definition for the function we are using. We could have defined the callback as:

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*fn)(int&nbsp;*);

</pre></font>
That prototype would have been unusable for lists that use doubles, for instance. With the current definition we can use this "MapcarArgs" structure with any other list.

<div class="p"><!----></div>
The actual function we are calling encapsulates all knowledge about the data stored in the list and the operation we perform with that data. The other parts of the software do not need to know anything about it.  It returns a static pointer to the result of the operation it performs using the given element as data that will be overwritten at each call. The intended usage is to save that result before making the next call.
It can be defined as follows:

<font size=+1><pre>
void&nbsp;*DoAbsValue(void&nbsp;*element)
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;result&nbsp;=&nbsp;*(int&nbsp;*)element;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-result;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;result;
}
/*&nbsp;This&nbsp;function&nbsp;will&nbsp;be&nbsp;directly&nbsp;called&nbsp;by&nbsp;"Apply".&nbsp;*/
static&nbsp;int&nbsp;Applyfn(void&nbsp;*element,&nbsp;struct&nbsp;MapcarArgs&nbsp;*args)
{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*result&nbsp;=&nbsp;args-&#62;fn(element);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iList.Add(args-&#62;Result,result);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}
List&nbsp;*mapcar(List&nbsp;*li,void&nbsp;*(*fn)(void&nbsp;*))
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;MapcarArgs&nbsp;args;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args.fn&nbsp;=&nbsp;fn;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args.Result&nbsp;=&nbsp;iList.Create(iList.GetElementSize(li));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(args.Result&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Apply(li,Applyfn,(void&nbsp;*)&amp;args);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;args.Result;
}

int&nbsp;main(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*li&nbsp;=&nbsp;iList.Create(sizeof(int));
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*newList;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;tab[]&nbsp;=&nbsp;{3,-4,2,-5,6};
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;5;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Add(li,&amp;tab[i]);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;newList&nbsp;=&nbsp;mapcar(li,DoAbsValue);
}

</pre></font>
Still, our version of mapcar is still specific to lists. A more general version would use a sequential container to make a mapcar function that would be able to work with any type of sequential container. 

<div class="p"><!----></div>
The basic idea is to provide an empty container of the desired result type as an extra argument to mapcar. We use an iterator instead of &#196;pply", obtaining a single compact function that will take any sequential container as input an add the result of the function to any type of sequential container.

<font size=+1><pre>
int&nbsp;mapcar(SequentialContainer&nbsp;*src,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;source&nbsp;container&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*fn)(void&nbsp;*),/*&nbsp;Function&nbsp;to&nbsp;call&nbsp;with&nbsp;each&nbsp;element&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SequentialContainer&nbsp;*result)&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;resulting&nbsp;container&nbsp;*/
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it&nbsp;=&nbsp;iSequentialContainer.NewIterator(src);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*obj;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(it&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(obj&nbsp;=&nbsp;it-&#62;GetFirst(it);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;!=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj&nbsp;=&nbsp;it-&#62;GetNext(it))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*tmp&nbsp;=&nbsp;fn(obj);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iSequentialContainer.Add(result,tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;In&nbsp;case&nbsp;of&nbsp;any&nbsp;error&nbsp;return&nbsp;a&nbsp;partial&nbsp;result&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;error&nbsp;code&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deleteIterator(it);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}

</pre></font>
Other similar functions can be built from this model. For instance "mapcon", a function that needs two containers to build a resulting container. The result is  made out of the results of a binary function that will receive one element from each container. 

<div class="p"><!----></div>
Its implementation is trivially deduced from the above function:
<a 
name="mapcon30"></a>

<font size=+1><pre>
int&nbsp;mapcon(SequentialContainer&nbsp;*src1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SequentialContainer&nbsp;*src2,&nbsp;&nbsp;/*&nbsp;The&nbsp;input&nbsp;containers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*fn)(void&nbsp;*,void&nbsp;*),&nbsp;&nbsp;/*&nbsp;Function&nbsp;with&nbsp;2&nbsp;arguments&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SequentialContainer&nbsp;*result)&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;resulting&nbsp;container&nbsp;*/
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it1&nbsp;=&nbsp;iSequentialContainer.NewIterator(src1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;*it2&nbsp;=&nbsp;iSequentialContainer.NewIterator(src2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*obj1,*obj2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(it&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(iSequentialContainer.GetElementSize(src1)&nbsp;!=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iSequentialContainer.GetElementSize(src2))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INCOMPATIBLE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(obj1&nbsp;=&nbsp;it1-&#62;GetFirst(it1),obj2&nbsp;=&nbsp;it2-&#62;GetFirst(it2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj1&nbsp;!=&nbsp;NULL&nbsp;&amp;&amp;&nbsp;obj2&nbsp;!=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj2&nbsp;=&nbsp;it2-&#62;GetNext(it2),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj1&nbsp;=&nbsp;it1-&#62;GetNext(it1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*tmp&nbsp;=&nbsp;fn(obj1,obj2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;iSequentialContainer.Add(result,tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;In&nbsp;case&nbsp;of&nbsp;any&nbsp;error&nbsp;return&nbsp;a&nbsp;partial&nbsp;result&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;error&nbsp;code&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deleteIterator(it1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deleteIterator(it2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}

</pre></font>
We can use it with a function  that adds its two arguments to add two containers:

<font size=+1><pre>
void&nbsp;*DoAdd(void&nbsp;*element1,void&nbsp;*element2)
{
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;result&nbsp;=&nbsp;*(int&nbsp;*)element1&nbsp;+&nbsp;*(int&nbsp;*)element2;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;result;
}

</pre></font>
Note that not all errors are detected, and we stop at the smallest container, producing a result compatible with the smallest of both arguments.
Note too that we make a very superficial compatibility test to see if the arguments contain the same type of object, using their size as an indication. This test would ignore elements of the same size but incompatible, for instance floats and 32 bit integers, or 64 bit integers and double precision elements, etc.

<div class="p"><!----></div>
The standard answer to the above problems is to point out that C has a tradition of keeping things simple and expecting programmers that take care of low level details. If you want more error support, you will find out with minimal research a lot of languages ready to make all kinds of hand holding for you.

<div class="p"><!----></div>

 <h1><a name="tth_chAp8">
Chapter 8 </a><br />The sample implementation</h1>
The objective of the sample implementation is to serve as a guide for the implementers of this proposal. It is not the fastest implementation and it is not the most efficient or compact one. As any other software, it contains bugs, that I hope to iron out with time.

<div class="p"><!----></div>
Please note that all the decisions done for the sample implementation are <b>not</b> part of the specifications of the containers library. Other
implementations could do completely different things.

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Partitioning</h2>
An interface is a table of functions. This tables are a monolithic construct: if you use only one of the functions of the
interface you will have to link with all of the interface functions, whether you use them or not.

<div class="p"><!----></div>
It is important then, that each interface doesn't "pull in" other interfaces since then you would end up linking with the whole library even if
you use a small fraction of it.

<div class="p"><!----></div>
Some of this is inevitable though. All interfaces use the observer interface, so if you use any interface the observer interface will be
pulled in. It is important then, that the dependencies of the observer interface be kept to a minimum 
<a href="#tthFtNtAFA" name="tthFrefAFA"><sup>50</sup></a>. Problem is, it is necessary for the
observer interface to set the flags of the container being registered as an observed object. This means that the generic interface is needed.

<div class="p"><!----></div>
Go avoid pulling in the whole generic interface, the observer functions use the <font size="+1"><tt>vTable</tt></font>. In the sample implementation all containers
have a table of functions as first interface field. Since the description of the generic container object is published in "containers.h" it can
use the generic notation.

<font size=+1><pre>
GenericContainer&nbsp;*gen&nbsp;=&nbsp;(GenericContainer&nbsp;*)InputObject;
unsigned&nbsp;flags&nbsp;=&nbsp;gen-&#62;vTable-&#62;GetFlags(gen);

</pre></font>

<div class="p"><!----></div>
This works because the sample implementation has carefully designed all interface to be binary compatible, allowing an easy implementation
of the generic interface. All vTables have the <font size="+1"><tt>GetFlags</tt></font> function at the same place, so we always call the correct function.

<div class="p"><!----></div>
Another interface that is used by all other interfaces is the error interface. It has been kept as small as possible to avoid pulling in too much
data into the fixed overhead.

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Data structures</h2>
All container data structures are composed of two parts:

<ol type="1">
<li> A header part, containing a pointer to the functions table and some other fields. This 'generic' part is at the start of all container header structures.
<div class="p"><!----></div>
</li>

<li> A container specific part, containing auxiliary structures and data needed for the specific container at hand.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;The generic part</h3>
The first part of all container data structures is the same for each container. This allows to implement conceptually an abstract class of objects: the 'generic' container.
<a 
name="Generic Container+structure21"></a>

<font size=+1><pre>
struct&nbsp;GenericContainer&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainerInterface&nbsp;*vTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;Size;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
};

</pre></font>

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>. All containers in the sample implementation contain a pointer to the table of functions of their interface.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Size</tt></font>. The number of elements this container stores.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Flags</tt></font>. Stores the state of the container. The only flag the sample implementation uses is the <font size="+1"><tt>READ_ONLY_FLAG</tt></font> but many others are possible, for instance a 'locked' flag for multi-threading access, or a 'copy on write' flag for lazy copy, etc.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>ElementSize</tt></font>. All containers in the sample implementation can store objects of the same size. This is not really a limitation since you can store objects of ANY size by storing a pointer in the container.
An alternative design would store objects of any size but it would need to store the size of each object in addition to the data used by the object. The specialized containers like bitstrings, string collections or integer/double arrays do not need this field obviously, and its presence is optional.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Lists</h3>
<img src="List.png" alt="Figure">

<div class="p"><!----></div>
Single linked lists use a single pointer to the next element. The data for the element comes right behind that pointer to avoid the overhead that yet another pointer would represent.

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_list_element&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;_list_element&nbsp;*Next;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;Data[MINIMUM_ARRAY_INDEX];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;See&nbsp;below
}&nbsp;list_element;

</pre></font>
The list header uses this structure to store the elements<a href="#tthFtNtAFB" name="tthFrefAFB"><sup>51</sup></a>. As you can see, there is no space wasted in a pointer to the element stored. The element stored is placed just behind the <font size="+1"><tt>Next</tt></font> pointer. The downside of this decision is that we can't recycle this object to store other different objects of different size.

<div class="p"><!----></div>
      <h4><a name="tth_sEc2.2.1">
2.2.1</a>&nbsp;&nbsp;Alignment</h4>
Some machines require that data be stored at particular addresses, always a multiple of two. For instance SPARC machines require that doubles be
aligned at a multiple of 8. The structure for our list element above would provoke a crash when used to store doubles
<a href="#tthFtNtAFC" name="tthFrefAFC"><sup>52</sup></a>. 

<div class="p"><!----></div>
In those machines the list element structure is defined as follows:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_ListElement&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;_ListElement&nbsp;*Next;
#ifdef&nbsp;SPARC32
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*alignment;
#endif
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;Data[MINIMUM_ARRAY_INDEX];
}&nbsp;ListElement;

</pre></font>

<div class="p"><!----></div>
This assumes that <font size="+1"><tt>sizeof(void&nbsp;*)</tt></font> is 4. 

<div class="p"><!----></div>
In machines that handle unaligned data gracefully without crashing alignment requirements aren't useless, since in most cases they 
provoke a performance loss.
<a 
name="lists+structure22"></a>

<font size=+1><pre>
struct&nbsp;_List&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;ListInterface&nbsp;*VTable;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;	
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Last;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*First;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;Compare;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerHeap&nbsp;*Heap;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*Allocator;
};

</pre></font>
In the public <font size="+1"><tt>containers.h</tt></font> header file we refer always to an abstract structure <font size="+1"><tt>_List</tt></font>. We define it here. This schema allows other implementation to use the same header with maybe radically different implementations of their data structure.

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>, <font size="+1"><tt>count</tt></font>, <font size="+1"><tt>Flags</tt></font>, <font size="+1"><tt>ElementSize</tt></font>. This fields were described in the generic container section.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>timestamp</tt></font>. This field is incremented at each modification of the list, and allows the iterators to detect if the container changes 
during an iteration: they store the value of this field at the start of the iteration, and before each iteration they compare it with its current 
value. If there are any changes, they return&nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Last</tt></font>. Stores a pointer to the last element of the list. This allows the addition of an element at the end of the list to be fast, 
avoiding a complete rescan of the list. This field is an optimization, all algorithms of a single linked list would work without this field.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>First</tt></font>. The start of the linked list.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Compare</tt></font>. A comparison function for the type of elements stored in the list.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>RaiseError</tt></font>. A function that will be called when an error occurs. This field is necessary only if you want to keep the flexibility of 
having a different error function for each list that the client software builds. An alternative implementation would store a pointer to an error 
function in the interface.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>Allocator</tt></font>. A set of functions that allocates memory for this list. In an implementation that needs less flexibility and is more interested in saving space it could be replaced by the default allocator.
<div class="p"><!----></div>
</li>
</ol>
The sample implementation has certainly a quite voluminous header because of a design decision to keep things very flexible. Other implementations 
could trim most of the fields, and an absolute minimal implementation would trim <font size="+1"><tt>Last</tt></font>, <font size="+1"><tt>Compare</tt></font>, <font size="+1"><tt>RaiseError</tt></font>, <font size="+1"><tt>Heap</tt></font>, 
and <font size="+1"><tt>Allocator</tt></font>. If the implementation assumes that only one iterator per container is allowed, the <font size="+1"><tt>timestamp</tt></font> field could be replace by 
a single bit ('changed') in the <font size="+1"><tt>Flags</tt></font> field.<a href="#tthFtNtAFD" name="tthFrefAFD"><sup>53</sup></a>

     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Double linked lists</h3>
This container has a very similar structure to the single linked ones

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_dlist_element&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;_dlist_element&nbsp;*Next;
	struct&nbsp;_dlist_element&nbsp;*Previous;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;Data[MINIMUM_ARRAY_INDEX];
}&nbsp;dlist_element;

</pre></font>
We have now two pointers followed by the stored data. All other fields are exactly identical to the ones in the single linked list. The single difference is the existence of a free list. This could have been done in the single linked list implementation too.
<a 
name="Dlist+structure23"></a>

<font size=+1><pre>
struct&nbsp;Dlist&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;DlistInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;dlist_element&nbsp;*Last;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;dlist_element&nbsp;*First;
&nbsp;&nbsp;&nbsp;&nbsp;dlist_element&nbsp;*FreeList;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;&nbsp;
	ContainerHeap&nbsp;*Heap;
	ContainerMemoryManager&nbsp;*Allocator;
};

</pre></font>

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;Vector</h3>
Arrays are the containers that use the smallest overhead per element: zero. The only overhead is the header structure, whose cost is amortized since it is fixed for all elements that the array can hold.

<div class="p"><!----></div>
This is a 'flexible' array however, what means that there is some spare space allocated for allowing further growth, and that different allocation strategies can be followed when allocating a new chunk of array space when the existing array is full.
<a 
name="Vector+structure24"></a>

<font size=+1><pre>
struct&nbsp;_Vector&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;VectorInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;	
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*contents;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;CompareFn;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*Allocator;
}&nbsp;;

</pre></font>

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>, <font size="+1"><tt>count</tt></font>, <font size="+1"><tt>Flags</tt></font>, <font size="+1"><tt>ElementSize</tt></font>. This fields were described in the generic container section.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>CompareFn, RaiseError, timestamp</tt></font> and <font size="+1"><tt>Allocator</tt></font> were described in the <font size="+1"><tt>List</tt></font> container.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>capacity</tt></font>. Stores the number of elements this container can hold without resizing.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>contents</tt></font>. Points to an array of <font size="+1"><tt>capacity</tt></font> elements, each of size <font size="+1"><tt>ElementSize</tt></font>.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc2.5">
2.5</a>&nbsp;&nbsp;Dictionary</h3>
This container consists of an array of single linked lists. It could have been done with an <font size="+1"><tt>Vector</tt></font> of <font size="+1"><tt>List</tt></font> containers but a dedicated implementation is justified because of a greater efficiency. The advantages of the <font size="+1"><tt>Vector</tt></font> container (secured access, flexible expansion) are not needed since the array has a fixed length that never changes.
<a 
name="Dictionary+structure25"></a>

<font size=+1><pre>
struct&nbsp;_Dictionary&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;DictionaryInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*Allocator;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;(*hash)(const&nbsp;char&nbsp;*Key);
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*Key;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*Value;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;**buckets;
};

</pre></font>

<ol type="1">
<li> <font size="+1"><tt>Vtable</tt></font>, <font size="+1"><tt>count</tt></font>, <font size="+1"><tt>Flags</tt></font>, <font size="+1"><tt>ElementSize</tt></font>. This fields were described in the generic container section.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>RaiseError, timestamp</tt></font> and <font size="+1"><tt>Allocator</tt></font> were described in the <font size="+1"><tt>List</tt></font> container.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>size</tt></font>. The number of different lists that the hash table can contain. This is normally a prime number.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>hash</tt></font>. A hash function for character strings.
<div class="p"><!----></div>
</li>

<li> <font size="+1"><tt>buckets</tt></font>. A table of pointers to lists of <font size="+1"><tt>DataList</tt></font> structures.
<div class="p"><!----></div>
</li>
</ol>

     <h3><a name="tth_sEc2.6">
2.6</a>&nbsp;&nbsp;String collection</h3>
String collections are just flexible arrays of pointers to C character strings. They share all the fields of the Vector container, the only specific field is a context that is passed to the string comparison function. This context can contain flags or other information to use with special text encodings (wide characters for instance) or other data like regular expressions, etc.
<a 
name="strCollection+structure26"></a>

<font size=+1><pre>
struct&nbsp;strCollection&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;strCollectionInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;count;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;**contents;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;StringCompareFn&nbsp;strcompare;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*StringCompareContext;
&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*Allocator;
};

</pre></font>

     <h3><a name="tth_sEc2.7">
2.7</a>&nbsp;&nbsp;The iterator implementation</h3>
This data structure has two main parts:

<ul>
<li> A public part declared in <font size="+1"><tt>containers.h</tt></font>:
<a 
name="Iterator+structure27"></a>

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Iterator&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetNext)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetPrevious)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetFirst)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetCurrent)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*GetLast)(struct&nbsp;_Iterator&nbsp;*);
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*(*Seek)(struct&nbsp;_Iterator&nbsp;*,size_t);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;(*Replace)(struct&nbsp;_Iterator&nbsp;*,void&nbsp;*data,int&nbsp;direction);
}&nbsp;Iterator;

</pre></font> 
This part contains only the functions that the interface offers. It is defined in the public header <font size="+1"><tt>containers.h</tt></font>.
<div class="p"><!----></div>
</li>

<li> A private, container specific part that comes right behind the public part and stores additional information that is needed for each container. For instance the list container will add following fields:
<a 
name="ListIterator27"></a>

<font size=+1><pre>
struct&nbsp;ListIterator&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;it;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;index;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Current;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;ElementBuffer[1];
};

</pre></font>
User code should only see and use the public part, as if the iterator was only the public part. Internally all iterator functions are completely different functions, specific for the container they should iterate. It looks like from user code, as you were always calling the same function because the syntax and name is the same. This allows for a certain abstraction in the source code that uses this functions, allowing to express a whole range of algorithms in terms of general concepts.

<div class="p"><!----></div>
Each of the functions that implement <font size="+1"><tt>GetNext</tt></font> <font size="+1"><tt>GetFirst</tt></font>, etc starts with a cast of the input argument that is declared as an <font size="+1"><tt>Iterator</tt></font> structure to a concrete container iterator like our <font size="+1"><tt>ListIterator</tt></font> above.

<div class="p"><!----></div>
In all those structures there is a common ground. They have:

<ol type="1">
<li> A pointer to the container the iterator is using.
<div class="p"><!----></div>
</li>

<li> Some fields for storing the current position within the container, i.e. a cursor.
<div class="p"><!----></div>
</li>

<li> A <font size="+1"><tt>timestamp</tt></font> field to detect if the container has changed during the iteration.
<div class="p"><!----></div>
</li>

<li> A buffer that allows the iterator to store an element of the container. This area contains a copy of the current element. Normally the
iterators return a pointer to the data of each element, but in the case of read only containers a pointer to this area will be returned. 
This allows to maintain the read only semantics.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc2.8">
2.8</a>&nbsp;&nbsp;The timestamp field</h3>
This field will be incremented by each modification of the list. When an iterator is created it will copy the current value of the time stamp, and for
each subsequent operation it will compare the value of the container with its saved copy. They should be always equal, otherwise the iterator will
return always&nbsp;NULL . The only exception to this rule is the iterator <font size="+1"><tt>Replace</tt></font> function that will modify the container without invalidating
the iterator that calls it. Other iterators to the same container will be invalidated.

<div class="p"><!----></div>
The timestamp field should be incremented in all operations that somehow modify the container, not only in the operations that modify the number of 
elements.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
Implementation issues

<ul>
<li>There is currently no way to know when you delete a container if there are iterators that are still
pointing to it. This could be detected by simply having a counter of the number of iterators a container has, but that would mean more overhead for the 
already fat header objects...
<div class="p"><!----></div>
</li>

<li> The current interface requires that the user calls the <font size="+1"><tt>deleteIterator</tt></font> function when you are done using the iterator. This is
a source of memory leaks if you forget
to do this. An easier way to do this would be to maintain a list of current iterators, to be freed automatically when the container is 
destroyed. Obviously this supposes that you do not create thousands of iterators but that you reuse the iterators for different loops.
<div class="p"><!----></div>
</li>
</ul>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;The code</h2>
Only one container will be shown here in full: the List container. For the others, only some functions will be explained to save space. You are 
invited to read the distributed code of course that is part of this work.

     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;List</h3>

<div class="p"><!----></div>
<a 
name="lists+code31"></a><br />
<b>Add</b><a 
name="Add+code for \container31"></a> <hr />



<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;static&nbsp;int&nbsp;Add_nd(List&nbsp;*l,void&nbsp;*elem)
&nbsp;&nbsp;2&nbsp;{
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*newl;
&nbsp;&nbsp;4&nbsp;
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newl&nbsp;=&nbsp;new_link(l,elem,"iList.Add");
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newl&nbsp;==&nbsp;0)
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;&nbsp;0)&nbsp;{
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;newl;
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;newl;
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;newl;
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++l-&#62;count;
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;18&nbsp;}
&nbsp;19&nbsp;
&nbsp;20&nbsp;static&nbsp;int&nbsp;Add(List&nbsp;*l,void&nbsp;*elem)
&nbsp;21&nbsp;{
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r;
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL&nbsp;||&nbsp;elem&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("Add");
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;CONTAINER_READONLY)&nbsp;return&nbsp;ErrorReadOnly(l,"Add");
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;Add_nd(l,elem);
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&amp;&amp;&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER))
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l,CCL_ADD,elem,NULL);
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
&nbsp;29&nbsp;}

</pre></font>
This function adds one element at the end. The <font size="+1"><tt>Add</tt></font> entry point performs the error checking and calls <font size="+1"><tt>Add_nd</tt></font> an internal
function that does the actual work. This is needed because other functions call internally <font size="+1"><tt>Add</tt></font> after they have already performed
the error checking.

<div class="p"><!----></div>
The <font size="+1"><tt>Add_nd</tt></font> function requests a new list element (5). If that suceeds the new element must be inserted in the list.
If the list is empty it just establishes the start of the list (9), if not, it adds it after the last element (12). The new 
list element is the last one (14). Errors leave the list unchanged. Exclusive access to the list is needed between the line 8 and the line 16 in the code. 
This operation is a modification of the list, and it needs to update the <font size="+1"><tt>timestamp</tt></font> value to notify possible iterators
that they are invalid.

<div class="p"><!----></div>
If the <font size="+1"><tt>Add_nd</tt></font> function was successfull and this container has a registered observer we notify the observer of this
event.
<br />

<div class="p"><!----></div>
<b>AddRange</b><a 
name="AddRange+code for \container31"></a> <hr />



<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;static&nbsp;int&nbsp;AddRange(List&nbsp;*&nbsp;AL,size_t&nbsp;n,&nbsp;void&nbsp;*data)
&nbsp;&nbsp;2&nbsp;{
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*p;&nbsp;
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*oldLast;
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("AddRange");
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;{
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;RaiseError("iList.AddRange",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(data&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;RaiseError("iList.AddRange",CONTAINER_ERROR_BADARG);
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;data;
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldLast&nbsp;=&nbsp;AL-&#62;Last;
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;Add_nd(AL,p);
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;Last&nbsp;=&nbsp;oldLast;
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Last)&nbsp;{
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*removed&nbsp;=&nbsp;oldLast-&#62;Next;
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(removed)&nbsp;{
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*tmp&nbsp;=&nbsp;removed-&#62;Next;
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Heap)&nbsp;
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.AddToFreeList(AL-&#62;Heap,removed);
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;Allocator-&#62;free(removed);
&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;tmp;
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;Last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;+=&nbsp;AL-&#62;ElementSize;&nbsp;/*&nbsp;Point&nbsp;to&nbsp;the&nbsp;next&nbsp;element&nbsp;*/
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--;&nbsp;/*&nbsp;Count&nbsp;the&nbsp;items&nbsp;added&nbsp;so&nbsp;far&nbsp;*/
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;timestamp++;
&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(AL,CCL_ADDRANGE,data,(void&nbsp;*)n);
&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;42&nbsp;}

</pre></font>
This function calls repeatedly <font size="+1"><tt>Add_nd</tt></font> for each element of the given array. Any error provokes an abort and the original 
list is left unchanged.

<div class="p"><!----></div>
Error checking is done in lines 6 to 15, testing for&nbsp;NULL for the list and the data. If the number of elements is zero the
function does nothing and returns zero. The code accepts data as&nbsp;NULL if the number of elements is zero. If <font size="+1"><tt>n</tt></font> is
zero this code still checks  that the list is not&nbsp;NULL , and that the list is not read only, considering both to be errors.
Nothing is specified for those cases and you can't rely on this behavior for other implemetations.

<div class="p"><!----></div>
Note that at compile time we do not know the 
size of each element and we can't index into this array. We just setup a generic pointer to the start of the data area (16), and 
increment it by the size of each element at each iteration (line 35). 
This implementation supposes that the size of the elements as assumed by the list is the same as the size of then element as assumed by the calling program.

<div class="p"><!----></div>
If an error occurs when adding elements the new elements are discarded, the list is reset to its previous state and an
error code is returned. (lines 20-33). The eventually added elements are discarded (lines 24-30).

<div class="p"><!----></div>

  <b>Notes:</b>
<div class="p"><!----></div>
It would be far more efficient to test at the start of the loop if there is enough space for the
<font size="+1"><tt><i>n</i></tt></font>
list elements than
doing it within the loop. That would eliminate the code for reclaiming the already allocated items. This isn't done because
the list allocator could be the default malloc function that doesn't allow queries of this type.

<div class="p"><!----></div>
<br />
<b>Append</b><a 
name="Append+code for \container31"></a> <hr />



<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;static&nbsp;int&nbsp;Append(List&nbsp;*l1,List&nbsp;*l2)
&nbsp;&nbsp;2&nbsp;{
&nbsp;&nbsp;3&nbsp;
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1&nbsp;==&nbsp;NULL&nbsp;||&nbsp;l2&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1)
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;RaiseError("iList.Append",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Append",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((l1-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;(l2-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY))&nbsp;{
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;RaiseError("iList.Append",CONTAINER_ERROR_READONLY);
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;ElementSize&nbsp;!=&nbsp;l1-&#62;ElementSize)&nbsp;{
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;RaiseError("iList.Append",CONTAINER_ERROR_INCOMPATIBLE);
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INCOMPATIBLE;
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l1,CCL_APPEND,l2,NULL);
&nbsp;22&nbsp;&nbsp;
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l2,CCL_FINALIZE,NULL,NULL);
&nbsp;25&nbsp;&nbsp;
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;count&nbsp;==&nbsp;0)&nbsp;{
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;First&nbsp;=&nbsp;l2-&#62;First;&nbsp;
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;Last&nbsp;=&nbsp;l2-&#62;Last;
&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(l2-&#62;count&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;First)
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;Last-&#62;Next&nbsp;=&nbsp;l2-&#62;First;
&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l2-&#62;Last)
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;Last&nbsp;=&nbsp;l2-&#62;Last;
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;count&nbsp;+=&nbsp;l2-&#62;count;
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1-&#62;timestamp++;
&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l2-&#62;Allocator-&#62;free(l2);
&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;40&nbsp;}

</pre></font>
This function  adds the second argument list to the first one. The second list is destroyed because all its elements are inserted into the first one. The result is obtained by pointer manipulation: no data is moved at all, and any pointers to the objects in the second list remain valid.

<div class="p"><!----></div>
Error checking is done in lines 4 to 19. Then, the observer interface is considered. Since the second list will be destroyed
a notification is sent to any observers that listen to events in that list. A notification is sent to the first list also,
informing the observers of this event.

<div class="p"><!----></div>
The actual work can then begin (lines 26 to 36):
<font size="+1"><tt><i>l2</i></tt></font>
is appended to
<font size="+1"><tt><i>l1</i></tt></font>
and the list header of
<font size="+1"><tt><i>l2</i></tt></font>
is freed.


<div class="p"><!----></div>
  <b>Notes:</b>
<div class="p"><!----></div>
The test for compatibility between both lists is done with the size of an element,
assuming elements of the same size are of the same type. This could
very well be false but there is no portable way of test this at run time. Anyway, since a container doesn't care what is
inside the objects it manages you can store elements of different types but the same size in a single container.

<div class="p"><!----></div>
<br />
<b>Apply</b><a 
name="Apply+code for \container31"></a> <hr />



<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;static&nbsp;int&nbsp;Apply(List&nbsp;*L,int&nbsp;(Applyfn)(void&nbsp;*,void&nbsp;*),void&nbsp;*arg)
&nbsp;&nbsp;2&nbsp;{
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*le;
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*pElem=NULL;
&nbsp;&nbsp;5&nbsp;
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L&nbsp;==&nbsp;NULL&nbsp;||&nbsp;Applyfn&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L)
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.Apply",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Apply",CONTAINER_ERROR_BADARG);
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;L-&#62;First;
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Flags&amp;CONTAINER_READONLY)&nbsp;{
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pElem&nbsp;=&nbsp;L-&#62;Allocator-&#62;malloc(L-&#62;ElementSize);
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pElem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.Apply",CONTAINER_ERROR_NOMEMORY);
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(le)&nbsp;{
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pElem)&nbsp;{
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(pElem,le-&#62;Data,L-&#62;ElementSize);
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applyfn(pElem,arg);
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;Applyfn(le-&#62;Data,arg);
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;le-&#62;Next;
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pElem)
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;Allocator-&#62;free(pElem);
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;32&nbsp;}

</pre></font>
This function calls the given function for each element. If the container is read only, a copy of each element is passed to the called function. This 
copy is allocated with "malloc" because it is used for internal purposes, and the standard allocator for the list could be a heap based, i.e. one that 
doesn't really free any memory. That could be a problem if repeated calls to <font size="+1"><tt>Apply</tt></font> are done.

<div class="p"><!----></div>
This function does not pass any pointer to the called function to mark the list as changed if the data passed to it is rewritten. This means that 
there is no way to let the called function inform the rest of the software of any modifications. This can be justified by the fact that only the data, 
not the container itself can be modified, but this can be tricky in multi-threaded environments. Other implementations could pass some pointer or away 
to inform the rest of the software that a modification has been done.
<br />

<div class="p"><!----></div>
<b>Clear</b><a 
name="Clear+code for \container31"></a> <hr />



<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;static&nbsp;int&nbsp;Clear_nd(List&nbsp;*l)
&nbsp;&nbsp;2&nbsp;{
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l,CCL_CLEAR,NULL,NULL);
&nbsp;&nbsp;5&nbsp;#ifdef&nbsp;NO_GC
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.Finalize(l-&#62;Heap);
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp&nbsp;=&nbsp;l-&#62;First,*tmp;
&nbsp;10&nbsp;
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp)&nbsp;{
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;rvp;
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;DestructorFn)
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;DestructorFn(tmp);
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(tmp);
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;19&nbsp;#endif
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count&nbsp;=&nbsp;0;
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Heap&nbsp;=&nbsp;NULL;
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;Last&nbsp;=&nbsp;NULL;
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Flags&nbsp;=&nbsp;0;
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp&nbsp;=&nbsp;0;
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;26&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;27&nbsp;
&nbsp;28&nbsp;static&nbsp;int&nbsp;Clear(List&nbsp;*l)
&nbsp;29&nbsp;{
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NullPtrError("Clear");
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;{
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Clear",CONTAINER_ERROR_READONLY);
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Clear_nd(l);
&nbsp;38&nbsp;}&nbsp;

</pre></font>
This function should clear all stored elements and reset some fields of the header structure so that the resulting list header is almost the same as when it was created. The only difference is that any functions like the comparison function or the error function are not cleared. If they were changed by the user they still remain changed.

<div class="p"><!----></div>
Like in other functions we have a no-debug function (named <font size="+1"><tt>Clear_nd</tt></font>) that assumes all its parameters are correct, and the 
official entry point that checks its arguments. If we are compiling with a garbage collector in mind we can save us all the
work of releasing each element since the collector will do that automatically.
<br />

<div class="p"><!----></div>
<b>Copy</b><a 
name="Copy+code for \container31"></a> <hr />



<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;static&nbsp;List&nbsp;*Copy(List&nbsp;*l)
&nbsp;&nbsp;2&nbsp;{
&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result;
&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*elem,*newElem;
&nbsp;&nbsp;5&nbsp;
&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NullPtrError("Copy");
&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;iList.CreateWithAllocator(l-&#62;ElementSize,l-&#62;Allocator);
&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Copy",CONTAINER_ERROR_NOMEMORY);
&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Flags&nbsp;=&nbsp;l-&#62;Flags;&nbsp;
&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;l-&#62;VTable;&nbsp;
&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Compare&nbsp;=&nbsp;l-&#62;Compare;
&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;RaiseError&nbsp;=&nbsp;l-&#62;RaiseError;
&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;=&nbsp;l-&#62;First;
&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(elem)&nbsp;{
&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newElem&nbsp;=&nbsp;new_link(result,elem-&#62;Data,"iList.Copy");
&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newElem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Copy",CONTAINER_ERROR_NOMEMORY);
&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable-&#62;Finalize(result);
&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elem&nbsp;==&nbsp;l-&#62;First)&nbsp;{
&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;First&nbsp;=&nbsp;newElem;
&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;count++;
&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Last-&#62;Next&nbsp;=&nbsp;newElem;
&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;count++;
&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Last&nbsp;=&nbsp;newElem;
&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;=&nbsp;elem-&#62;Next;
&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_HAS_OBSERVER)
&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iObserver.Notify(l,CCL_COPY,result,NULL);
&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
&nbsp;41&nbsp;}


</pre></font>
This function requires a non null list pointer. It creates a header structure, and fills some of it fields with the corresponding fields of the source list:

<ol type="1">
<li> The allocator
<div class="p"><!----></div>
</li>

<li> The flags.
<div class="p"><!----></div>
</li>

<li> The table of functions. This is necessary in case some of those functions have been sub-classed.
<div class="p"><!----></div>
</li>

<li> The comparison function
<div class="p"><!----></div>
</li>

<li> The error function
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
Note that the timestamp is not copied, and starts in the copy with zero.

<div class="p"><!----></div>
If an error occurs during the copy, probably because of lack of memory, the new list is destroyed and the result is&nbsp;NULL .
Otherwise elements are added at the growing end of the list.
<br />

<div class="p"><!----></div>
<b>Contains</b><a 
name="Contains+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Contains(List&nbsp;*l,void&nbsp;*data)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(IndexOf(l,data,NULL,&amp;idx)&nbsp;&lt;&nbsp;0)&nbsp;?&nbsp;0&nbsp;:&nbsp;1;
}

</pre></font>
The <font size="+1"><tt>Contains</tt></font> function is just a cover function for <font size="+1"><tt>IndexOf</tt></font>.
<br />

<div class="p"><!----></div>
<b>CopyElement</b><a 
name="CopyElement+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;CopyElement(List&nbsp;*l,size_t&nbsp;position,void&nbsp;*outBuffer)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Error&nbsp;checking&nbsp;ellided&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(position)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memcpy(outBuffer,rvp-&#62;Data,l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
After the error checking, this function positions at the given element and copies its contents into the  given buffer.
Other designs are obviously possible. 

<ul>
<li> This function could return a newly allocated buffer. This poses other problems like the type of allocator to use. If we use the list allocator we could run into problems if it is a specialized allocator that is designed for allocating list elements from a pool where no 'free' operation exists. Another, more important problem with that solution is that it forces an allocation when none is necessary if the buffer you use is stack based.
<div class="p"><!----></div>
</li>

<li> The function could require the buffer length to be sure there are no buffer overflows. This solution was discarded because it actually increases the chances of errors: you have to pass the size of the buffer, and if you pass the wrong one more problems arise. Is it an error if you pass more space than is actually needed? It could be an error if the passed size differs from the size of the elements stored or it could be just a consequence that you used the <font size="+1"><tt>sizeof(buffer)</tt></font> expression with a bigger buffer than necessary.
<div class="p"><!----></div>
</li>
</ul>
<br />

<div class="p"><!----></div>
<b>Create</b><a 
name="Create+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;List&nbsp;*Create(size_t&nbsp;elementsize)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CreateWithAllocator(elementsize,CurrentMemoryManager);
}

</pre></font>
This function just calls <font size="+1"><tt>CreateWithAllocator</tt></font> using the current memory manager.
<br />

<div class="p"><!----></div>
<b>CreateWithAllocator</b><a 
name="CreateWithAllocator+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;List&nbsp;*CreateWithAllocator(size_t&nbsp;elementsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator)
{
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elementsize&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Create",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;allocator-&#62;malloc(sizeof(List));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Create",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memset(result,0,sizeof(List));
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;ElementSize&nbsp;=&nbsp;elementsize;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;&amp;iList;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Compare&nbsp;=&nbsp;DefaultListCompareFunction;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;RaiseError&nbsp;=&nbsp;iError.RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Allocator&nbsp;=&nbsp;allocator;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
After doing some error checking, the creation function allocates and initializes the new container with its default values.

<div class="p"><!----></div>
A big question is the alignment problem for the given size. This can't be checked and could lead to problems if you pass to this function any argument that is not the product of a sizeof expression.
<br />

<div class="p"><!----></div>
<b>DefaultListCompareFunction</b><a 
name="DefaultListCompareFunction+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;DefaultListCompareFunction(const&nbsp;void&nbsp;*left,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*right,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*ExtraArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;siz=((List&nbsp;*)ExtraArgs-&#62;Container)-&#62;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;memcmp(left,right,siz);
}

</pre></font>
The default element compare function is just a cover for <font size="+1"><tt>memcmp</tt></font>. It is assumed that the user will replace it with a comparison function of its own if necessary.
<br />

<div class="p"><!----></div>
<b>DefaultListLoadFunction</b><a 
name="DefaultListLoadFunction+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;size_t&nbsp;DefaultLoadFunction(void&nbsp;*element,void&nbsp;*arg,&nbsp;FILE&nbsp;*Infile)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;len&nbsp;=&nbsp;*(size_t&nbsp;*)arg;

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fread(element,1,len,Infile);
}

</pre></font>
This function just reads an element from the disk file. Returns the result value of <font size="+1"><tt>fread</tt></font>, what is OK for our purposes.
<br />

<div class="p"><!----></div>
<b>DefaultSaveFunction</b><a 
name="DefaultSaveFunction+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;size_t&nbsp;DefaultSaveFunction(const&nbsp;void&nbsp;*element,void&nbsp;*arg,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*Outfile)
{
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;unsigned&nbsp;char&nbsp;*str&nbsp;=&nbsp;element;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;len&nbsp;=&nbsp;*(size_t&nbsp;*)arg;

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fwrite(str,1,len,Outfile);
}

</pre></font>
This function just writes the given element to the disk. Together with the default load function they allow for a very effective serialization package for containers. Obviously here we have a shallow copy, and all this will never work for recursive saves, i.e. for elements that contain pointers.
<br />

<div class="p"><!----></div>
<b>deleteIterator</b><a 
name="deleteIterator+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;deleteIterator(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(it&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("deleteIterator",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;Allocator-&#62;free(it);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This routine retrieves the list header object from the hidden part of the iterator and uses its allocator object to free the memory used by the iterator.

<div class="p"><!----></div>
The functions <font size="+1"><tt>NewIterator</tt></font> and <font size="+1"><tt>deleteIterator</tt></font> should occur in pairs like many others in C: malloc and free, fopen and fclose, etc. It would be very easy to have in the header object a counter of iterators that should be zero when the list is destroyed or cleared.
<br />

<div class="p"><!----></div>
<b>Equal</b><a 
name="Equal+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Equal(List&nbsp;*l1,List&nbsp;*l2)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*link1,*link2;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;ci;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1&nbsp;==&nbsp;l2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1&nbsp;==&nbsp;NULL&nbsp;||&nbsp;l2&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;count&nbsp;!=&nbsp;l2-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;ElementSize&nbsp;!=&nbsp;l2-&#62;ElementSize)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;Compare&nbsp;!=&nbsp;l2-&#62;Compare)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l1-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;l1-&#62;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;link1&nbsp;=&nbsp;l1-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;link2&nbsp;=&nbsp;l2-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;ci.Container&nbsp;=&nbsp;l1;
&nbsp;&nbsp;&nbsp;&nbsp;ci.ExtraArgs&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(link1&nbsp;&amp;&amp;&nbsp;link2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fn(link1-&#62;Data,link2-&#62;Data,&amp;ci))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link1&nbsp;=&nbsp;link1-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link2&nbsp;=&nbsp;link2-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(link1&nbsp;||&nbsp;link2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
If two null pointers are passed to the <font size="+1"><tt>Equal</tt></font> function it returns true. This is a design decision: <font size="+1"><tt>Equal</tt></font> doesn't have any error result. Either the two objects are equal or not.

<div class="p"><!----></div>
A redundant test is done at the end of the function: if the lists have the same count and all elements are equal, link1 and link2 should be&nbsp;NULL . If they aren't that means there is a memory overwrite problem somewhere...
<br />

<div class="p"><!----></div>
<b>Erase</b><a 
name="Erase+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Erase(List&nbsp;*l,void&nbsp;*elem)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Erase",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Erase",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOTFOUND;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;IndexOf(l,elem,NULL,&amp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;RemoveAt(l,idx);
}

</pre></font>
This is a very inefficient implementation. The list will be traversed twice, the first by <font size="+1"><tt>IndexOf</tt></font>, and the second by <font size="+1"><tt>RemoveAt</tt></font>. The obvious solution is to merge both into one function.
<br />

<div class="p"><!----></div>
<b>EraseRange</b><a 
name="EraseRange+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;EraseRange(List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp,*start_pos,*tmp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;toremove;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(end&nbsp;&#62;&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;&#62;=&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;&#62;=&nbsp;end)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;toremove&nbsp;=&nbsp;end&nbsp;-&nbsp;start+1;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp&nbsp;&amp;&amp;&nbsp;start&nbsp;&#62;&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;start_pos&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(toremove&nbsp;&#62;&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.AddToFreeList(l-&#62;Heap,rvp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(rvp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toremove--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;start_pos-&#62;Next&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}
</pre></font>
This function positions the cursor <a href="#tthFtNtAFE" name="tthFrefAFE"><sup>54</sup></a> at the element before
the one where the range starts, and then erases until it reaches the end of the range.
<br />

<div class="p"><!----></div>
<b>Finalize</b><a 
name="Finalize+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Finalize(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;t=0;

&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;Clear(l);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(t&nbsp;&lt;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;t;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(l);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function should free the memory used by the header object. It is fundamental that this will never be done with an object not allocated with that iterator in the first place, i.e. when the user has called <font size="+1"><tt>Init</tt></font> instead of <font size="+1"><tt>Create</tt></font>. This can't be tested in a portable manner since there is no function to verify that a given memory space belongs or not to a given allocator.<a href="#tthFtNtAFF" name="tthFrefAFF"><sup>55</sup></a>
<br />

<div class="p"><!----></div>
<b>GetCurrent</b><a 
name="GetCurrent+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;void&nbsp;*GetCurrent(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;==&nbsp;(size_t)-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;L-&#62;RaiseError("GetCurrent",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;ElementBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;Current-&#62;Data;
}

</pre></font>
Returns the current object pointed by the given iterator. This function should be called only after <font size="+1"><tt>GetFirst</tt></font> is called. It verifies this by testing if a correct value is stored in the <font size="+1"><tt>index</tt></font> field. This value is stored by the <font size="+1"><tt>NewIterator</tt></font> function. This simple algorithm avoids the usage of an uninitialized iterator at the cost of one integer comparison per call.

<div class="p"><!----></div>
<br />
<b>GetFirst</b><a 
name="GetFirst+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;void&nbsp;*GetFirst(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;


&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;timestamp&nbsp;!=&nbsp;L-&#62;timestamp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.GetFirst",CONTAINER_ERROR_OBJECT_CHANGED);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(li-&#62;ElementBuffer,L-&#62;First-&#62;Data,L-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;ElementBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;L-&#62;First-&#62;Data;
}

</pre></font>
This function should set the iteration at the first element of the container, ready to get the iteration started. After the error checking phase it returns a pointer to the data in the first element, or a pointer to a copy of that data if the container is read only.
<br />

<div class="p"><!----></div>
<b>GetFlags</b><a 
name="GetFlags+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;unsigned&nbsp;GetFlags(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.GetFlags",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(unsigned)CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;l-&#62;Flags;
}

</pre></font>
Just returns the value of the flags.
<br />

<div class="p"><!----></div>
<b>GetNext</b><a 
name="GetNext+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;void&nbsp;*GetNext(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*result;


&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.GetNext",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;&#62;=&nbsp;(L-&#62;count-1)&nbsp;||&nbsp;li-&#62;Current&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;timestamp&nbsp;!=&nbsp;L-&#62;timestamp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("GetNext",CONTAINER_ERROR_OBJECT_CHANGED);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;li-&#62;Current-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index++;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(li-&#62;ElementBuffer,li-&#62;Current-&#62;Data,L-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;ElementBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;li-&#62;Current-&#62;Data;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
Advances the cursor to the next element and returns either a pointer to it or a pointer to a copy if the list is read only. The test for the cursor being&nbsp;NULL avoids using <font size="+1"><tt>GetNext</tt></font> with an uninitialized iterator.
<br />

<div class="p"><!----></div>
<b>GetPrevious</b><a 
name="GetPrevious+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;void&nbsp;*GetPrevious(Iterator&nbsp;*it)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*L;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;

&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;=&nbsp;li-&#62;L;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;&#62;=&nbsp;L-&#62;count&nbsp;||&nbsp;li-&#62;index&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;timestamp&nbsp;!=&nbsp;L-&#62;timestamp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("GetPrevious",CONTAINER_ERROR_OBJECT_CHANGED);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;i=0;
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index--;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;index&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;&nbsp;li-&#62;index)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;rvp-&#62;Data;
}

</pre></font>
There were heated discussions about this function. In single linked lists it is necessary to go through the whole list at each call to this function. This is extremely inefficient and its usage should be avoided, it is much better to use double linked lists if you are interested in bi-directional cursor positioning. In the other hand this should be a required iterator feature, and rather than filling this function pointer with a function that just returns an error, the user is better served with a function that actually returns the previous item. Besides for short lists the performance lost is quite small, and would justify using lists with smaller overhead per item.<a href="#tthFtNtAFG" name="tthFrefAFG"><sup>56</sup></a>.
<br />

<div class="p"><!----></div>
<b>GetRange</b><a 
name="GetRange+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;List&nbsp;*GetRange(List&nbsp;*l,size_t&nbsp;start,size_t&nbsp;end)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;counter;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;;

&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;iList.Create(l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;l-&#62;VTable;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(end&nbsp;&#62;=&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;&#62;&nbsp;end&nbsp;||&nbsp;start&nbsp;&#62;&nbsp;l-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(start&nbsp;==&nbsp;l-&#62;count-1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(counter&nbsp;&lt;&nbsp;start)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(start&nbsp;&lt;&nbsp;end&nbsp;&amp;&amp;&nbsp;rvp&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;result-&#62;VTable-&#62;Add(result,&amp;rvp-&#62;Data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finalize(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
A new list is constructed from the given range of elements. The elements are copied. Any error during the construction of the new list provokes a&nbsp;NULL result: the copied elements are destroyed. Only correctly constructed ranges are returned. A recurring problem arises because it is impossible to report any details about the error that stops the copy. The result is actually boolean, either everything worked and there is a non&nbsp;NULL result, or something didn't. 

<div class="p"><!----></div>
An alternative design would have an integer return code, and a pointer to a result. This option was discarded because it is cumbersome and the most likely reason for <font size="+1"><tt>Add</tt></font> to fail is lack of memory.
<br />

<div class="p"><!----></div>
<b>IndexOf</b><a 
name="IndexOf+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;IndexOf(List&nbsp;*l,void&nbsp;*ElementToFind,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs,size_t&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r,i=0;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;ci;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL&nbsp;||&nbsp;ElementToFind&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.IndexOf",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.IndexOf",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;l-&#62;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;ci.Container&nbsp;=&nbsp;l;
&nbsp;&nbsp;&nbsp;&nbsp;ci.ExtraArgs&nbsp;=&nbsp;ExtraArgs;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;fn(&amp;rvp-&#62;Data,ElementToFind,&amp;ci);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*result&nbsp;=&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOTFOUND;
}

</pre></font>
The design of this function went through several iterations. The big problem was the result type: a <font size="+1"><tt>size_t</tt></font>, that in most cases is an unsigned quantity. A negative error result then was out of the question. But then, how would you indicate an error? <a href="#tthFtNtAFH" name="tthFrefAFH"><sup>57</sup></a>

<div class="p"><!----></div>
A first solution was to return a 1 based index and reserve zero for the 'not found' value. That could work, but was the source of many bugs in the rest of the software when the value was used without decrementing it first. 

<div class="p"><!----></div>
A second solution was to reserve a value within the <font size="+1"><tt>size_t</tt></font> range to represent the 'not found' result. That works, and it is doable, but produced other, more subtle, problems in the rest of the sofwtare since in all checks of a size_t, it could be that <i>this</i> size_t has a value that is actually the sentinel value of <font size="+1"><tt>IndexOf</tt></font>: the tests tended to multiply and the handling of those tests started to become a problem.

<div class="p"><!----></div>
Here you see the third iteration: the function receives a pointer to a size_t that will be set if the function returns with a result greater than zero.

<div class="p"><!----></div>
Another, completely different issue is the fact that in lists, this function is inefficient since it forces the function that uses the result to restart a list traversal to access the nth element. Much more efficient would be to do something immediately with the result, or to return a list element that allows the calling software to use it without going again through the list. 

<div class="p"><!----></div>
Problems with those solutions is that they are not portable, and that they would expose the inner workings of the list container to the users. The <font size="+1"><tt>list_element</tt></font> structure is not even mentioned in the public containers.h.

<div class="p"><!----></div>
<br />
<b>InitWithAllocator</b><a 
name="InitWithAllocator+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;List&nbsp;*InitWithAllocator(List&nbsp;*result,size_t&nbsp;elementsize,
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elementsize&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Init",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memset(result,0,sizeof(List));
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;ElementSize&nbsp;=&nbsp;elementsize;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;&amp;iList;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Compare&nbsp;=&nbsp;DefaultListCompareFunction;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;RaiseError&nbsp;=&nbsp;iError.RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Allocator&nbsp;=&nbsp;allocator;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
This function initializes a piece of storage to a list container. This allows the user to use stack storage for the list container, saving an allocation from the heap, and the corresponding need to free that storage.
<br />

<div class="p"><!----></div>
<b>Init</b><a 
name="Init+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;List&nbsp;*Init(List&nbsp;*result,size_t&nbsp;elementsize)
{
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;InitWithAllocator(result,elementsize,CurrentMemoryManager);
}

</pre></font>
Uses the current memory manager to call InitWithAllocator.
<br />

<div class="p"><!----></div>
<b>InsertAt</b><a 
name="InsertAt+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;InsertAt(List&nbsp;*l,size_t&nbsp;pos,void&nbsp;*pdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*elem;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL&nbsp;||&nbsp;pdata&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.InsertAt",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pos&nbsp;&#62;&nbsp;l-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_INDEX);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pos&nbsp;==&nbsp;l-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;l-&#62;VTable-&#62;Add(l,pdata);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;elem&nbsp;=&nbsp;new_link(l,pdata,"iList.&nbsp;InsertAt");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(elem&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertAt",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pos&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem-&#62;Next&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;elem;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(--pos&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elem-&#62;Next&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp-&#62;Next&nbsp;=&nbsp;elem;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This inserts before the given index. It would have been equally possible to insert after, that is a more or less random decision.
<br />

<div class="p"><!----></div>
<b>InsertIn</b><a 
name="InsertIn+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;InsertIn(List&nbsp;*l,&nbsp;size_t&nbsp;idx,List&nbsp;*newData)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;newCount;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*le,*nle;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;&nbsp;l-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertIn",CONTAINER_ERROR_INDEX);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;ElementSize&nbsp;!=&nbsp;newData-&#62;ElementSize)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertIn",CONTAINER_ERROR_INCOMPATIBLE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INCOMPATIBLE;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newData-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;newData&nbsp;=&nbsp;Copy(newData);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newData&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.InsertIn",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;newCount&nbsp;=&nbsp;l-&#62;count&nbsp;+&nbsp;newData-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;newData-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;newData-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(le&nbsp;&amp;&amp;&nbsp;idx&nbsp;&#62;&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;le-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nle&nbsp;=&nbsp;le-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;le-&#62;Next&nbsp;=&nbsp;newData-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newData-&#62;Last-&#62;Next&nbsp;=&nbsp;nle;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;newData-&#62;Allocator-&#62;free(newData);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count&nbsp;=&nbsp;newCount;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
Inserts the given list at the specified position.

<ol type="1">
<li> Error checking. First argument must be non&nbsp;NULL and read/write. Second must be non&nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> If the position given is exactly the same as the length of the receiving list, the second list is just appended to the first one.
<div class="p"><!----></div>
</li>

<li> Otherwise search the position and insert a copy of the elements in the second list.
<div class="p"><!----></div>
</li>
</ol>
<br />

<div class="p"><!----></div>
<b>Load</b><a 
name="Load+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;List&nbsp;*Load(FILE&nbsp;*stream,&nbsp;ReadFunction&nbsp;loadFn,void&nbsp;*arg)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i,elemSize;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*result,L;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*buf;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r;
&nbsp;&nbsp;&nbsp;&nbsp;guid&nbsp;Guid;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(loadFn&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadFn&nbsp;=&nbsp;DefaultLoadFunction;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;=&nbsp;&amp;elemSize;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fread(&amp;Guid,sizeof(guid),1,stream)&nbsp;&lt;=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_FILE_READ);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(memcmp(&amp;Guid,&amp;ListGuid,sizeof(guid)))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_WRONGFILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fread(&amp;L,1,sizeof(List),stream)&nbsp;&lt;=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_FILE_READ);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;elemSize&nbsp;=&nbsp;L.ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;=&nbsp;malloc(L.ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;iList.Create(L.ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Flags&nbsp;=&nbsp;L.Flags;
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&nbsp;&lt;&nbsp;L.count;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(loadFn(buf,arg,stream)&nbsp;&lt;=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;CONTAINER_ERROR_FILE_READ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((r=Add(result,buf))&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;free(buf);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Load",r);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>

<div class="p"><!----></div>
The load function is long and complex. As always, the process starts with error checking. All streams written to by its counterpart <font size="+1"><tt>Save</tt></font> are 
marked with a container specific globally unique identifier (GUID). This ensures that a load function from the list container will not crash if passed a file that belongs to an array or a dictionary, or a totally unrelated file. The guids can be changed to mark the versions of the software and
allow more advanced versions to read older versions.<a 
name="guid31"></a>

<div class="p"><!----></div>
Then, the header object is read, what gives the data to continue the process, since we now know the number of elements and the size of each element.

<div class="p"><!----></div>
A new list is created with the given element size, and we start reading <i>count</i> elements from the stream. Any error provokes the destruction of the elements read so far and a result of NULL.
<br />

<div class="p"><!----></div>
<b>NewIterator</b><a 
name="NewIterator+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;Iterator&nbsp;*NewIterator(List&nbsp;*L)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*result;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.NewIterator",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;L-&#62;Allocator-&#62;malloc(sizeof(struct&nbsp;ListIterator));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("iList.NewIterator",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetNext&nbsp;=&nbsp;GetNext;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetPrevious&nbsp;=&nbsp;GetPrevious;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetFirst&nbsp;=&nbsp;GetFirst;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;it.GetCurrent&nbsp;=&nbsp;GetCurrent;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;L&nbsp;=&nbsp;L;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;timestamp&nbsp;=&nbsp;L-&#62;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;index&nbsp;=&nbsp;(size_t)-1;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Current&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&amp;result-&#62;it;
}

</pre></font>
The creation of a new iterator involves just allocating and initializing values to their defaults.
<br />

<div class="p"><!----></div>
<b>PopFront</b><a 
name="PopFront+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;PopFront(List&nbsp;*l,void&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*le;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;le&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;Last&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;First-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(result,&amp;le-&#62;Data,l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.AddToFreeList(l-&#62;Heap,le);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;Allocator-&#62;free(le);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
Contrary to most versions of this function, <font size="+1"><tt>PopFront</tt></font> does not return the data of the element but stores it in a pointer that it receives. If the pointer is&nbsp;NULL , the data is just discarded.

<div class="p"><!----></div>
The problem with returning a pointer to the first element, is that the user code should remember to discard it when no longer needed, and it should discard it using the same allocator that the list used to allocate it. That would be a very error prone interface.
<br />

<div class="p"><!----></div>
<b>PushFront</b><a 
name="PushFront+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;PushFront(List&nbsp;*l,void&nbsp;*pdata)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;new_link(l,pdata,"Insert");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rvp&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;rvp-&#62;Next&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Last&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
Lists are a good base to implement a stack. PushFront and PopFront take a constant and small time to complete and they would be much smaller if we would eliminate the error checking.
<br />

<div class="p"><!----></div>
<b>RemoveAt</b><a 
name="RemoveAt+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;RemoveAt(List&nbsp;*l,size_t&nbsp;position)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp,*last,*removed;


&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(position&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;==&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;Last&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;l-&#62;First-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(position&nbsp;==&nbsp;l-&#62;count&nbsp;-&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(rvp-&#62;Next&nbsp;!=&nbsp;l-&#62;Last)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(position&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position&nbsp;--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;removed&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last-&#62;Next&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Heap)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iHeap.AddToFreeList(l-&#62;Heap,removed);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;Allocator-&#62;free(removed);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;--l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The operation when <font size="+1"><tt>RemoveAt</tt></font> is called with the index of the last element is equivalent to the <font size="+1"><tt>PopBack</tt></font> function, that is absent in the single linked list interface. After much discussions, we decided that the generic interface would have only Push and Pop, and that each container would fill those functions with the most efficient implementation available for it. For lists, the most efficient implementation is PopFront and PushFront. For arrays, the most efficient is PushBack and PopBack. For double linked lists is either.
<br />

<div class="p"><!----></div>
<b>ReplaceAt</b><a 
name="ReplaceAt+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;ReplaceAt(List&nbsp;*l,size_t&nbsp;position,void&nbsp;*data)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(position&nbsp;==&nbsp;l-&#62;count-1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(position)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;rvp-&#62;Data&nbsp;,&nbsp;data,l-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
After error checking (not shown), position the cursor at the right item, then copy from the given data pointer the element size bytes needed.

<div class="p"><!----></div>
An open issue is whether the "timestamp" field should be changed. Nothing in the list structure has been changed, only the data stored in the container. Any iterators will go on working as advertised even if this function is called to replace many items in the list. In the other hand, if  user programs were making assumptions about the data (for instance a search function doesn't always look again at past items to see if they have been changed) this could bad consequences. As a rule, any change will provoke the incrementing of the "timestamp" counter.
<br />

<div class="p"><!----></div>
<b>Reverse</b><a 
name="Reverse+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Reverse(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*New,*current,*old;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;old&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;New&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(old)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;old;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;old&nbsp;=&nbsp;old-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current-&#62;Next&nbsp;=&nbsp;New;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;New&nbsp;=&nbsp;current;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;New;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
After the error checking, the list is reversed in place if the count of its element is bigger than 1.<a href="#tthFtNtAFI" name="tthFrefAFI"><sup>58</sup></a>
<br />

<div class="p"><!----></div>
<b>RotateLeft</b><a 
name="RotateLeft+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;RotateLeft(List&nbsp;*l,&nbsp;size_t&nbsp;n)
{
&nbsp;&nbsp;&nbsp;&nbsp;ListElement&nbsp;*rvp,*oldStart,*last=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("RotateLeft");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ErrorReadOnly(l,"RotateLeft");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2&nbsp;||&nbsp;n&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;%=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;oldStart&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;oldStart;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;last;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The <font size="+1"><tt>RotateLeft</tt></font> and the <font size="+1"><tt>RotateRight</tt></font>functions can be implemented without any movement of the stored objects themselves. It suffices to make the list start at another place: <i>n</i> places after the start for left rotates, or n places before the end for right rotates.
<br />

<div class="p"><!----></div>
<b>RotateRight</b><a 
name="RotateRight+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;RotateRight(List&nbsp;*l,&nbsp;size_t&nbsp;n)
{
&nbsp;&nbsp;&nbsp;&nbsp;ListElement&nbsp;*rvp,*oldStart,*last=NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;NullPtrError("RotateRight");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ErrorReadOnly(l,"RotateRight");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2&nbsp;||&nbsp;n&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;%=&nbsp;l-&#62;count;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(n&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;oldStart&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;=&nbsp;l-&#62;count&nbsp;-&nbsp;n;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(n&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;last&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n--;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(last&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("RotateRight",CONTAINER_INTERNAL_ERROR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_INTERNAL_ERROR;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;last-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last-&#62;Next&nbsp;=&nbsp;oldStart;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;last;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>

<div class="p"><!----></div>
The <font size="+1"><tt>RotateRight/RotateLeft</tt></font> functions check their arguments to the contrary of their <font size="+1"><tt>ValArray</tt></font> counterparts that do not. This 
implementation shows also a checking of values that <i>should</i> be non-null but could be&nbsp;NULL if there is a memory overwrite or another
similar problem.
<br />

<div class="p"><!----></div>
<b>Save</b><a 
name="Save+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Save(List&nbsp;*L,FILE&nbsp;*stream,&nbsp;SaveFunction&nbsp;saveFn,void&nbsp;*arg)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(saveFn&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;saveFn&nbsp;=&nbsp;DefaultSaveFunction;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg&nbsp;=&nbsp;&amp;L-&#62;ElementSize;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fwrite(&amp;ListGuid,sizeof(guid),1,stream)&nbsp;&lt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EOF;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fwrite(L,1,sizeof(List),stream)&nbsp;&lt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EOF;
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;&nbsp;L-&#62;count;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*p&nbsp;=&nbsp;rvp-&#62;Data;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(saveFn(p,arg,stream)&nbsp;&lt;=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EOF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The format of the saved list container is:

<ol type="1">
<li> The GUID of the list container: 128 bytes
<div class="p"><!----></div>
</li>

<li> The Header object
<div class="p"><!----></div>
</li>

<li> The data for all the elements of the list. This is the siz of the container times the element size.
<div class="p"><!----></div>
</li>
</ol>
<br />

<div class="p"><!----></div>
<b>Seek</b><a 
name="Seek+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;void&nbsp;*Seek(Iterator&nbsp;*it,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;ListIterator&nbsp;*li&nbsp;=&nbsp;(struct&nbsp;ListIterator&nbsp;*)it;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;


&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(li-&#62;L-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;

&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;li-&#62;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=&nbsp;li-&#62;L-&#62;count-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;li-&#62;L-&#62;count-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;li-&#62;L-&#62;Last;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;li-&#62;L-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;index&nbsp;=&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(idx&nbsp;&#62;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;li-&#62;Current&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;li-&#62;Current;
}

</pre></font>
This function positions the given iterator at the desired position. Several alternatives are possible, for instance position the iterator at a
given item. This can be obtained now only by calling first <font size="+1"><tt>IndexOf</tt></font>, then <font size="+1"><tt>Seek</tt></font>, what forces to go through the list twice.
<br />

<div class="p"><!----></div>
<b>SetCompareFunction</b><a 
name="SetCompareFunction+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;CompareFunction&nbsp;SetCompareFunction(List&nbsp;*l,CompareFunction&nbsp;fn)
{
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;oldfn&nbsp;=&nbsp;l-&#62;Compare;

&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.SetCompareFunction",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if&nbsp;(fn&nbsp;!=&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&amp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.SetCompareFunction",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_LIST_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;l-&#62;Compare&nbsp;=&nbsp;fn;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return&nbsp;oldfn;
}

</pre></font>
This function returns the old value of the comparison function and sets it to the new one, if the new one is not&nbsp;NULL . This allows to query the comparison function without changing it, avoiding yet another trivial function like GetComparisonFunction. This is just what in other languages like Objective C or others is called a <i>property</i> of the iList object. Objective C makes all this automatic with its <font size="+1"><tt>synthetise</tt></font> directive.

<div class="p"><!----></div>
In C there isn't any such hand holding and you have to write that code yourself. There are several other functions in the same style like <font size="+1"><tt>SetErrorFunction</tt></font>, <font size="+1"><tt>Size</tt></font> (that returns the <font size="+1"><tt>count</tt></font> field) and <font size="+1"><tt>SetFlags</tt></font>. They aren't listed here but you can look at the code by browsing through the list.c file distributed
with this software.
<br />

<div class="p"><!----></div>
<b>Sizeof</b><a 
name="Sizeof+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;size_t&nbsp;Sizeof(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sizeof(List);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sizeof(List)&nbsp;+&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;ElementSize&nbsp;*&nbsp;l-&#62;count&nbsp;+&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;count&nbsp;*sizeof(list_element);
}

</pre></font>
Returns the number of bytes used by the given list, including the data, and all overhead. For lists, tghis is the size of the header object, and for 
each element the overhead of a pointer to the next element and the size of each stored object. With a&nbsp;NULL list pointer returns the size of the list 
header object, what allows you to allocate buffers containing a header object and use the <font size="+1"><tt>Init</tt></font> function.
<br />

<div class="p"><!----></div>
<b>Sort</b><a 
name="Sort+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Sort(List&nbsp;*l)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;**tab;
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*rvp;
&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;ci;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.Sort",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;count&nbsp;&lt;&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(l-&#62;Flags&amp;CONTAINER_LIST_READONLY)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Sort",CONTAINER_ERROR_READONLY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;tab&nbsp;=&nbsp;l-&#62;Allocator-&#62;malloc(l-&#62;count&nbsp;*&nbsp;sizeof(list_element&nbsp;*));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tab&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;RaiseError("iList.Sort",CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;l-&#62;First;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;l-&#62;count;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tab[i]&nbsp;=&nbsp;rvp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rvp&nbsp;=&nbsp;rvp-&#62;Next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ci.Container&nbsp;=&nbsp;l;
&nbsp;&nbsp;&nbsp;&nbsp;ci.ExtraArgs&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;qsortEx(tab,l-&#62;count,sizeof(list_element&nbsp;*),lcompar,&amp;ci);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;l-&#62;count-1;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tab[i]-&#62;Next&nbsp;=&nbsp;tab[i+1];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;tab[l-&#62;count-1]-&#62;Next&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Last&nbsp;=&nbsp;tab[l-&#62;count-1];
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;First&nbsp;=&nbsp;tab[0];
&nbsp;&nbsp;&nbsp;&nbsp;l-&#62;Allocator-&#62;free(tab);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;

}

</pre></font>
This function basically builds an array and calls quicksort, nothing really fancy. Note that it calls a modified version of the library
function quicksort, since it needs to pass a context to it for the comparison function.
The default comparison function is listed below:

<font size=+1><pre>
static&nbsp;bool&nbsp;lcompar&nbsp;(const&nbsp;void&nbsp;*elem1,&nbsp;const&nbsp;void&nbsp;*elem2,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CompareInfo&nbsp;*ExtraArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Elem1&nbsp;=&nbsp;*(list_element&nbsp;**)elem1;
&nbsp;&nbsp;&nbsp;&nbsp;list_element&nbsp;*Elem2&nbsp;=&nbsp;*(list_element&nbsp;**)elem2;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*l&nbsp;=&nbsp;(List&nbsp;*)ExtraArgs-&#62;Container;
&nbsp;&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;fn&nbsp;=&nbsp;l-&#62;Compare;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;fn(Elem1-&#62;Data,Elem2-&#62;Data,ExtraArgs);
}

</pre></font>
The default comparison function pulls the list compare function and calls it with the extra arguments needed to
pass a context to it.
<br />

<div class="p"><!----></div>
<b>UseHeap</b><a 
name="UseHeap+code for \container31"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;UseHeap(List&nbsp;*L,&nbsp;ContainerMemoryManager&nbsp;*m)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iList.UseHeap",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(L-&#62;Heap&nbsp;||&nbsp;L-&#62;count)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;RaiseError("UseHeap",CONTAINER_ERROR_NOT_EMPTY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOT_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(m&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m&nbsp;=&nbsp;CurrentMemoryManager;
&nbsp;&nbsp;&nbsp;&nbsp;L-&#62;Heap&nbsp;=&nbsp;iHeap.Create(L-&#62;ElementSize+sizeof(list_element),&nbsp;m);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function installs a heap to be used by the list. This is very important for huge lists, since performance goes quickly down if you call malloc 
for each element you add to the list. Basically, the heap is just a way to allocate memory in blocks so that malloc calls are reduced.

     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Queues</h3>
Queues are, to use the C++ terminology, <i>adaptor</i> containers, i.e. containers based on other containers, in this case a list. We describe here
an implementation with the objective to show how those adaptors can be implemented, and how you can restrain the interface of the underlying container
with a small cost.

<div class="p"><!----></div>
The data structure used is very simple:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_Queue&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;QueueInterface&nbsp;*VTable;
&nbsp;&nbsp;&nbsp;&nbsp;List&nbsp;*Items;
}&nbsp;_Queue;

</pre></font>
Just two fields: the interface and the underlying list.
We do not document here some functions of the queue interface that trivially call the corresponding List functions.

<div class="p"><!----></div>
<br />
<b>Back</b><a 
name="Back+code for \container32"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Back(Queue&nbsp;*Q,void&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Q&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iQueue.Front",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;iList.Size(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;iList.CopyElement(Q-&#62;Items,idx-1,result);
}

</pre></font>
Returns the last element of the queue. We do not want to have any errors issued by the underlying list, so we test for&nbsp;NULL . We use the size as an index, except of course when the queue is empty.
<br />

<div class="p"><!----></div>
<b>CreateWithAllocator</b><a 
name="CreateWithAllocator+code for \container32"></a> <hr />



<font size=+1><pre>
static&nbsp;Queue&nbsp;*CreateWithAllocator(size_t&nbsp;ElementSize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator)
{
&nbsp;&nbsp;&nbsp;&nbsp;Queue&nbsp;*result&nbsp;=&nbsp;allocator-&#62;malloc(sizeof(Queue));

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Items&nbsp;=&nbsp;iList.CreateWithAllocator(ElementSize,allocator);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result-&#62;Items&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allocator-&#62;free(result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;VTable&nbsp;=&nbsp;&amp;iQueue;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>
Using the given allocator, we get memory for the Queue object, then for the list using the given allocator.
<br />

<div class="p"><!----></div>
<b>Finalize</b><a 
name="Finalize+code for \container32"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Finalize(Queue&nbsp;*Q)
{
&nbsp;&nbsp;&nbsp;&nbsp;ContainerMemoryManager&nbsp;*allocator&nbsp;=&nbsp;iList.GetAllocator(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;iList.Finalize(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;allocator-&#62;free(Q);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
We should free the queue header object with the same allocator we used for the list. We obtain it first, before we free the list.
<br />

<div class="p"><!----></div>
<b>Front</b><a 
name="Front+code for \container32"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Front(Queue&nbsp;*Q,void&nbsp;*result)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Q&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iQueue.Front",CONTAINER_ERROR_BADARG);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_BADARG;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;iList.Size(Q-&#62;Items);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;iList.CopyElement(Q-&#62;Items,0,result);
}

</pre></font>
Same as <font size="+1"><tt>Back</tt></font>. We make the error checking to avoid errors when accessing the list.
<br />

<div class="p"><!----></div>
<b>Sizeof</b><a 
name="Sizeof+code for \container32"></a> <hr />



<font size=+1><pre>
static&nbsp;size_t&nbsp;Sizeof(Queue&nbsp;*q)
{
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(q&nbsp;==&nbsp;NULL)&nbsp;return&nbsp;sizeof(Queue);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sizeof(*q)&nbsp;+&nbsp;iList.Sizeof(q-&#62;Items);
}

</pre></font>
If passed a&nbsp;NULL queue, we return the size of the Queue header object. Note that we do not return the size of the underlying list even if it has been allocated and uses up space. An alternative design would have required to take into account the list header as it would have been part of the overhead of the Queue object. But in that case we could never know the size of the Queue itself...

     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;The dictionary</h3>
Dictionary is an instance of a hash table where the key is supposed to contain character strings (names) that are associated with some data. Hash 
tables are normal tables that are indexed by a hash function, i.e. a function that maps character strings into some integer that is used to index the 
table. At each slot of the table we find a linked list of elements that were classified by the hash function into the same slot. If we have a good hash function, i.e. one that spreads evenly the elements across the table, we can have a speed up for searching an element of the order of the table size, in the best case.

<div class="p"><!----></div>
      <h4><a name="tth_sEc3.3.1">
3.3.1</a>&nbsp;&nbsp;Hashing</h4>
One of the important aspects of a dictionary implementation is to use a good hash function, i.e. one that distributes evenly the keys. I have picked
up for this work one of the most used functions of this type. Here is the documentation I found for this function in the Apache runtime:

<div class="p"><!----></div>

<blockquote>This is the popular `times 33' hash algorithm which is used by perl and that also appears in Berkeley DB. This is one of the best
 known hash functions for strings because it is both computed very fast and distributes very well.

<div class="p"><!----></div>
 The originator may be Dan Bernstein but the code in Berkeley DB cites Chris Torek as the source. The best citation I have found
 is "Chris Torek, Hash function for text in C, Usenet message   &lt; 27038@mimsy.umd.edu &gt;  in comp.lang.c , October, 1990." in Rich
 Salz's USENIX 1992 paper about INN which can be found at  <u>http://citeseer.nj.nec.com/salz92internetnews.html</u>.

<div class="p"><!----></div>
    The magic of number 33, i.e. why it works better than many other constants, prime or not, has never been adequately explained by
 anyone. So I try an explanation: if one experimentally tests all  multipliers between 1 and 256 (as I did while writing a low-level
 data structure library some time ago) one detects that even numbers are not useable at all. The remaining 128 odd numbers
 (except for the number 1) work more or less all equally well.  They all distribute in an acceptable way and this way fill a hash
 table with an average percent of approx. 86%.

<div class="p"><!----></div>
   If one compares the chi<sup>2</sup> 
 values of the variants (see Bob Jenkins "Hashing FAQ" at <u>
 http://burtleburtle.net/bob/hash/hashfaq.html</u>  for a description  of chi<sup>2</sup>), the number 33 not even has the best value. 
<div class="p"><!----></div>
 But the
 number 33 and a few other equally good numbers like 17, 31, 63, 127 and 129 have nevertheless a great advantage to the remaining
 numbers in the large set of possible multipliers: their multiply operation can be replaced by a faster operation based on just one
 shift plus either a single addition or subtraction operation. And  because a hash function has to both distribute good <i>and</i> has to
 be very fast to compute, those few numbers should be preferred.

<div class="p"><!----></div>
                 - Ralf S. Engelschall  &lt; rse@engelschall.com &gt; 
                
</blockquote>
Julienne Walker has another twist to this story. She says:<a href="#tthFtNtAFJ" name="tthFrefAFJ"><sup>59</sup></a>

<blockquote>
Bernstein hash

<div class="p"><!----></div>
Dan Bernstein created this algorithm and posted it in a newsgroup. It is known by many as the Chris Torek hash because Chris went a long way toward popularizing it. Since then it has been used successfully by many, but despite that the algorithm itself is not very sound when it comes to avalanche and permutation of the internal state. It has proven very good for small character keys, where it can outperform algorithms that result in a more random distribution.

<div class="p"><!----></div>
Bernstein's hash should be used with caution. It performs very well in practice, for no apparently known reasons (much like how the constant 33 does better than more logical constants for no apparent reason), but in theory it is not up to snuff. Always test this function with sample data for every application to ensure that it does not encounter a degenerate case and cause excessive collisions.
</blockquote>
<br />

<div class="p"><!----></div>
<b>hash</b><a 
name="hash+code for \container33"></a> <hr />



<font size=+1><pre>
static&nbsp;unsigned&nbsp;int&nbsp;hash(const&nbsp;unsigned&nbsp;char&nbsp;*key)
{
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Hash&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;const&nbsp;unsigned&nbsp;char&nbsp;*p;
		
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(p&nbsp;=&nbsp;key;&nbsp;*p;&nbsp;p++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hash&nbsp;=&nbsp;Hash&nbsp;*&nbsp;33&nbsp;+&nbsp;scatter[*p];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Hash;
}

</pre></font>
Note that I have slightly modified the algorithm by using a scatter table of 256 positions filled with random numbers. The objective is to avoid
that letters that appear frequently in the text would tend to cluster the keys in  the same position.

<div class="p"><!----></div>
This default function may not be the best for the data in the user's application. The library has reserved a field in the dictionary header object for a pointer to a hash function that can be changed by the user.

<div class="p"><!----></div>
      <h4><a name="tth_sEc3.3.2">
3.3.2</a>&nbsp;&nbsp;Creation</h4>
Another important aspect of the dictionary implementation is the decision of how many slots the table should have. I have followed the recommendations of Dave Hanson in his Book "C interfaces and Implementations"<a href="#tthFtNtAGA" name="tthFrefAGA"><sup>60</sup></a>, and I use a small table of primes to decide what size the table should have:
<br />

<div class="p"><!----></div>
<b>Init</b><a 
name="Init+code for \container33"></a> <hr />



<font size=+1><pre>
static&nbsp;Dictionary&nbsp;*Init(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;elementsize,size_t&nbsp;hint)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i,allocSiz;
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;unsigned&nbsp;primes[]&nbsp;=&nbsp;{&nbsp;509,&nbsp;509,&nbsp;1021,&nbsp;2053,&nbsp;4093,&nbsp;8191,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16381,&nbsp;32771,&nbsp;65521,&nbsp;131071,&nbsp;0&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;1;&nbsp;primes[i]&nbsp;&lt;&nbsp;hint&nbsp;&amp;&amp;&nbsp;primes[i]&nbsp;&#62;&nbsp;0;&nbsp;i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;
&nbsp;&nbsp;&nbsp;&nbsp;allocSiz&nbsp;=&nbsp;sizeof&nbsp;(Dictionary);
&nbsp;&nbsp;&nbsp;&nbsp;memset(Dict,0,allocSiz);
&nbsp;&nbsp;&nbsp;&nbsp;allocSiz&nbsp;=&nbsp;primes[i-1]*sizeof&nbsp;(Dict-&#62;buckets[0]);
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;buckets&nbsp;=&nbsp;CurrentMemoryManager-&#62;malloc(allocSiz);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict-&#62;buckets&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memset(Dict-&#62;buckets,0,allocSiz);
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;size&nbsp;=&nbsp;primes[i-1];
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;hash&nbsp;=&nbsp;hash;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;VTable&nbsp;=&nbsp;&amp;iDictionary;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;ElementSize&nbsp;=&nbsp;elementsize;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;Allocator&nbsp;=&nbsp;CurrentMemoryManager;
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;RaiseError&nbsp;=&nbsp;iError.RaiseError;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Dict;
}

</pre></font>
The primes in the table are the nearest primes to the regular powers of two. Table sizes can range from 509 to more than 130000, what gives a really 
wide range of table sizes. Obviously, bigger tables could be necessary, and other specialized implementations could use the <i>hint</i> parameter
to extend this algorithm or to use a completely different algorithm altogether.

<div class="p"><!----></div>
      <h4><a name="tth_sEc3.3.3">
3.3.3</a>&nbsp;&nbsp;Adding elements</h4>
This operation consists of:

<ul>
<li> hash the key to find a slot
<div class="p"><!----></div>
</li>

<li> go through the list at that slot to see if the key is already there
<div class="p"><!----></div>
</li>

<li> if key is already there replace
<div class="p"><!----></div>
</li>

<li> if key is absent add it in a new list item
<div class="p"><!----></div>
</li>
</ul>
<br />

<div class="p"><!----></div>
<b>Add</b><a 
name="Add+code for \container33"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Add(Dictionary&nbsp;*Dict,const&nbsp;unsigned&nbsp;char&nbsp;*Key,void&nbsp;*Value)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*tmp;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict&nbsp;==&nbsp;NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NullPtrError("Add");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict-&#62;Flags&nbsp;&amp;&nbsp;CONTAINER_READONLY)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ReadOnlyError(Dict,"Add");
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Key&nbsp;==&nbsp;NULL&nbsp;||&nbsp;Value&nbsp;==&nbsp;NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BadArgError(Dict,"Add");
&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;(*Dict-&#62;hash)(Key)&nbsp;%&nbsp;Dict-&#62;size;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(p&nbsp;=&nbsp;Dict-&#62;buckets[i];&nbsp;p;&nbsp;p&nbsp;=&nbsp;p-&#62;Next)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strcmp(Key,&nbsp;p-&#62;Key)&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;Dict-&#62;Allocator-&#62;malloc(sizeof(*p)+Dict-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp&nbsp;=&nbsp;Dict-&#62;Allocator-&#62;malloc(1+strlen((char&nbsp;*)Key));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL&nbsp;||&nbsp;tmp&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p)&nbsp;Dict-&#62;Allocator-&#62;free(p);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tmp)&nbsp;Dict-&#62;Allocator-&#62;free(tmp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NoMemoryError(Dict,"Add");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&#62;Value&nbsp;=&nbsp;(void&nbsp;*)(p+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(tmp,Key);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&#62;Key&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p-&#62;Next&nbsp;=&nbsp;Dict-&#62;buckets[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;buckets[i]&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dict-&#62;count++;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;memcpy((void&nbsp;*)p-&#62;Value,Value,Dict-&#62;ElementSize);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

</pre></font>
Following the logical steps outlined above, we:

<ol type="1">
<li> Call the hash function and use its result modulo the size of the slot table to fetch the list at the indicated slot.
<div class="p"><!----></div>
</li>

<li> See if the key was absent. If that is the case, we need to add a new key. We copy the key and allocate memory for a new list element 
that is initialized afterwards with the copied value of the key and inserted into the list.
<div class="p"><!----></div>
</li>

<li> Copy in the value. If it was a new key, its value is initialized, if the key was already present we overwrite the old contents.
<div class="p"><!----></div>
</li>
</ol>
This function uses strcmp for comparing keys. This has the advantage of simplicity and speed, but in many other contexts a key comparison function 
would be necessary, to allow for keys in Unicode for instance, or for binary keys, for instance a GUID or similar binary data.

<div class="p"><!----></div>
An important design decision was to replace the data associated with a key if the key is already there. This is a decision that has consequences for 
all associative containers, since it must be coherent in all of them. Since the &#207;nsert" function allows for non-destructive insertions, Add was
allowed to replace contents since this is a very common operation for instance in some symbol tables, where &#207;nsert if absent or replace if present"
is used to ensure that a symbol is associated with a certain value. <a href="#tthFtNtAGB" name="tthFrefAGB"><sup>61</sup></a>. At the same time we need a <font size="+1"><tt>Replace</tt></font> function since we want to get an error if the element we want to replace was <b>not</b> found.
A small table makes this clearer

<div class="p"><!----></div>
 
<center>

<table border="1">
<tr><td align="left">Add </td><td align="left">Insert or replace an item for a key </td></tr>
<tr><td align="left">Insert </td><td align="left">Insert, error if the key was present </td></tr>
<tr><td align="left">Replace </td><td align="left">Replace, error if key was absent </td></tr></table>

</center>

<div class="p"><!----></div>
      <h4><a name="tth_sEc3.3.4">
3.3.4</a>&nbsp;&nbsp;Implementing iterators</h4>
Iterators in sequential containers are conceptually easy: just start at the first and stop at the last. In associative containers however things are 
more complicated since there is no obvious way to order them. The solution retained in the sample implementation involves going through all elements
starting at the first element of the slots table, and for each slot go through the linked list of items if any. This guarantees to visit all elements 
in a fixed order. As an example of this here is the <font size="+1"><tt>Apply</tt></font> function that should go through all elements calling the given function for each 
one of them.
<br />

<div class="p"><!----></div>
<b>Apply</b><a 
name="Apply+code for \container33"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Apply(Dictionary&nbsp;*Dict,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*apply)(const&nbsp;char&nbsp;*Key,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;void&nbsp;*Value,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;stamp;
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*p;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NullPtrError("Apply");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(apply&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BadArgError(Dict,"Apply");
&nbsp;&nbsp;&nbsp;&nbsp;stamp&nbsp;=&nbsp;Dict-&#62;timestamp;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;Dict-&#62;size;&nbsp;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(p&nbsp;=&nbsp;Dict-&#62;buckets[i];&nbsp;p;&nbsp;p&nbsp;=&nbsp;p-&#62;Next)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply(p-&#62;Key,p-&#62;Value,&nbsp;ExtraArgs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(Dict-&#62;timestamp&nbsp;!=&nbsp;stamp)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>

<div class="p"><!----></div>
As we outlined above, we start at slot zero, going upwards. If we find a non-empty slot, we go through the linked list of items.

<div class="p"><!----></div>
Iterators are implemented using the same algorithm, and need conceptually two indexes to remember their position: a first index for the slots table, 
and another for the position in the list of items at that slot.

<div class="p"><!----></div>
The implementation of the dictionary iterator is as follows:
<a 
name="iterator+Dictionary33"></a>

<font size=+1><pre>
struct&nbsp;DictionaryIterator&nbsp;{
&nbsp;&nbsp;&nbsp;Iterator&nbsp;it;
&nbsp;&nbsp;&nbsp;Dictionary&nbsp;*Dict;
&nbsp;&nbsp;&nbsp;size_t&nbsp;index;
&nbsp;&nbsp;&nbsp;struct&nbsp;DataList&nbsp;*dl;
&nbsp;&nbsp;&nbsp;size_t&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;long&nbsp;Flags;
};

</pre></font>
The <font size="+1"><tt>index</tt></font> field remembers the position in the slot table, and the <font size="+1"><tt>dl</tt></font> field is just a small structure that contains a link to the 
next item in the linked list and a pointer to the key. Storing the list element itself spare us the work of going through all the list to position ourselves at each advance of the cursor in the list.

     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;The bloom filter</h3>
This container is a completely different beast as all other ones we have in the library. It is a probabilistic data structure. It was conceived by
Mr Burton Howard Bloom in 1970 according to D. E Knuth in his Art of Computer Programming.

<div class="p"><!----></div>
Bloom filters are designed to cheaply test if a given element is in a large set. It is possible that the filter says that an element is there
when in fact, it is not. But if the filter says it is <i>not</i> there you can be ceratin that the element is not in the set.

<div class="p"><!----></div>
You can add elements to the set but not remove them. The more elements you add to the filter, the larger the posibility of getting false positives, i.e.
getting an answer of &#255;es, the element is there" when in fact it is not.

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;Debugging malloc</h3>
<a name="Malloc">
</a>
The library provides a sample of how a malloc used for debugging allocation problems could look like. It is designed to be enhanced and even if it
has several important features like detection of double free and buffer overflows, it is not a competitor for the professional versions you can find
in the market like valgrind or similar.
<br />

<div class="p"><!----></div>
<b>Malloc</b><a 
name="Malloc+code for \container35"></a> <hr />



<font size=+1><pre>
static&nbsp;void&nbsp;*Malloc(size_t&nbsp;size)
{
&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;char&nbsp;*r;
&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;size_t&nbsp;*ip&nbsp;=&nbsp;NULL;

&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;ALIGN_DEFAULT(size);
&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;+=&nbsp;3&nbsp;*&nbsp;sizeof(size_t);
&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;malloc(size);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;AllocatedMemory&nbsp;+=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;r;
&nbsp;&nbsp;&nbsp;&nbsp;*ip++&nbsp;=&nbsp;SIGNATURE;
&nbsp;&nbsp;&nbsp;&nbsp;*ip++&nbsp;=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;memset(ip,&nbsp;0,&nbsp;size&nbsp;-&nbsp;3*sizeof(size_t));
&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;(&amp;r[size&nbsp;-&nbsp;sizeof(size_t)]);
&nbsp;&nbsp;&nbsp;&nbsp;*ip&nbsp;=&nbsp;MAGIC;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(r&nbsp;+&nbsp;2&nbsp;*&nbsp;sizeof(size_t));
}

</pre></font>
The algorithm is as follows:

<ul>
<li> The given size will be aligned to a multiple of <font size="+1"><tt>size_t</tt></font>. It is assumed that this size is the size of a register, and will be 
good for any type of allocation. In some machines this may be completely wrong, for instance for some quantities the Intel processors need an
alignment of 16 bytes, and there is no implementation of <font size="+1"><tt>size_t</tt></font> with that size.
<div class="p"><!----></div>
</li>

<li> We reserve three words more than the requested size to store:

<ol type="1">
<li> The "magic number". This is just an integer that will enable us to ensure that we are dealing with a valid block. Blocks that have this number two 
words below the address passed to our <font size="+1"><tt>Free</tt></font> function will be assumed to be real blocks. There 
is of course a chance that the memory
could contain that number for other reasons, but choosing a value that can't be a pointer and that is high above 100 millions give us a fighting chance 
that the
probablity of hitting a bad positive is fairly low.
<div class="p"><!----></div>
</li>

<li> The length of the block. This will allow us to verify that nothing was written beyond the required length of the block.
<div class="p"><!----></div>
</li>

<li> A guard at the end of the block. We will ensure that we can read this quantity when freeing the block.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li> We obtain memory using <font size="+1"><tt>malloc</tt></font>. If not available we just return&nbsp;NULL .
<div class="p"><!----></div>
</li>

<li> We keep a counter of all memory allocated so far. This counter should be zero at program exit. It helps to detect the leaks between two 
operations: it suffices to note the value of the counter before some part of the software and then see if the counter returns to the
same value after the module has finished.
<div class="p"><!----></div>
</li>

<li> We write the two different integers at the start and at the end of the block, together with its size.
<div class="p"><!----></div>
</li>

<li> We set to zero all memory even if the program didn't ask us. This ensures that any error that accesses uninitialized memory will 
always have the same consequences.
<div class="p"><!----></div>
</li>
</ul>
The other functions that complete this memory manager (free, realloc calloc) are not shown here (they are available in the source code 
of the library). They just undo what <font size="+1"><tt>Malloc</tt></font> has built, calling the error functions if they detect a problem.

<div class="p"><!----></div>
This simple system has several drawbacks.

<ul>
<li> If a buffer &#252;nderflow" happens, i.e. something is written to memory <i>before</i> the start of the block, our field "length" could be
wrong. Depending on the resulting contents of the length field after the overwrite we could have a bogus length and access some invalid memory.
<div class="p"><!----></div>
</li>

<li> Memory overwrites <i>after</i> the magic number that guards the end of the block are not detected. This is obviously impossible to detect
unless we would just inspect each memory write, but a few words more after the end of the block could give us some extra security.
<div class="p"><!----></div>
</li>
</ul>
For completeness here is the code of the free function for the debugging malloc sample:
<br />

<div class="p"><!----></div>
<b>Free</b><a 
name="Free+code for \container35"></a> <hr />



<font size=+1><pre>
&nbsp;1&nbsp;static&nbsp;void&nbsp;Free(void&nbsp;*pp)
&nbsp;2&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;*ip&nbsp;=&nbsp;NULL;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;s;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;char&nbsp;*p&nbsp;=&nbsp;pp;
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(p&nbsp;==&nbsp;NULL)
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;-=&nbsp;2&nbsp;*&nbsp;sizeof(size_t);
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;p;
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*ip&nbsp;==&nbsp;SIGNATURE)&nbsp;{
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ip++&nbsp;=&nbsp;0;
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;*ip;
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip&nbsp;=&nbsp;(size_t&nbsp;*)&nbsp;(&amp;p[s&nbsp;-&nbsp;sizeof(size_t)]);
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*ip&nbsp;!=&nbsp;MAGIC)&nbsp;{
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;overwritten&nbsp;block&nbsp;size&nbsp;*/
16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("Free",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_ERROR_BUFFEROVERFLOW);
17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ip&nbsp;=&nbsp;0;
20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AllocatedMemory&nbsp;-=&nbsp;s;
21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(p,66,s);
22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;free(p);
23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Wrong&nbsp;block&nbsp;passed&nbsp;to&nbsp;Free&nbsp;*/
26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("Free",CONTAINER_ERROR_BADPOINTER);
27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
28&nbsp;}

</pre></font>

<ul>
<li> Line 6:
If we receive a&nbsp;NULL argument is not an error (C99 standard).
<div class="p"><!----></div>
</li>

<li> Line 8:
We seek to the start of the real block and we point to it with a pointer to int (line 9).
<div class="p"><!----></div>
</li>

<li>
If we find the signature we erase the signature immediately (line 11). This avoids that
we ever process this block again. We get in line 12 the size of the block and we point
to the end of it. If we do not find our magic number it has been erased because our
block was somehow overwritten. We report that and stop any further processing.
<div class="p"><!----></div>
</li>

<li>
If we find our magic number all is OK and we free the block. We set it to zero before
to avoid that its data is used again (line 21).
<div class="p"><!----></div>
</li>

<li>
If we do not find the signature after we seek for it we do nothing but report an error:
the block has been overwritten or we have been handed a bogus pointer to our <font size="+1"><tt>free</tt></font>
function. Since our data is written before the start of the block, the software assumes
that it is a bad pointer since in most cases buffer overflows go beyond the end
of the block. It could be that it is actually a buffer overflow error however.
<div class="p"><!----></div>
</li>
</ul>

     <h3><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;The observer interface</h3>
This interface allows arbitrary functions to be called when some interesting event happens.
It supposes several actors that play together:

<ul>
<li> An object that wants to be notified when some event occurs. This object will be represented by
its callback function.
<div class="p"><!----></div>
</li>

<li> An object that emits events and necessary calls the interface to announce them.
<div class="p"><!----></div>
</li>

<li> An associative interface that associates objects with their corresponding
observer functions.
<div class="p"><!----></div>
</li>
</ul>
The observer interface has three entry points:

<ol type="1">
<li> Subscribe. This operation is started by an object that wants to be notified of events
happening in a specific container. It calls the associative interface to be notified
when those events occur.
<div class="p"><!----></div>
</li>

<li> Notify. The container sends events descriptions to the interface. The interface searches
the observer list and if an interested object exists, its associated function is called.
<div class="p"><!----></div>
</li>

<li> Unsubscribe Either the container is going out of scope or the object that receives
the notifications is going out of scope and wants to stop the process. The associative
interface is called to break the event stream. It can be that an either object is no
longer interested in receiving notifications for a specific container without any
change in scope: One of the objects desires to break the relationship.
<div class="p"><!----></div>
</li>
</ol>
The observer object then, is very simple:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_tagObserver&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ObservedObject;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;Callback;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Flags;&nbsp;
}&nbsp;Observer;

</pre></font>
The association is between an observed object (the container) and another unspecified object represented by its
callback here. The flags contain in each bit an event code<a href="#tthFtNtAGC" name="tthFrefAGC"><sup>62</sup></a>. If an observer wants to subscribe to several events
it sets different bits in this field.

<div class="p"><!----></div>
Note that we do not characterize further the observed object: it is just a <font size="+1"><tt>void&nbsp;*</tt></font>. This is not
a great idea since the <font size="+1"><tt>InitObserver</tt></font> function assumes it is a generic container.

<div class="p"><!----></div>
We need a table of this objects because several containers could have several observers defined.

<font size=+1><pre>
static&nbsp;Observer&nbsp;*ObserverVector;
static&nbsp;size_t&nbsp;vsize;

</pre></font>
Now we can start describing the functions themselves
<br />

<div class="p"><!----></div>
<b>Subscribe</b><a 
name="Subscribe+code for \container36"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Subscribe(void&nbsp;*ObservedObject,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback,&nbsp;unsigned&nbsp;flags)
{
&nbsp;&nbsp;&nbsp;&nbsp;Observer&nbsp;result;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r&nbsp;=&nbsp;InitObserver(&amp;result,ObservedObject,callback,flags);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;&#62;&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;AddObject(&amp;result);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;r;
}

</pre></font>
We initialize an observer object, and if that succeeds we add it to the association tables.
We use temporary storage for the initialization because the &#196;ddObserver" function copies
the contents into the table<a href="#tthFtNtAGD" name="tthFrefAGD"><sup>63</sup></a>.
<br />

<div class="p"><!----></div>
<b>InitObserver</b><a 
name="InitObserver+code for \container36"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;InitObserver(Observer&nbsp;*result,void&nbsp;*ObservedObject,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback,&nbsp;unsigned&nbsp;flags)
{
&nbsp;&nbsp;&nbsp;&nbsp;GenericContainer&nbsp;*gen&nbsp;=&nbsp;ObservedObject;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;Subjectflags&nbsp;=&nbsp;gen-&#62;Flags;
&nbsp;&nbsp;&nbsp;&nbsp;Subjectflags&nbsp;|=&nbsp;CONTAINER_HAS_OBSERVER;
&nbsp;&nbsp;&nbsp;&nbsp;gen-&#62;Flags=Subjectflags;
&nbsp;&nbsp;&nbsp;&nbsp;memset(result,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;ObservedObject&nbsp;=&nbsp;ObservedObject;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Callback&nbsp;=&nbsp;callback;
&nbsp;&nbsp;&nbsp;&nbsp;result-&#62;Flags&nbsp;=&nbsp;flags;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector&nbsp;==&nbsp;NULL&nbsp;&amp;&amp;&nbsp;initVector()&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
This function assumes that it receives a container that follows the requirements of generic containers,
i.e. it has a Get/Set flags field. It sets a bit in the flags field that is tested at each function
that modifies the number of elements within the container logic. This means in most machines a bit
test, a very fast operation that should not really affect the speed of the library code in a
significant way.

<div class="p"><!----></div>
A far more important consideration is that the interface is called with a notification for many
functions that the user hasn't subscribed at all. This could be speeded up simply by storing
the flags somewhere in the container, but the sample implementation doesn't go that far. The
reason is that it is assumed that observers are seldom used, and the objects that have an
observer defined are surely heavyweight objects where the slow down caused by the observer
interface is not that significant.

<div class="p"><!----></div>
Of course this assumptions could be very wrong: other, better implementations could decide
otherwise.
<br />

<div class="p"><!----></div>
<b>AddObject</b><a 
name="AddObject+code for \container36"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;&nbsp;AddObject(Observer&nbsp;*ob)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;Observer&nbsp;*tmp;

1:&nbsp;&nbsp;for&nbsp;(i=0;&nbsp;i&lt;vsize;i++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[i].ObservedObject==NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(ObserverVector+i,ob,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
2:&nbsp;&nbsp;tmp&nbsp;=&nbsp;realloc(ObserverVector,(vsize+CHUNK_SIZE)*sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tmp&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iError.RaiseError("iObserver.Subscribe",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CONTAINER_ERROR_NOMEMORY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_NOMEMORY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ObserverVector&nbsp;=&nbsp;tmp;
&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+vsize+1,0,(CHUNK_SIZE-1)*sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;memcpy(ObserverVector+vsize,ob,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;vsize+=&nbsp;CHUNK_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;
}

</pre></font>
The AddObject function is responsible for inserting a new association in the existing table.
First (in <b>1:</b> above) it searches for a free slot. If a free slot is available
it copies the new association into it and returns.

<div class="p"><!----></div>
If there isn't any free slot it attempts to enlarge the table (<b>2:</b>). If an error occurs, the
original table is still valid but no more elements can't be added. It reports the error
and returns with the error code.

<div class="p"><!----></div>
Otherwise all went well, and a new element is inserted.
<br />

<div class="p"><!----></div>
<b>Notify</b><a 
name="Notify+code for \container36"></a> <hr />



<font size=+1><pre>
static&nbsp;int&nbsp;Notify(void&nbsp;*ObservedObject,unsigned&nbsp;operation,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo1,void&nbsp;*ExtraInfo2)
{
&nbsp;&nbsp;&nbsp;int&nbsp;count=0;
&nbsp;&nbsp;&nbsp;size_t&nbsp;idx&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;void&nbsp;*ExtraInfo[2];

&nbsp;&nbsp;&nbsp;ExtraInfo[0]&nbsp;=&nbsp;ExtraInfo1;
&nbsp;&nbsp;&nbsp;ExtraInfo[1]&nbsp;=&nbsp;ExtraInfo2;
&nbsp;&nbsp;&nbsp;for&nbsp;(idx=0;&nbsp;idx&nbsp;&lt;&nbsp;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].ObservedObject&nbsp;==&nbsp;ObservedObject)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].Flags&nbsp;&amp;&nbsp;operation)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverVector[idx].Callback(ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation,ExtraInfo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return&nbsp;count;
}

</pre></font>
This is a simple linear search function. We search for an association that has the same
observed object and in the flags field has a bit set that indicates that is interested in this operation.
If both conditions are true we call the registered function.
<br />

<div class="p"><!----></div>
<b>Unsubscribe</b><a 
name="Unsubscribe+code for \container36"></a> <hr />



<font size=+1><pre>
static&nbsp;size_t&nbsp;Unsubscribe(void&nbsp;*ObservedObject,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverFunction&nbsp;callback)
{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;idx,count=0;

1:&nbsp;&nbsp;if&nbsp;(ObservedObject&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(callback&nbsp;==&nbsp;NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(idx=0;&nbsp;idx&lt;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].Callback&nbsp;==&nbsp;callback)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+idx,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;}
2:&nbsp;&nbsp;if&nbsp;(callback&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(idx=0;idx&lt;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].ObservedObject&nbsp;==&nbsp;ObservedObject)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+idx,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;}
3:&nbsp;&nbsp;for&nbsp;(idx=0;&nbsp;idx&lt;vsize;idx++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ObserverVector[idx].ObservedObject&nbsp;==&nbsp;ObservedObject&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObserverVector[idx].Callback&nbsp;==&nbsp;callback)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(ObserverVector+idx,0,sizeof(Observer));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
}

</pre></font>
Unsubscribe should handle three different situations:

<ul>
<li>The observer object wishes to stop observing. This case is represented by a&nbsp;NULL <font size="+1"><tt>ObservedObject</tt></font> argument meaning that all
observed objects for this callback should be affected. This is handled in the code marked <b>1:</b> above.
<div class="p"><!----></div>
</li>

<li> The observed object (the container) wishes to stop being observed. This case is represented by a&nbsp;NULL <font size="+1"><tt>callback</tt></font> argument, meaning that
all callbacks are affected. This is handled in the code marked <b>2:</b> above.
<div class="p"><!----></div>
</li>

<li> Only a single relationship should be stopped between a single object and a single callback. This is handled in the code marked <b>3:</b> above.
<div class="p"><!----></div>
</li>
</ul>
To erase an item we just set it to zero, supposing that the next time an object subscribes the empty slot will be found and used.
Obviously this method could waste some space in case we ever do only a single relationship in the whole program. The number of slots
that is reserved in the sample implementation is small, to avoid wasting memory in case there are few  observers. More sophisticated
implementations can add features here.

     <h3><a name="tth_sEc3.7">
3.7</a>&nbsp;&nbsp;ValArrays</h3>
<a 
name="ValArrays,code37"></a>
All ValArrays are implemented using a template file that receives its parameters from a small c file. The same is done for the header files, that
are also controlled by a header file. Since header files do not contain any definitions, only declarations, the different headers are grouped into
a single header file that includes the templated file several times. Here is an excertp of valarray.h:

<font size=+1><pre>
&nbsp;&nbsp;1&nbsp;/**********************************************&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;2&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ValArraySize_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;3&nbsp;&nbsp;*************************************************/&nbsp;
&nbsp;&nbsp;4&nbsp;#undef&nbsp;ElementType
&nbsp;&nbsp;5&nbsp;#undef&nbsp;ValArrayInterface
&nbsp;&nbsp;6&nbsp;#undef&nbsp;ElementType
&nbsp;&nbsp;7&nbsp;#undef&nbsp;ValArray
&nbsp;&nbsp;9&nbsp;#undef&nbsp;_ValArray
&nbsp;10&nbsp;#define&nbsp;ValArray&nbsp;ValArraySize_t
&nbsp;11&nbsp;#define&nbsp;ElementType&nbsp;size_t
&nbsp;12&nbsp;#define&nbsp;ValArrayInterface&nbsp;ValArraySize_tInterface
&nbsp;13&nbsp;#define&nbsp;__IS_UNSIGNED__
&nbsp;14&nbsp;#define&nbsp;__IS_INTEGER__
&nbsp;15&nbsp;#include&nbsp;"valarraygen.h"
&nbsp;16&nbsp;#undef&nbsp;__IS_UNSIGNED__
&nbsp;17&nbsp;#undef&nbsp;__IS_INTEGER__
&nbsp;18&nbsp;extern&nbsp;ValArraySize_tInterface&nbsp;iValArraySize_t;
&nbsp;

</pre></font>
Lines 4-9 remove a possible previous definition of the parameters we are going to use for valarraygen.h. Then we start defining the parameters:

<ul>
<li> <font size="+1"><tt>_ValArray</tt></font> is <font size="+1"><tt>ValArraySize_t</tt></font> (line 10)
<div class="p"><!----></div>
</li>

<li> The <font size="+1"><tt>ElementType</tt></font> parameter is the actual type of the elements to be stored into each ValArray.
<div class="p"><!----></div>
</li>

<li> Lines 13 and 14 define symbols used to test for certain attributes within valarraygen.h. Some functions are defined in types that 
correspond to those attributes and omitted in the types where they are not. The attributes defined are:

<ul>
<li> Unsigned. This encloses all unsigned types. In these types bitwise operations are legal.
<div class="p"><!----></div>
</li>

<li> Integer. This encloses all integer types. The <font size="+1"><tt>mod</tt></font> operation is defined for these types.
<div class="p"><!----></div>
</li>

<li> Not Integer implies float. Operations like <font size="+1"><tt>fcmp</tt></font> are defined only for floats.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> All parameters defined, we can include the valarraygen.h file. This file uses the defines above to define the interface data structure.
<div class="p"><!----></div>
</li>

<li> The really end user visible name is at line 19: the name of the interface.
<div class="p"><!----></div>
</li>
</ul>
The valarraygen.h (gen for <b>gen</b>eric) defines the interfaces for all the parameter types.
Here is a small part of it so that you get the idea:

<font size=+1><pre>
typedef&nbsp;struct&nbsp;_ValArray&nbsp;ValArray;
typedef&nbsp;struct&nbsp;tagValArray&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;(*Size)(const&nbsp;ValArray&nbsp;*AL);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Contains)(ValArray&nbsp;*AL,ElementType&nbsp;data);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;(*Erase)(ValArray&nbsp;*AL,ElementType&nbsp;elem);
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;snip
}&nbsp;ValArrayInterface;

</pre></font>
In a very similar way, the generic ValArray containers for all basic types are organized in a small parameter file "valarrayint.c", "valarraydouble.c"
and others that make the necessary defines so that the underlying valarraygen.c defines a function for each required basic type.
Programming in valarraygen.c is fairly simple. Here is a function that is parametrized by the <font size="+1"><tt>ElementType</tt></font> macro:

<font size=+1><pre>
static&nbsp;ElementType&nbsp;GetElement(const&nbsp;ValArray&nbsp;*AL,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;start=0,incr=1,top=AL-&#62;count;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Slice)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;AL-&#62;Slice-&#62;start;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;incr&nbsp;=&nbsp;AL-&#62;Slice-&#62;increment;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;=&nbsp;AL-&#62;Slice-&#62;length;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=top&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IndexError("GetElement");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MinElementType;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;start+idx*incr;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AL-&#62;contents[idx];
}

</pre></font>
We see here:

<ul>
<li> Slice management. All operations in a ValArray are constrained by the current slice, that starts with a slice that encloses the whole array 
(the start is zero, the increment is one, and the length of the slice is the length of the array). When a slice is defined for an array, it will be
used, if not, an implicit slice is used that includes the whole array.
<div class="p"><!----></div>
</li>

<li> Error analysis is simplified for ValArrays, and no&nbsp;NULL checking is done. However hard errors like an index error (trying to index an aray beyond
its bounds) are always reported.
<div class="p"><!----></div>
</li>

<li> Contrary to the <font size="+1"><tt>GetElement</tt></font> function in the <font size="+1"><tt>vector</tt></font> container we do not return a pointer to the element but the element
itself. For the basic types this can always be done and is very efficient. For more complex types use <font size="+1"><tt>vector</tt></font> instead of <font size="+1"><tt>ValArray</tt></font>.
<div class="p"><!----></div>
</li>
</ul>
The <font size="+1"><tt>valarraygen.c</tt></font> file can be used to provide for an array of actually <b>any</b> data structure that is small enough to be returned by value.
It suffices to change the <font size="+1"><tt>ElementType</tt></font> to the concerned structure whose definition must be visible to the compiler. In the next chapter we see how this
could be done.

<div class="p"><!----></div>

 <h1><a name="tth_chAp9">
Chapter 9 </a><br />Building generic components</h1>

<div class="p"><!----></div>
If you take the source code of a container like &#228;rraylist", for instance, you will notice that all those "void *&#228;re actually a single type, i.e. the type of the objects being stored in the container.  All generic containers use "void *" as the type under which the objects are stored so that the same code works with many different types.

<div class="p"><!----></div>
Obviously another way is possible. You could actually replace the object type within that code and build a family of functions and types that can be specialized by its type parameter. For instance:

<font size=+1><pre>
struct&nbsp;tag$(TYPE)ArrayInterface;
typedef&nbsp;struct&nbsp;_$(TYPE)Array&nbsp;{
&nbsp;&nbsp;&nbsp;struct&nbsp;tag$(TYPE)ArrayInterface&nbsp;*VTable;&nbsp;
&nbsp;&nbsp;&nbsp;size_t&nbsp;count;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;
&nbsp;&nbsp;&nbsp;$(TYPE)&nbsp;*contents;
&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;
&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;CompareFn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
}&nbsp;$(TYPE)_Array&nbsp;;

</pre></font>
Now, if we just substitute <b> <font size="+1"><tt>$(TYPE)</tt></font></b> with <b>"double"</b> in the code above, we obtain:

<div class="p"><!----></div>

<font size=+1><pre>
struct&nbsp;tagdoubleArrayInterface;
typedef&nbsp;struct&nbsp;_doubleArray&nbsp;{
&nbsp;&nbsp;&nbsp;struct&nbsp;tagdoubleArrayInterface&nbsp;*VTable;&nbsp;
&nbsp;&nbsp;&nbsp;size_t&nbsp;count;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;Flags;
&nbsp;&nbsp;&nbsp;double&nbsp;*contents;
&nbsp;&nbsp;&nbsp;size_t&nbsp;capacity;
&nbsp;&nbsp;&nbsp;size_t&nbsp;ElementSize;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;timestamp;
&nbsp;&nbsp;&nbsp;CompareFunction&nbsp;CompareFn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ErrorFunction&nbsp;RaiseError;
}&nbsp;double_Array&nbsp;;

</pre></font>

<div class="p"><!----></div>
We use the name of the parameter to build a family of names, and we use the name of the type parameter to declare an array of elements of that specific type as the contents of the array. This double usage allows us to build different name spaces for each different array type, so that we can declare arrays of different types without problems.

<div class="p"><!----></div>
Using the same pattern, we can build a family of functions for this container that is specialized to a concrete type of element. For instance we can write:

<div class="p"><!----></div>

<font size=+1><pre>
static&nbsp;int&nbsp;EraseAt($(TYPE)_Array&nbsp;*AL,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(TYPE)&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=&nbsp;AL-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;AL_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;AL-&#62;contents+idx;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&lt;&nbsp;(AL-&#62;count-1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove(p,p+1,(AL-&#62;count-idx)*sizeof($(TYPE)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AL-&#62;count;
}

</pre></font>

<div class="p"><!----></div>
when transformed, the function above becomes:

<div class="p"><!----></div>

<font size=+1><pre>
static&nbsp;int&nbsp;EraseAt(double_Array&nbsp;*AL,size_t&nbsp;idx)
{
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;*p;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&#62;=&nbsp;AL-&#62;count)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_INDEX;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;Flags&nbsp;&amp;&nbsp;AL_READONLY)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;CONTAINER_ERROR_READONLY;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(AL-&#62;count&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-2;
&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;AL-&#62;contents+idx;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(idx&nbsp;&lt;&nbsp;(AL-&#62;count-1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove(p,p+1,(AL-&#62;count-idx)*sizeof(double));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;count--;
&nbsp;&nbsp;&nbsp;&nbsp;AL-&#62;timestamp++;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;AL-&#62;count;
}

</pre></font>

<div class="p"><!----></div>
Now we can build a simple program in C that will do the substitution work for us. To make things easier, that program should build two files:

<ul>
<li> The header file, that will contain the type definitions for our array.
<div class="p"><!----></div>
</li>

<li> The C source file, containing all the parametrized function definitions.
<div class="p"><!----></div>
</li>
</ul>
We separate the commands to change the name of the file from the rest of the text by introducing in the first positions of a line a sequence of three or more @ signs.  Normally we will have two of those "commands": one for the header file, another for the c file.

<div class="p"><!----></div>
Besides that, our program is just a plain text substitution. No parsing, nor anything else is required. If we write <font size="+1"><tt>"$(TYPE)"</tt></font> within a comment or a character string, it will be changed too.

<font size=+1><pre>
#include&nbsp;&lt;stdlib.h&#62;
#include&nbsp;&lt;string.h&#62;
#include&nbsp;&lt;stdio.h&#62;

#define&nbsp;MAXLINE_LEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2048
#define&nbsp;MAX_FNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1024
#define&nbsp;EXPANSION_LENGTH&nbsp;256

int&nbsp;main(int&nbsp;argc,char&nbsp;*argv[])
{
&nbsp;&nbsp;&nbsp;FILE&nbsp;*input,*output=NULL;
&nbsp;&nbsp;&nbsp;char&nbsp;buf[MAXLINE_LEN],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpLine[MAXLINE_LEN+EXPANSION_LENGTH];
&nbsp;&nbsp;&nbsp;char&nbsp;tmpBuf[MAX_FNAME];
&nbsp;&nbsp;&nbsp;char&nbsp;outputFile[MAX_FNAME];
&nbsp;&nbsp;&nbsp;char&nbsp;*TypeDefinition;
&nbsp;&nbsp;&nbsp;unsigned&nbsp;lineno&nbsp;=&nbsp;1;

&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Usage:&nbsp;%s&nbsp;&lt;template&nbsp;file&nbsp;to&nbsp;expand&#62;&nbsp;&lt;type&nbsp;name&#62;\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_FAILURE;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;input&nbsp;=&nbsp;fopen(argv[1],"r");
&nbsp;&nbsp;&nbsp;if&nbsp;(input&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"Unable&nbsp;to&nbsp;open&nbsp;file&nbsp;'%s'\n",argv[1]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_FAILURE;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;TypeDefinition&nbsp;=&nbsp;argv[2];
&nbsp;&nbsp;&nbsp;while&nbsp;(fgets(buf,sizeof(buf)-1,input))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf[0]=='@'&nbsp;&amp;&amp;&nbsp;buf[1]&nbsp;==&nbsp;'@'&nbsp;&amp;&amp;&nbsp;buf[2]&nbsp;==&nbsp;'@')&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i=0,j=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(buf[i]&nbsp;&nbsp;==&nbsp;'@')
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(buf[i]&nbsp;!=&nbsp;0&nbsp;&amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf[i]&nbsp;!=&nbsp;'\n'&nbsp;&amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;&lt;&nbsp;MAX_FNAME-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpBuf[j++]&nbsp;=&nbsp;buf[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpBuf[j]&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strrepl(tmpBuf,"$(TYPE)",TypeDefinition,NULL))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,"File&nbsp;name&nbsp;'%s'&nbsp;too&nbsp;long\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpBuf);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_FAILURE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strrepl(tmpBuf,"$(TYPE)",TypeDefinition,outputFile);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output&nbsp;!=&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(output);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output&nbsp;=&nbsp;fopen(outputFile,"w");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Impossible&nbsp;to&nbsp;open&nbsp;'%s'\n",outputFile);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(EXIT_FAILURE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(lineno&nbsp;==&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Error:&nbsp;First&nbsp;line&nbsp;should&nbsp;contain&nbsp;the&nbsp;file&nbsp;name\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Normal&nbsp;lines&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(strrepl(buf,"$(TYPE)",TypeDefinition,NULL)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#62;=&nbsp;sizeof(tmpLine))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Line&nbsp;buffer&nbsp;overflow&nbsp;line&nbsp;%d\n",lineno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strrepl(buf,"$(TYPE)",TypeDefinition,tmpLine);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fwrite(tmpLine,1,strlen(tmpLine),output);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineno++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(input);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fclose(output);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EXIT_SUCCESS;
}

</pre></font>
The heart of this program is the &#223;trrepl" function that replaces a given character string in a piece of text. If you call it with a&nbsp;NULL output parameter, it will return the number of characters that the replacement would need if any. For completeness, here is the code for strrepl:

<font size=+1><pre>
int&nbsp;strrepl(const&nbsp;char&nbsp;*InputString,&nbsp;const&nbsp;char&nbsp;*StringToFind,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*StringToReplace,&nbsp;char&nbsp;*output)
{
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*offset&nbsp;=&nbsp;NULL,&nbsp;*CurrentPointer&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;insertlen;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;findlen&nbsp;=&nbsp;strlen(StringToFind);
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(StringToReplace)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertlen&nbsp;=&nbsp;strlen(StringToReplace);
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertlen&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output&nbsp;!=&nbsp;InputString)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove(output,InputString,strlen(InputString)+1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputString&nbsp;=&nbsp;output;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;strlen(InputString)+1;

&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*InputString)&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;offset&nbsp;=&nbsp;strstr&nbsp;(!offset&nbsp;?&nbsp;InputString&nbsp;:&nbsp;CurrentPointer,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringToFind);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(offset&nbsp;==&nbsp;NULL)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CurrentPointer&nbsp;=&nbsp;(offset&nbsp;+&nbsp;(output&nbsp;?&nbsp;insertlen&nbsp;:&nbsp;findlen));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(output)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy&nbsp;(offset,&nbsp;(offset&nbsp;+&nbsp;findlen));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memmove&nbsp;(offset&nbsp;+&nbsp;insertlen,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset,&nbsp;strlen&nbsp;(offset)&nbsp;+&nbsp;1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(insertlen)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy&nbsp;(offset,&nbsp;StringToReplace,&nbsp;insertlen);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;-=&nbsp;findlen;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;insertlen;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;
}

</pre></font>

<div class="p"><!----></div>
And now we are done. The usage of this program is very simple:
 
<font size=+1><pre>
&nbsp;&nbsp;&nbsp;expand&nbsp;&lt;template&nbsp;file&#62;&nbsp;&lt;type&nbsp;name&#62;

</pre></font>

<div class="p"><!----></div>
For instance to substitute by "double" in the template file &#228;rraylist.tpl" we would use:

<div class="p"><!----></div>

<font size=+1><pre>
&nbsp;&nbsp;&nbsp;expand&nbsp;arraylist.tpl&nbsp;double

</pre></font>

<div class="p"><!----></div>
We would obtain doublearray.h and doublearray.c

<div class="p"><!----></div>
BUG: Obviously, this supposes that the type name does NOT contain  any spaces or other characters like '*' or "[  ]". If you want to use types with those characters you should substitute them with a "_" for instance, and make a typedef:

<div class="p"><!----></div>
<font size="+1"><tt>typedef long double long_double;</tt></font>

<div class="p"><!----></div>
And use that type ("long_double") as the substitution type.
<BR CLEAR=LEFT><BR><BR>


<center>
API Overview
</center>

<br />
<a 
name="API Overview07"></a>

<div class="p"><!----></div>
Here is a table of all functions of the library. It indicates which functions are implemented in each container. Some containers are fused 
together since they implement exactly the same functions: all the <font size="+1"><tt>ValArray</tt></font> containers are displayed in a single column, the containers 
<font size="+1"><tt>StringList</tt></font> and <font size="+1"><tt>wStringList</tt></font> share the same column also.



<font size="-2">


<div class="p"><!----></div>
<a name="tth_tAb1">
</a> 
<center>      
<table border="1">
<tr><td align="left"><b>Function</b>  </td><td align="center"><b>List</b> </td><td align="center"><b>Dlist</b> </td><td align="center"><b>String</b> </td><td align="center"><b>Vector</b> </td><td align="center"><b>Value</b> </td><td align="center"><b>Bit-</b> </td><td align="center"><b>String</b> </td><td align="center"><b>Queue</b> </td><td align="center"><b>Deque</b> </td><td align="center"><b>Dict.</b> </td><td align="center"><b>Hash</b> </td><td align="center"><b>Tree</b> 
</td></tr>
<tr><td align="left"><b>Name</b></td><td align="center"></td><td align="center"></td><td align="center"><b>list</b> </td><td align="center"></td><td align="center"><b>Array</b> </td><td align="center"><b>string</b> </td><td align="center"><b>Collection</b> </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"><b>Table</b> </td><td align="center"><b>Map</b> 
</td></tr>
<tr><td align="left"></td></tr>
<tr><td></td></tr>
<tr><td align="left">
Abs                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Accumulate          	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Add                 	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">AddRange            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td align="left">And                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">AndAssign           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">AndScalar           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Append              	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Apply               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Back                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">BitBlockCount       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">BitLeftShift        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">BitRightShift       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CastToArray         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Clear               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Compare             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CompareEqual        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CompareEqualScalar  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CompareScalar       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Contains            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Copy                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">CopyBits            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CopyElement         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CopyTo              	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Create              	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">CreateFromFile      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CreateSequence      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">CreateWithAllocator 	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td></tr>
<tr><td align="left">Dequeue             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">DivideBy            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">DivideByScalar      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">DivideScalarBy      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Enqueue             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Equal               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td></tr>
<tr><td align="left">Erase               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">EraseAll            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">EraseAt             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">EraseRange          	</td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">FCompare            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">FillSequential      	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Finalize            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">FindFirst           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">FindNext            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">FindText            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">FindTextIndex       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">FindTextPositions   	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">ForEach             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Fprintf             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Front               	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">GetAllocator        	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td></tr>
<tr><td align="left">GetCapacity         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">GetData             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">GetElement          	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">GetElementSize      	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">GetFlags            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">GetKeys             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">GetRange            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">GetSlice            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">IndexIn             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">IndexOf             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Init                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td></tr>
<tr><td align="left">InitIterator        	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">InitWithAllocator   	</td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">InitializeWith      	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td></tr>
<tr><td align="left">Insert              	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td></tr>
<tr><td align="left">InsertAt            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">InsertIn            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Inverse             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">LessEqual           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Load                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Max                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Memset              	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Min                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Mismatch            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Mod                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">ModScalar           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">MultiplyWith        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">MultiplyWithScalar  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">NewIterator         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Not                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">NotAssign           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Or                  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">OrAssign            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">OrScalar            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">PopBack             	</td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">PopFront            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">PopulationCount     	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Print               	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Product             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">PushBack            	</td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">PushFront           	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">RemoveRange         	</td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Replace             	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td></tr>
<tr><td align="left">ReplaceAt           	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">ResetSlice          	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Resize              	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td></tr>
<tr><td align="left">Reverse             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">RotateLeft          	</td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">RotateRight         	</td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Save                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Search              	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td></tr>
<tr><td align="left">SearchWithKey       	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Select              	</td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SelectCopy          	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SetAllocator        	</td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SetCapacity         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SetCompareFunction  	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td></tr>
<tr><td align="left">SetDestructor       	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">SetElement          	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SetErrorFunction    	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">SetFlags            	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">SetHashFunction     	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td></tr>
<tr><td align="left">SetSlice            	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Size                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Sizeof              	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">SizeofIterator      	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td></tr>
<tr><td align="left">Sort                	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Splice              	</td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">StringToBitString   	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SubtractFrom        	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SubtractFromScalar  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SubtractScalarFrom  	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SumScalarTo         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">SumTo               	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">UseHeap             	</td><td align="center"> X </td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">WriteToFile         	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Xor                 	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">XorAssign           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">XorScalar           	</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"> X </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">Totals              	</td><td align="center">52</td><td align="center">49</td><td align="center">48</td><td align="center">59</td><td align="center">92</td><td align="center">55</td><td align="center">65</td><td align="center">11</td><td align="center">28</td><td align="center">34</td><td align="center">26</td><td align="center">28</td></tr>
<tr><td align="left">Total APIs          	</td><td align="center">547 </td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="left">

<div class="p"><!----></div>
</tr><tr><td></td></tr></table>
</center>
<div class="p"><!----></div>
</font><a name="tth_sEcindex"></a>

<h2> Index (showing section)</h2>

<table width="100%"><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Abs</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Abs+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Accumulate</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Accumulate+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Add</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Add+\container11">1.1</a>, 
		<a href="#Add+\container32">3.2</a>, 
		<a href="#Add+\container42">4.2</a>, 
		<a href="#Add+\container62">6.2</a>, 
		<a href="#Add+\container82">8.2</a>, 
		<a href="#Add+\container112">11.2</a>, 
		<a href="#Add+\container123">12.3</a>, 
		<a href="#Add+\container132">13.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Add+code for \container31">3.1</a>, 
		<a href="#Add+code for \container33">3.3</a></dd>
 <dt><b></b></dt>
	<dd>AddObject</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#AddObject+code for \container36">3.6</a></dd>
 <dt><b></b></dt>
	<dd>AddRange</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#AddRange+\container11">1.1</a>, 
		<a href="#AddRange+\container32">3.2</a>, 
		<a href="#AddRange+\container52">5.2</a>, 
		<a href="#AddRange+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#AddRange+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>AddToFreeList</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#AddToFreeList+\container22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>Alloc</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Alloc+\container30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>And</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#And+\container12">1.2</a>, 
		<a href="#And+\container42">4.2</a>, 
		<a href="#And+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>AndAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#AndAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>API Overview, <a href="#API Overview07">0.7</a></dd>
 <dt><b></b></dt>
	<dd>Append</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Append+\container11">1.1</a>, 
		<a href="#Append+\container32">3.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Append+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Apply</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Apply+\container11">1.1</a>, 
		<a href="#Apply+\container32">3.2</a>, 
		<a href="#Apply+\container62">6.2</a>, 
		<a href="#Apply+\container82">8.2</a>, 
		<a href="#Apply+\container101">10.1</a>, 
		<a href="#Apply+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Apply+code for \container31">3.1</a>, 
		<a href="#Apply+code for \container33">3.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; general, <a href="#Apply+general112">11.2</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Back</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Back+\container11">1.1</a>, 
		<a href="#Back+\container32">3.2</a>, 
		<a href="#Back+\container92">9.2</a>, 
		<a href="#Back+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Back+code for \container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>BitBlockCount</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#BitBlockCount+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>BitLeftShift</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#BitLeftShift+\container42">4.2</a>, 
		<a href="#BitLeftShift+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>BitRightShift</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#BitRightShift+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>BitString, <a href="#BitString40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>Bloomfilter, <a href="#Bloomfilter110">11.0</a></dd>
 <dt><b></b></dt>
	<dd>Buffers, <a href="#Buffers130">13.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>CalculateSpace</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CalculateSpace+\container112">11.2</a></dd>
 <dt><b></b></dt>
	<dd>Calloc</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Calloc+\container30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>CastToArray</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CastToArray+\container52">5.2</a>, 
		<a href="#CastToArray+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>Clear</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Clear+\container11">1.1</a>, 
		<a href="#Clear+\container12">1.2</a>, 
		<a href="#Clear+\container30">3.0</a>, 
		<a href="#Clear+\container32">3.2</a>, 
		<a href="#Clear+\container62">6.2</a>, 
		<a href="#Clear+\container82">8.2</a>, 
		<a href="#Clear+\container101">10.1</a>, 
		<a href="#Clear+\container112">11.2</a>, 
		<a href="#Clear+\container123">12.3</a>, 
		<a href="#Clear+\container131">13.1</a>, 
		<a href="#Clear+\container132">13.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Clear+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Compare</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Compare+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>CompareEqual</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CompareEqual+\container32">3.2</a>, 
		<a href="#CompareEqual+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>CompareEqualScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CompareEqualScalar+\container32">3.2</a>, 
		<a href="#CompareEqualScalar+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>CompareFunction, <a href="#CompareFunction52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>CompareScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CompareScalar+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Contains</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Contains+\container11">1.1</a>, 
		<a href="#Contains+\container32">3.2</a>, 
		<a href="#Contains+\container62">6.2</a>, 
		<a href="#Contains+\container101">10.1</a>, 
		<a href="#Contains+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Contains+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Copy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Copy+\container11">1.1</a>, 
		<a href="#Copy+\container12">1.2</a>, 
		<a href="#Copy+\container32">3.2</a>, 
		<a href="#Copy+\container62">6.2</a>, 
		<a href="#Copy+\container82">8.2</a>, 
		<a href="#Copy+\container101">10.1</a>, 
		<a href="#Copy+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Copy+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>CopyBits</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CopyBits+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>CopyElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CopyElement+\container11">1.1</a>, 
		<a href="#CopyElement+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#CopyElement+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>CopyTo</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CopyTo+\container32">3.2</a>, 
		<a href="#CopyTo+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Create</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Create+\container11">1.1</a>, 
		<a href="#Create+\container12">1.2</a>, 
		<a href="#Create+\container22">2.2</a>, 
		<a href="#Create+\container30">3.0</a>, 
		<a href="#Create+\container32">3.2</a>, 
		<a href="#Create+\container62">6.2</a>, 
		<a href="#Create+\container82">8.2</a>, 
		<a href="#Create+\container101">10.1</a>, 
		<a href="#Create+\container112">11.2</a>, 
		<a href="#Create+\container123">12.3</a>, 
		<a href="#Create+\container131">13.1</a>, 
		<a href="#Create+\container132">13.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Create+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>CreateFromFile</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CreateFromFile+\container52">5.2</a>, 
		<a href="#CreateFromFile+\container131">13.1</a></dd>
 <dt><b></b></dt>
	<dd>CreateFromMask</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CreateFromMask+\container12">1.2</a></dd>
 <dt><b></b></dt>
	<dd>CreateSequence</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CreateSequence+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>CreateWithAllocator, <a href="#CreateWithAllocator62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#CreateWithAllocator+\container11">1.1</a>, 
		<a href="#CreateWithAllocator+\container32">3.2</a>, 
		<a href="#CreateWithAllocator+\container131">13.1</a>, 
		<a href="#CreateWithAllocator+\container132">13.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#CreateWithAllocator+code for \container31">3.1</a>, 
		<a href="#CreateWithAllocator+code for \container32">3.2</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>DefaultListCompareFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#DefaultListCompareFunction+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>DefaultListLoadFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#DefaultListLoadFunction+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>DefaultSaveFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#DefaultSaveFunction+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>deleteIterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#deleteIterator+\container11">1.1</a>, 
		<a href="#deleteIterator+\container32">3.2</a>, 
		<a href="#deleteIterator+\container62">6.2</a>, 
		<a href="#deleteIterator+\container82">8.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#deleteIterator+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Deque, <a href="#Deque100">10.0</a></dd>
 <dt><b></b></dt>
	<dd>DestroyFreeList</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#DestroyFreeList+\container22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>DestructorFunction, <a href="#DestructorFunction56">5.6</a></dd>
 <dt><b></b></dt>
	<dd>Dictionary, <a href="#Dictionary60">6.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Dictionary+structure25">2.5</a></dd>
 <dt><b></b></dt>
	<dd>DivideBy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#DivideBy+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>DivideByScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#DivideByScalar+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>DivideScalarBy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#DivideScalarBy+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Dlist, <a href="#Dlist20">2.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Dlist+structure23">2.3</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>EmptyErrorFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#EmptyErrorFunction+\container40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>Equal</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Equal+\container11">1.1</a>, 
		<a href="#Equal+\container32">3.2</a>, 
		<a href="#Equal+\container62">6.2</a>, 
		<a href="#Equal+\container101">10.1</a>, 
		<a href="#Equal+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Equal+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Erase</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Erase+\container11">1.1</a>, 
		<a href="#Erase+\container32">3.2</a>, 
		<a href="#Erase+\container62">6.2</a>, 
		<a href="#Erase+\container82">8.2</a>, 
		<a href="#Erase+\container101">10.1</a>, 
		<a href="#Erase+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Erase+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>EraseAll</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#EraseAll+\container11">1.1</a>, 
		<a href="#EraseAll+\container32">3.2</a>, 
		<a href="#EraseAll+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>EraseAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#EraseAt+\container11">1.1</a>, 
		<a href="#EraseAt+\container32">3.2</a>, 
		<a href="#EraseAt+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>EraseRange</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#EraseRange+\container11">1.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#EraseRange+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>error-codes, <a href="#error-codes30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>ErrorFunction, <a href="#ErrorFunction55">5.5</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>FCompare</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#FCompare+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>FillSequential</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#FillSequential+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Finalize</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Finalize+\container11">1.1</a>, 
		<a href="#Finalize+\container12">1.2</a>, 
		<a href="#Finalize+\container22">2.2</a>, 
		<a href="#Finalize+\container30">3.0</a>, 
		<a href="#Finalize+\container32">3.2</a>, 
		<a href="#Finalize+\container62">6.2</a>, 
		<a href="#Finalize+\container101">10.1</a>, 
		<a href="#Finalize+\container112">11.2</a>, 
		<a href="#Finalize+\container123">12.3</a>, 
		<a href="#Finalize+\container131">13.1</a>, 
		<a href="#Finalize+\container132">13.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Finalize+code for \container31">3.1</a>, 
		<a href="#Finalize+code for \container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>Find</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Find+\container112">11.2</a></dd>
 <dt><b></b></dt>
	<dd>FindFirst</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#FindFirst+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>FindNext</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#FindNext+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>FindTextPositions</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#FindTextPositions+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>ForEach</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#ForEach+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Fprintf</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Fprintf+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Free</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Free+code for \container35">3.5</a></dd>
 <dt><b></b></dt>
	<dd>Front</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Front+\container11">1.1</a>, 
		<a href="#Front+\container32">3.2</a>, 
		<a href="#Front+\container52">5.2</a>, 
		<a href="#Front+\container92">9.2</a>, 
		<a href="#Front+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Front+code for \container32">3.2</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Generic Container</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Generic Container+structure21">2.1</a></dd>
 <dt><b></b></dt>
	<dd>GetAllocator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetAllocator+\container11">1.1</a>, 
		<a href="#GetAllocator+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>GetCapacity</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetCapacity+\container32">3.2</a>, 
		<a href="#GetCapacity+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>GetCurrent</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetCurrent+\container51">5.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#GetCurrent+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>GetData</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetData+\container32">3.2</a>, 
		<a href="#GetData+\container42">4.2</a>, 
		<a href="#GetData+\container92">9.2</a>, 
		<a href="#GetData+\container123">12.3</a>, 
		<a href="#GetData+\container131">13.1</a></dd>
 <dt><b></b></dt>
	<dd>GetElement</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetElement+\container11">1.1</a>, 
		<a href="#GetElement+\container32">3.2</a>, 
		<a href="#GetElement+\container62">6.2</a>, 
		<a href="#GetElement+\container82">8.2</a>, 
		<a href="#GetElement+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>GetElementSize</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetElementSize+\container11">1.1</a>, 
		<a href="#GetElementSize+\container32">3.2</a>, 
		<a href="#GetElementSize+\container62">6.2</a>, 
		<a href="#GetElementSize+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>GetFirst</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetFirst+\container51">5.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#GetFirst+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>GetFlags</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetFlags+\container62">6.2</a>, 
		<a href="#GetFlags+\container82">8.2</a>, 
		<a href="#GetFlags+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#GetFlags+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>GetFlags / SetFlags</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetFlags / SetFlags+\container11">1.1</a>, 
		<a href="#GetFlags / SetFlags+\container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>GetLast</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetLast+\container51">5.1</a></dd>
 <dt><b></b></dt>
	<dd>GetNext</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetNext+\container51">5.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#GetNext+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>GetPosition</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetPosition+\container131">13.1</a></dd>
 <dt><b></b></dt>
	<dd>GetPrevious</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetPrevious+\container51">5.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#GetPrevious+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>GetRange</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetRange+\container11">1.1</a>, 
		<a href="#GetRange+\container32">3.2</a>, 
		<a href="#GetRange+\container42">4.2</a>, 
		<a href="#GetRange+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#GetRange+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>GetSlice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#GetSlice+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>guid, <a href="#guid31">3.1</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>hash</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#hash+code for \container33">3.3</a></dd>
 <dt><b></b></dt>
	<dd>HashTable, <a href="#HashTable80">8.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>iAssociativeContainer, <a href="#iAssociativeContainer143">14.3</a></dd>
 <dt><b></b></dt>
	<dd>iBitString, <a href="#iBitString41">4.1</a></dd>
 <dt><b></b></dt>
	<dd>iDeque, <a href="#iDeque101">10.1</a></dd>
 <dt><b></b></dt>
	<dd>iDictionary, <a href="#iDictionary61">6.1</a></dd>
 <dt><b></b></dt>
	<dd>iDlist, <a href="#iDlist20">2.0</a></dd>
 <dt><b></b></dt>
	<dd>iError, <a href="#iError40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>iGenericContainer, <a href="#iGenericContainer141">14.1</a></dd>
 <dt><b></b></dt>
	<dd>iHashTable, <a href="#iHashTable81">8.1</a></dd>
 <dt><b></b></dt>
	<dd>iHeap, <a href="#iHeap22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>iList, <a href="#iList10">1.0</a></dd>
 <dt><b></b></dt>
	<dd>IndexIn</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#IndexIn+\container32">3.2</a>, 
		<a href="#IndexIn+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>IndexOf</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#IndexOf+\container11">1.1</a>, 
		<a href="#IndexOf+\container32">3.2</a>, 
		<a href="#IndexOf+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#IndexOf+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Init</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Init+\container11">1.1</a>, 
		<a href="#Init+\container52">5.2</a>, 
		<a href="#Init+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Init+code for \container31">3.1</a>, 
		<a href="#Init+code for \container33">3.3</a></dd>
 <dt><b></b></dt>
	<dd>InitHeap</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#InitHeap+\container22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>InitializeWith</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#InitializeWith+\container11">1.1</a>, 
		<a href="#InitializeWith+\container42">4.2</a>, 
		<a href="#InitializeWith+\container62">6.2</a>, 
		<a href="#InitializeWith+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>InitObserver</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#InitObserver+code for \container36">3.6</a></dd>
 <dt><b></b></dt>
	<dd>InitWithAllocator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#InitWithAllocator+\container11">1.1</a>, 
		<a href="#InitWithAllocator+\container52">5.2</a>, 
		<a href="#InitWithAllocator+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#InitWithAllocator+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Insert</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Insert+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>InsertAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#InsertAt+\container11">1.1</a>, 
		<a href="#InsertAt+\container32">3.2</a>, 
		<a href="#InsertAt+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#InsertAt+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>InsertIn</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#InsertIn+\container11">1.1</a>, 
		<a href="#InsertIn+\container32">3.2</a>, 
		<a href="#InsertIn+\container52">5.2</a>, 
		<a href="#InsertIn+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#InsertIn+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Inverse</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Inverse+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>iPool, <a href="#iPool30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>iSequentiaContainer, <a href="#iSequentiaContainer142">14.2</a></dd>
 <dt><b></b></dt>
	<dd>istrCollection, <a href="#istrCollection50">5.0</a></dd>
 <dt><b></b></dt>
	<dd>Iterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Iterator+structure27">2.7</a></dd>
 <dt><b></b></dt>
	<dd>iterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Dictionary, <a href="#iterator+Dictionary33">3.3</a></dd>
 <dt><b></b></dt>
	<dd>iTreeMap, <a href="#iTreeMap70">7.0</a></dd>
 <dt><b></b></dt>
	<dd>iValArray, <a href="#iValArray120">12.0</a></dd>
 <dt><b></b></dt>
	<dd>iVector, <a href="#iVector30">3.0</a>, <a href="#iVector31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>iWstrCollection, <a href="#iWstrCollection50">5.0</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>List, <a href="#List03">0.3</a></dd>
 <dt><b></b></dt>
	<dd>ListIterator, <a href="#ListIterator27">2.7</a></dd>
 <dt><b></b></dt>
	<dd>lists</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code, <a href="#lists+code31">3.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; double linked, <a href="#lists+double linked20">2.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; single linked, <a href="#lists+single linked10">1.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#lists+structure22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>Load</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Load+\container11">1.1</a>, 
		<a href="#Load+\container32">3.2</a>, 
		<a href="#Load+\container62">6.2</a>, 
		<a href="#Load+\container82">8.2</a>, 
		<a href="#Load+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Load+code for \container31">3.1</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Malloc</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Malloc+code for \container35">3.5</a></dd>
 <dt><b></b></dt>
	<dd>mapcar, <a href="#mapcar30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>mapcon, <a href="#mapcon30">3.0</a></dd>
 <dt><b></b></dt>
	<dd>Max</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Max+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Memset</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Memset+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Merge</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Merge+\container82">8.2</a></dd>
 <dt><b></b></dt>
	<dd>Min</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Min+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Mismatch</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Mismatch+\container32">3.2</a>, 
		<a href="#Mismatch+\container52">5.2</a>, 
		<a href="#Mismatch+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>MultiplyWith</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#MultiplyWith+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>MultiplyWithScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#MultiplyWithScalar+\container123">12.3</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>NewIterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#NewIterator+\container11">1.1</a>, 
		<a href="#NewIterator+\container32">3.2</a>, 
		<a href="#NewIterator+\container62">6.2</a>, 
		<a href="#NewIterator+\container82">8.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#NewIterator+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>newObject</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#newObject+\container22">2.2</a></dd>
 <dt><b></b></dt>
	<dd>Not</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Not+\container12">1.2</a>, 
		<a href="#Not+\container42">4.2</a>, 
		<a href="#Not+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>NotAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#NotAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Notify</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Notify+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Notify+code for \container36">3.6</a></dd>
 <dt><b></b></dt>
	<dd>NullPtrError</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#NullPtrError+\container40">4.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>observer, <a href="#observer60">6.0</a></dd>
 <dt><b></b></dt>
	<dd>ObserverFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#ObserverFunction+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>Or</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Or+\container12">1.2</a>, 
		<a href="#Or+\container42">4.2</a>, 
		<a href="#Or+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>OrAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#OrAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>OrScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#OrScalar+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Overlay</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Overlay+\container82">8.2</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>PeekFront</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#PeekFront+\container132">13.2</a></dd>
 <dt><b></b></dt>
	<dd>PopBack</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#PopBack+\container20">2.0</a>, 
		<a href="#PopBack+\container32">3.2</a>, 
		<a href="#PopBack+\container52">5.2</a>, 
		<a href="#PopBack+\container101">10.1</a>, 
		<a href="#PopBack+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>PopFront</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#PopFront+\container11">1.1</a>, 
		<a href="#PopFront+\container101">10.1</a>, 
		<a href="#PopFront+\container132">13.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#PopFront+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>PopulationCount</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#PopulationCount+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Print</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Print+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Product</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Product+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>PushBack</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#PushBack+\container101">10.1</a></dd>
 <dt><b></b></dt>
	<dd>PushFront</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#PushFront+\container11">1.1</a>, 
		<a href="#PushFront+\container101">10.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#PushFront+code for \container31">3.1</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Queue, <a href="#Queue90">9.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>RaiseError</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#RaiseError+\container40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>Read</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Read+\container131">13.1</a></dd>
 <dt><b></b></dt>
	<dd>ReadFunction, <a href="#ReadFunction54">5.4</a></dd>
 <dt><b></b></dt>
	<dd>RemoveAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#RemoveAt+\container42">4.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#RemoveAt+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>RemoveRange</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#RemoveRange+\container11">1.1</a>, 
		<a href="#RemoveRange+\container32">3.2</a>, 
		<a href="#RemoveRange+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>Replace</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Replace+\container51">5.1</a>, 
		<a href="#Replace+\container82">8.2</a></dd>
 <dt><b></b></dt>
	<dd>ReplaceAt</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#ReplaceAt+\container11">1.1</a>, 
		<a href="#ReplaceAt+\container32">3.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#ReplaceAt+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>ResetSlice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#ResetSlice+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Resize</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Resize+\container32">3.2</a>, 
		<a href="#Resize+\container82">8.2</a>, 
		<a href="#Resize+\container131">13.1</a></dd>
 <dt><b></b></dt>
	<dd>Reverse</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Reverse+\container11">1.1</a>, 
		<a href="#Reverse+\container32">3.2</a>, 
		<a href="#Reverse+\container42">4.2</a>, 
		<a href="#Reverse+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Reverse+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>RotateLeft</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#RotateLeft+\container11">1.1</a>, 
		<a href="#RotateLeft+\container32">3.2</a>, 
		<a href="#RotateLeft+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#RotateLeft+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>RotateRight</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#RotateRight+\container11">1.1</a>, 
		<a href="#RotateRight+\container32">3.2</a>, 
		<a href="#RotateRight+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#RotateRight+code for \container31">3.1</a></dd>
</dl></td><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>Save</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Save+\container11">1.1</a>, 
		<a href="#Save+\container32">3.2</a>, 
		<a href="#Save+\container62">6.2</a>, 
		<a href="#Save+\container82">8.2</a>, 
		<a href="#Save+\container101">10.1</a>, 
		<a href="#Save+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Save+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>SaveFunction, <a href="#SaveFunction53">5.3</a></dd>
 <dt><b></b></dt>
	<dd>SearchWithKey</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SearchWithKey+\container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>Seek</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Seek+\container51">5.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Seek+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Select</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Select+\container11">1.1</a>, 
		<a href="#Select+\container32">3.2</a>, 
		<a href="#Select+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>SelectCopy</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SelectCopy+\container11">1.1</a>, 
		<a href="#SelectCopy+\container32">3.2</a>, 
		<a href="#SelectCopy+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Set</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Set+\container12">1.2</a>, 
		<a href="#Set+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>SetAllocator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetAllocator+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>SetCapacity</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetCapacity+\container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>SetCompareFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetCompareFunction+\container11">1.1</a>, 
		<a href="#SetCompareFunction+\container32">3.2</a>, 
		<a href="#SetCompareFunction+\container52">5.2</a>, 
		<a href="#SetCompareFunction+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#SetCompareFunction+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>SetDestructor</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetDestructor+\container11">1.1</a>, 
		<a href="#SetDestructor+\container32">3.2</a>, 
		<a href="#SetDestructor+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>SetErrorFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetErrorFunction+\container11">1.1</a>, 
		<a href="#SetErrorFunction+\container32">3.2</a>, 
		<a href="#SetErrorFunction+\container40">4.0</a>, 
		<a href="#SetErrorFunction+\container62">6.2</a>, 
		<a href="#SetErrorFunction+\container82">8.2</a></dd>
 <dt><b></b></dt>
	<dd>SetHashFunction</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetHashFunction+\container62">6.2</a></dd>
 <dt><b></b></dt>
	<dd>SetPosition</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetPosition+\container131">13.1</a></dd>
 <dt><b></b></dt>
	<dd>SetSlice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SetSlice+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>Size</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Size+\container11">1.1</a>, 
		<a href="#Size+\container12">1.2</a>, 
		<a href="#Size+\container32">3.2</a>, 
		<a href="#Size+\container62">6.2</a>, 
		<a href="#Size+\container82">8.2</a>, 
		<a href="#Size+\container123">12.3</a>, 
		<a href="#Size+\container131">13.1</a>, 
		<a href="#Size+\container132">13.2</a></dd>
 <dt><b></b></dt>
	<dd>Sizeof</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Sizeof+\container11">1.1</a>, 
		<a href="#Sizeof+\container12">1.2</a>, 
		<a href="#Sizeof+\container22">2.2</a>, 
		<a href="#Sizeof+\container32">3.2</a>, 
		<a href="#Sizeof+\container62">6.2</a>, 
		<a href="#Sizeof+\container82">8.2</a>, 
		<a href="#Sizeof+\container123">12.3</a>, 
		<a href="#Sizeof+\container132">13.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Sizeof+code for \container31">3.1</a>, 
		<a href="#Sizeof+code for \container32">3.2</a></dd>
 <dt><b></b></dt>
	<dd>SizeofIterator</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SizeofIterator+\container11">1.1</a></dd>
 <dt><b></b></dt>
	<dd>Sort</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Sort+\container11">1.1</a>, 
		<a href="#Sort+\container32">3.2</a>, 
		<a href="#Sort+\container123">12.3</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Sort+code for \container31">3.1</a></dd>
 <dt><b></b></dt>
	<dd>Splice</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Splice+\container20">2.0</a></dd>
 <dt><b></b></dt>
	<dd>strCollection</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#strCollection+structure26">2.6</a></dd>
 <dt><b></b></dt>
	<dd>StrError</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#StrError+\container40">4.0</a></dd>
 <dt><b></b></dt>
	<dd>StringCompareFn, <a href="#StringCompareFn52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>StringToBitString</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#StringToBitString+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>Subscribe</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Subscribe+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Subscribe+code for \container36">3.6</a></dd>
 <dt><b></b></dt>
	<dd>SubtractFrom</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SubtractFrom+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>SubtractFromScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SubtractFromScalar+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>SubtractScalarFrom</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SubtractScalarFrom+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>SumTo</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SumTo+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>SumToScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#SumToScalar+\container123">12.3</a></dd>
</dl></td></tr><tr><td width="48%" valign="top"><hr />
<dl compact="compact">
 <dt><b></b></dt>
	<dd>TreeMap, <a href="#TreeMap70">7.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Unsubscribe</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Unsubscribe+\container62">6.2</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#Unsubscribe+code for \container36">3.6</a></dd>
 <dt><b></b></dt>
	<dd>UseHeap</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#UseHeap+\container11">1.1</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; code for Observer, 
		<a href="#UseHeap+code for \container31">3.1</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>ValArray, <a href="#ValArray120">12.0</a></dd>
 <dt><b></b></dt>
	<dd>ValArrays,code, <a href="#ValArrays,code37">3.7</a></dd>
 <dt><b></b></dt>
	<dd>Vector, <a href="#Vector30">3.0</a></dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; structure, <a href="#Vector+structure24">2.4</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Write</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Write+\container131">13.1</a></dd>
 <dt><b></b></dt>
	<dd>WriteToFile</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#WriteToFile+\container52">5.2</a></dd>
 <dt><b></b></dt>
	<dd>WstrCollection, <a href="#WstrCollection50">5.0</a><br /><br /></dd>
 <dt><b></b></dt>
	<dd>Xor</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#Xor+\container42">4.2</a>, 
		<a href="#Xor+\container123">12.3</a></dd>
 <dt><b></b></dt>
	<dd>XorAssign</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#XorAssign+\container42">4.2</a></dd>
 <dt><b></b></dt>
	<dd>XorScalar</dd>
<dd>&nbsp;&nbsp;&nbsp;&nbsp; Observer, <a href="#XorScalar+\container123">12.3</a></dd>
</dl></td></tr></table>

<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>"Precise Reasoning for programs using containers" Isil Dillig, Thomas Dillig, and Alex Aitken, available on line at
http://www.stanford.edu/<font size="+1"><tt>!~!isil/popl2011.pdf</tt></font>or at POPL 2011 Proceedings of the 38th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages
ACM New York, NY, USA ©2011 
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>We were discussing 
the specifications of the <font size="+1"><tt>mismatach</tt></font> function of the C++ STL and why any error analysis is absent. The C++ STL prescribes a bounded 
region for the first container, but just a starting point for the second one. If the second is shorter than the specified range of the first
 <i>undefined behavior</i> ensues and anything can happen. In many cases this &#228;nything" is different each time the same error occurs. In our
specific case <font size="+1"><tt>mismatch</tt></font> would read from memory that doesn't belong to the container it started with. Depending on the contents of
that memory a crash could happen, or worst, a wrong result returned to the calling software, etc.
<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>Donald Knuth, the author of the TeX typesetting program can be without doubt be qualified as a good programmer (and an excellent computer scientist). But he, like anybody else, is not without flaws. See: 
www.tug.org/texmf-dist/doc/generic/knuth/errata/errorlog.pdf. There are hundreds of entries in that log.
<div class="p"><!----></div>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>Matthew Wilson uses a more restrictive definition of a container in his book &#203;xtended STL (Vol 1, page 16)" :
<div class="p"><!----></div>
  A container is a 
collection that owns its objects and provides operations by which those objects may be accessed and modified and, optionally, added removed and 
rearranged.
<div class="p"><!----></div>
  By this definition, containers that have just pointers to their elements woudn't be containers at all.
<div class="p"><!----></div>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>There is no automatic cleanup of objects left by active functions in the stack. This can be a problem or not, depending if your use a garbage collection or not. If you use a garbage collector, this problem doesn't even appear: the unused objects will be automatically collected. If you don't, you should test for the return code of each function.
<div class="p"><!----></div>
<a name="tthFtNtAAG"></a><a href="#tthFrefAAG"><sup>6</sup></a>This corresponds to ENOMEM in the POSIX1 standard.
<div class="p"><!----></div>
<a name="tthFtNtAAH"></a><a href="#tthFrefAAH"><sup>7</sup></a>The most similar error code using the POSIX standard would be <font size="-2">EPERM</font> here.
<div class="p"><!----></div>
<a name="tthFtNtAAI"></a><a href="#tthFrefAAI"><sup>8</sup></a>In the C99 standard this error is reserved for a wrong sequence of wide character bytes. Here it would 
be used for a wrong sequence of operations what somehow changes the meaning of the error code. It is used since the standard has only three error 
codes.
<div class="p"><!----></div>
<a name="tthFtNtAAJ"></a><a href="#tthFrefAAJ"><sup>9</sup></a>The POSIX error number would be here EIO: error in input/output
<div class="p"><!----></div>
<a name="tthFtNtABA"></a><a href="#tthFrefABA"><sup>10</sup></a>The corresponding POSIX error number would be EFBIG: file too big
<div class="p"><!----></div>
<a name="tthFtNtABB"></a><a href="#tthFrefABB"><sup>11</sup></a>In POSIX this would 
be EFAULT.
<div class="p"><!----></div>
<a name="tthFtNtABC"></a><a href="#tthFrefABC"><sup>12</sup></a>The corresponding POSIX error would EBADF: bad file
<div class="p"><!----></div>
<a name="tthFtNtABD"></a><a href="#tthFrefABD"><sup>13</sup></a>POSIX: EDOM, domain error
<div class="p"><!----></div>
<a name="tthFtNtABE"></a><a href="#tthFrefABE"><sup>14</sup></a>
Hashtables are present in all major computer languages:

<ul>
<li>  C# features a hashtable class that "Represents a collection of key/value pairs that are organized based on the hash code of the key." 
according to the documentation from Microsoft.
<div class="p"><!----></div>
</li>

<li>  Java has relatively recently added a HashTable class that "... maps keys to values. Any non-null object can be used as a key or as a value."
<div class="p"><!----></div>
</li>

<li>  Fortran doesn't include them in the language itself but there are librares that implement hash tables in Fortran. For instance 
Herbert J. Bernstein implemented a hash table library in Fortran 2003.
<div class="p"><!----></div>
</li>

<li>  In Common Lisp hash tables are standard: 
<font size="+1"><tt><i>make-hash-table</i></tt></font>
 and other functions implement all the needed functionality.
<div class="p"><!----></div>
</li>
</ul>
They were absent from the C++ STL for unknown reasons. They have been now incoporated into the latest C++ standard.

<div class="p"><!----></div>
<a name="tthFtNtABF"></a><a href="#tthFrefABF"><sup>15</sup></a>This incredibly useful feature has been made now optional by the C99 committee, even if it was mandatory when the C99 standard was published.
<div class="p"><!----></div>
<a name="tthFtNtABG"></a><a href="#tthFrefABG"><sup>16</sup></a>
Other frameworks use a similar method. For instance Apple Foundation classes has several classes that take an &#228;llocator" argument, for instance the
<font size="+1"><tt>CFBundleCreate</tt></font> and other functions that create objects.

<div class="p"><!----></div>
<a name="tthFtNtABH"></a><a href="#tthFrefABH"><sup>17</sup></a>In previous versions these functions returned some useful information in case of success, for instance the number of elements left. The problem is that an int can't span all the possible values of a <font size="+1"><tt>size_t</tt></font> data type but it is needed to return negative
error codes. If the result type would be a <font size="+1"><tt>size_t</tt></font> the negative error codes would be transformed in other values, etc. After some iterations 
the present solution was used: a positive number is equal to success, without specifying what the positive number is, or what information (if any) 
should be coded in it. The sample implementation always returns 1.
<div class="p"><!----></div>
<a name="tthFtNtABI"></a><a href="#tthFrefABI"><sup>18</sup></a>In general it is a bad idea to save elements containing pointers without a custom save/load function. The 
pointers restored are with almost certainty wrong when restored in another environment
<div class="p"><!----></div>
<a name="tthFtNtABJ"></a><a href="#tthFrefABJ"><sup>19</sup></a>Note that the container is not declared as <font size="+1"><tt>const</tt></font> and could possibly be modified either directly or 
indirectly by the function being applied to it. Some modifications like modifying the number of elements could lead to undefined behavior since it
is not required that the Apply loop tests at each iteration if the container has been modified
<div class="p"><!----></div>
<a name="tthFtNtACA"></a><a href="#tthFrefACA"><sup>20</sup></a>This is completely 
different to the C++ language. In C++ you may have an invalid iterator or not if you change the underlying container, depending on the 
operation and the specific container involved. This interface was discarded for the following reasons:

<ol type="1">
<li>  There are many rules to remember without underlying principles.
  You have to know the specifics of each container to know
  if the iterators are invalidated or not. This breaks the independence
   of the algorithm code from the underlying container.
<div class="p"><!----></div>
</li>

<li>  Any error leads directly to catastrophic consequences instead
   of being caught and signaled in an orderly fashion. Worst, errors
   do not produce always the same consequences, depending on what
   were the contents of the invalid memory you are using, on the
   memory allocation pattern, etc. In short, any error leads to
   very difficult maintenance problems.
<div class="p"><!----></div>
</li>

<li>  Any modifications of the container type lead to a review of
   all code that uses that container since the rules change from
   container to container. Iterators that worked could be invalid
   now. This another source of errors.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
<a name="tthFtNtACB"></a><a href="#tthFrefACB"><sup>21</sup></a>Contrary to C++ <font size="+1"><tt>const</tt></font> directive this is done at run time and an explicit check of this flag is needed. This has disadvantages 
(one instruction and a conditional jump are needed) but it has also advantages: you can set it when you pass some container to another module, and unset it when you need to update the container. This solution is more flexible than the static solution at the cost of a very small runtime cost.
<div class="p"><!----></div>
<a name="tthFtNtACC"></a><a href="#tthFrefACC"><sup>22</sup></a>In C++ the allocator receives the number of items to allocate.
<div class="p"><!----></div>
<a name="tthFtNtACD"></a><a href="#tthFrefACD"><sup>23</sup></a>An open issue is whether the interface of the memory allocator should be extended with functions like
<font size="+1"><tt>GetSize</tt></font> for instance, that would return the size of a given memory block, or other query functions like <font size="+1"><tt>isMallocBlock</tt></font> that would
allow to verify if a memory block belongs to the pool. Some proposals were discussed in the discussion group <font size="+1"><tt>comp.std.c</tt></font> but nothing official
has emerged from the committee meetings
<div class="p"><!----></div>
<a name="tthFtNtACE"></a><a href="#tthFrefACE"><sup>24</sup></a>An alternative design would have been to specify not one type of
observer function but to define a different function type for each possible message the containers could send. We would have then a SubscribeAdd
SubscribeErase SubscribeReplace functions, combined with NotifyAdd, NotifyErase, NotifyReplace functions. That design would have been easier to
control at compile time. It was rejected because of the increased complexity of the interface and the necessity for the user to define a lot
of functions just to know when something as simple as "Was this container modified?" happened.

<div class="p"><!----></div>
Obviously implementations can add that type of interface if they wish. In future revisions of this specifications this question will be posed again, with more actual use data to make more informed decisions.
<div class="p"><!----></div>
<a name="tthFtNtACF"></a><a href="#tthFrefACF"><sup>25</sup></a>See the full list and the description of all notifications at the end of this section
<div class="p"><!----></div>
<a name="tthFtNtACG"></a><a href="#tthFrefACG"><sup>26</sup></a>
The single linked list container corresponds to the C++ STL <font size="+1"><tt>forward_list</tt></font>.

<div class="p"><!----></div>
<a name="tthFtNtACH"></a><a href="#tthFrefACH"><sup>27</sup></a>Java, C++ and C# have a similar "Clear" functionality.
<div class="p"><!----></div>
<a name="tthFtNtACI"></a><a href="#tthFrefACI"><sup>28</sup></a>An alternative would have been to return the average string length, but that solution would have needed a result type different from a 
size_t (a floating point number would be needed), making this interface different from all other containers where this function returns a
size_t. A size_t of zero was choosen as a compromise solution. It would also have been possible to eliminate this function but that would have needed 
an interface change.
<div class="p"><!----></div>
  In all specializations it is needed to make compromises since the specialization is different from its original interface. One 
way to solve this is to try to keep the interface identical at the cost of some redundant or unnecessary functions. In this case the only function 
affected is <font size="+1"><tt>GetElementSize</tt></font> but in other specializations the differences could be more profound and other solutions could be better.
<div class="p"><!----></div>
<a name="tthFtNtACJ"></a><a href="#tthFrefACJ"><sup>29</sup></a>Again, implementations could improve this by storing a byte count that
is increased when a string is added and decreased when a string is eliminated, but that introduces more complexity and would penalize all users
of the string list, even those that never use Sizeof at all.
<div class="p"><!----></div>
<a name="tthFtNtADA"></a><a href="#tthFrefADA"><sup>30</sup></a>A similar function exists in the C++ STL: 
<font size="+1"><tt>max_size()</tt></font>
<div class="p"><!----></div>
<a name="tthFtNtADB"></a><a href="#tthFrefADB"><sup>31</sup></a>
The equivalent in C# is the <font size="+1"><tt>BitArray</tt></font> class in <font size="+1"><tt>System.Collections</tt></font>. In Java the equivalent is the BitSet class.

<div class="p"><!----></div>
<a name="tthFtNtADC"></a><a href="#tthFrefADC"><sup>32</sup></a>The Java language provides an interface in the class <font size="+1"><tt>java.util</tt></font>. C# offers a Queue class in <font size="+1"><tt>System.Collections</tt></font>, 
implemented as a circular array that is icreased automatically if needed. There is also a generic Queue class.

<div class="p"><!----></div>
 In C++ the definition is:
<font size="+1"><tt>template &lt; class T, class Container = deque&lt;T&#62; &#62; class queue;</tt></font>
Where

<ul>
<li>  <b>T</b>: Type of the elements.
<div class="p"><!----></div>
</li>

<li>  <b>Container</b>: Type of the underlying container object used to store and access the elements.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
<a name="tthFtNtADD"></a><a href="#tthFrefADD"><sup>33</sup></a>More about bloom filters in:
http://pages.cs.wisc.edu/&nbsp;cao/papers/summary-cache/node8.html,
<div class="p"><!----></div>
  and at the NIST: http://xw2k.nist.gov/dads/html/bloomFilter.html
<div class="p"><!----></div>
  The original paper about them was published by Burton Bloom: <b>Space/time trade-offs in hash coding with allowable errors.
Communications of ACM, pages 13(7):422-426, July 1970</b>.
<div class="p"><!----></div>
  The idea behind this data structure is to allocate a vector of m bits, initially all set to 0, and then choose k independent hash functions, h<sub>1</sub>, h<sub>2</sub>, &#8230;, h<sub>k</sub>,each with range {1,&#8230;,m}. For each element a  &#8712; A, the whole set, the bits at positions h1(a), h2(a), ..., hk(a) in v are set to 1. (A particular bit might be set to 1 multiple times). 

<div class="p"><!----></div>
Given a query for some key b we check the bits at positions h1(b), h2(b), ..., hk(b). If any of them is 0, then certainly b is not in the set A. Otherwise we conjecture that b is in the set although there is a certain probability that we are wrong. This is called a "false positive". The parameters k (the maximum number of elements) and m (the probability) should be chosen such that the probability m of a false positive (and hence a false hit) is acceptable.

<div class="p"><!----></div>
<a name="tthFtNtADE"></a><a href="#tthFrefADE"><sup>34</sup></a>In C++ the sequence <b>n,0,1</b>
is called <i>iota</i> as in the APL language. This can be obtained with <font size="+1"><tt>CreateSequence(n,0,1)</tt></font>
<div class="p"><!----></div>
<a name="tthFtNtADF"></a><a href="#tthFrefADF"><sup>35</sup></a>Some implementations can provide a debug mode where the left argument is somehow preserved, or provide a mode that replaces zero by one and continues. In all cases a division by zero should provoke an error.
<div class="p"><!----></div>
<a name="tthFtNtADG"></a><a href="#tthFrefADG"><sup>36</sup></a> Knuth, Donald E. (1998). The Art of Computer Programming.  Volume
2: Seminumerical Algorithms. Third edition. Section 4.2.2,
p. 233. Reading, MA: Addison-Wesley.  ISBN 0-201-89684-2.
<div class="p"><!----></div>
<a name="tthFtNtADH"></a><a href="#tthFrefADH"><sup>37</sup></a>
University of Michigan Center for the Study of Complex Systems
<div class="p"><!----></div>
 <font size="+1"><tt> &lt; mailto:Ted.Belding@umich.edu &gt; </tt></font>
<div class="p"><!----></div>
 <font size="+1"><tt>http://www-personal.umich.edu/&#126;  streak</tt></font>
<div class="p"><!----></div>
 
<div class="p"><!----></div>
<a name="tthFtNtADI"></a><a href="#tthFrefADI"><sup>38</sup></a>The rationale for this API is to simplify the <font size="+1"><tt>Apply</tt></font> function allowing full optimization for the compiler.
This function is used to implement all trigonometric/roots, and hyperbolic functions
<div class="p"><!----></div>
<a name="tthFtNtADJ"></a><a href="#tthFrefADJ"><sup>39</sup></a>For obvious reasons: using integers the inverse can have only a value of
one for the integer one, and zero for all others since we use integer division.
<div class="p"><!----></div>
<a name="tthFtNtAEA"></a><a href="#tthFrefAEA"><sup>40</sup></a>The smallest element is the identity value for the operation Max since <font size="+1"><tt>Max(a,smallest) ==&#62; a</tt></font> for all a
<div class="p"><!----></div>
<a name="tthFtNtAEB"></a><a href="#tthFrefAEB"><sup>41</sup></a>The biggest element is the identity value for the operation Min since <font size="+1"><tt>Min(a,biggest) ==&#62; a</tt></font> for all a
<div class="p"><!----></div>
<a name="tthFtNtAEC"></a><a href="#tthFrefAEC"><sup>42</sup></a>Keep in mind that in circular buffers new items can overwrite old items. Do not be surprised if you keep pointers to data in 
a circular buffer, that your data changes as you add items into it
<div class="p"><!----></div>
<a name="tthFtNtAED"></a><a href="#tthFrefAED"><sup>43</sup></a>Buffers exist in many languages. The C++ STL doesn't explicitely provide them, but other STL extensions do, like the one proposed by 
Matthew Wilson. In that implementation, buffers store only objects of a single type. In contrast to that this library proposes no typed buffers: each buffer can store
objects of any type without any limitations, the buffer doesn't care about the type of its objects.
<div class="p"><!----></div>
<a name="tthFtNtAEE"></a><a href="#tthFrefAEE"><sup>44</sup></a>Here, as in other APIs from the <font size="+1"><tt>buffer</tt></font> interface it was preferred to have a friendly interface than to cater for errors. In case of a zero return, you should test for a&nbsp;NULL pointer, but it is even better to test for it before calling this function.
<div class="p"><!----></div>
<a name="tthFtNtAEF"></a><a href="#tthFrefAEF"><sup>45</sup></a>The sample implementation allocates all the memory necessary for the container when creating it. This means that all n&times;ElementSize are allocated, copying the elements into it as they are added. This simplifies the management of circular buffers but is wasteful when the buffer is half empty.
<div class="p"><!----></div>
<a name="tthFtNtAEG"></a><a href="#tthFrefAEG"><sup>46</sup></a>
The Objective-C language has a similar constructs with its "Protocols". Several classes can share a common interface without any inheritance between them. Obviously in C there is no compiler support for this kind of programming, what forces your implementation to be careful about the order of the function pointers within all objects. A change in the order of those function pointers makes the object incompatible with the protocol specifications, and this can't be checked by the compiler.
All of this can be avoided, of course, if you just use the protocols designed and implemented by someone else.

<div class="p"><!----></div>
<a name="tthFtNtAEH"></a><a href="#tthFrefAEH"><sup>47</sup></a>Two special cases of specialized arrays have been presented: an array of strings and an array of bits. Many other arrays are possible and surely necessary for numeric work, and they could be used as basis for vector extensions with hardware support. Another subject not mentioned in this specification  is multi-dimensional arrays.
<div class="p"><!----></div>
<a name="tthFtNtAEI"></a><a href="#tthFrefAEI"><sup>48</sup></a>The &#203;rase" function  has been added to the generic interface because it has the same interface both in associative and sequential containers.The &#196;dd" function was left out because in associative containers you need a key argument to add data. This could have been fixed by defining a structure with two fields that would be passed as a single argument, but that would make things more complex than they need to be
<div class="p"><!----></div>
<a name="tthFtNtAEJ"></a><a href="#tthFrefAEJ"><sup>49</sup></a>For instance you can use <font size="+1"><tt>iList_Add</tt></font> for <font size="+1"><tt>iList.Add</tt></font>, or similar conventions. The specifications of the library do not define those macros to avoid invasion of the user's name space
<div class="p"><!----></div>
<a name="tthFtNtAFA"></a><a href="#tthFrefAFA"><sup>50</sup></a>Early versions of the library used the vector interface to maintain the association between an object and its callbacks. That meant that the vector interface would be pulled in too. And since the vector interface uses the heap interface object, that one would be pulled in also.
<div class="p"><!----></div>
<a name="tthFtNtAFB"></a><a href="#tthFrefAFB"><sup>51</sup></a>The constant <font size="+1"><tt>MINIMUM_ARRAY_INDEX</tt></font> is defined as 1 if we are compiling in C90 mode or as nothing if we are compiling in C99 mode. In C99 mode we have a flexible structure, that consists of a fixed and a variable part. The fixed part is the pointer to the next element. The variable part is the object we are storing in the list. 

<div class="p"><!----></div>
<a name="tthFtNtAFC"></a><a href="#tthFrefAFC"><sup>52</sup></a>Modern versions of the operating systems that use SPARC catch the exception, load the data with several instructions and return control
to the program transparently. This wasn't the case in the older versions, and anyway the SPARC example is an example for a whole class of machines
that require alignment.
<div class="p"><!----></div>
<a name="tthFtNtAFD"></a><a href="#tthFrefAFD"><sup>53</sup></a>The function <font size="+1"><tt>newContainer</tt></font> would clear the 'changed' bit, and the iterator 
functions would test if it is still clear. All modifications function would set it to one. This simple schema becomes problematic when you consider 
what happens when an invalid iterator is used again. In the simple one bit schema if the flag has been cleared, the iterator goes on, in the more 
expensive schema of the sample  implementation, the stalled iterators are never restartable until the counter wraps around to the same value.
<div class="p"><!----></div>
<a name="tthFtNtAFE"></a><a href="#tthFrefAFE"><sup>54</sup></a>Very often I use the name "rvp" for <b>r</b>o<b>v</b>ing <b>p</b>ointer
<div class="p"><!----></div>
<a name="tthFtNtAFF"></a><a href="#tthFrefAFF"><sup>55</sup></a>This has been
discussed several times in the comp.lang.c discussion group, but the committee never followed any of those proposals
<div class="p"><!----></div>
<a name="tthFtNtAFG"></a><a href="#tthFrefAFG"><sup>56</sup></a>But then, if the lists are small, the greater overhead of the double linked lists is small too. You see, there were a lot of good arguments from both sides
<div class="p"><!----></div>
<a name="tthFtNtAFH"></a><a href="#tthFrefAFH"><sup>57</sup></a>The function <font size="+1"><tt>Contains</tt></font> started its life as a way of avoiding all this problems
<div class="p"><!----></div>
<a name="tthFtNtAFI"></a><a href="#tthFrefAFI"><sup>58</sup></a>Looks easy isn't it? It isn't. It took me a while to arrive at the code above. Even worst is the reversing of a double linked list
<div class="p"><!----></div>
<a name="tthFtNtAFJ"></a><a href="#tthFrefAFJ"><sup>59</sup></a>In the very interesting web page 
<div class="p"><!----></div>
 http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx
<div class="p"><!----></div>
  In that page she also proposes to replace the addition operation with an XOR operations. She says that that improves the algorithm.
<div class="p"><!----></div>
<a name="tthFtNtAGA"></a><a href="#tthFrefAGA"><sup>60</sup></a>C Interfaces and Implementations, David R. Hanson, Addison Wesley. ISBN 0-201-49841-3 3rd printing June 2001 page 149
<div class="p"><!----></div>
<a name="tthFtNtAGB"></a><a href="#tthFrefAGB"><sup>61</sup></a>Note that the C++ <font size="+1"><tt>map::insert</tt></font> does not replace an element
<div class="p"><!----></div>
<a name="tthFtNtAGC"></a><a href="#tthFrefAGC"><sup>62</sup></a>According to the C99 standard, an unsigned int is at
least 16 bits what gives up to 16 different events.
<div class="p"><!----></div>
<a name="tthFtNtAGD"></a><a href="#tthFrefAGD"><sup>63</sup></a>In the first versions the Vector interface was used
to implement the table. This had several advantages, but since the observer interface is used by all
containers, the vector interface would be also included by all other containers, what would
mean too much code bloat. The solution was to replicate a subset of the functionality of the vector
interface here
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>Hgold</a>,
version 4.05 (hacked by jacob navia).<br />On 23 Apr 2012, 00:39.</small>
</html>
